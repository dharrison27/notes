# Certified Associate of Python Programming
## Contents

\#    | Title | Links
:---  | :---  | :---
0     | Introduction  | 
0.1   | Programming - absolute basics   | [`01`](#011-how-does-a-computer-program-work) [`02`](#012-natural-languages-vs-programming-languages) [`03`](#013-compilation-vs-interpretation) [`04`](#014-compilation-vs-interpretation) [`05`](#015-compilation-vs-interpretation) 
0.2   | Python - a tool, not a reptile  | [`01`](#021-what-is-python) [`02`](#022-who-created-python) [`03`](#023-who-created-python) [`04`](#024-why-python) [`05`](#025-why-not-python)
0.3   | There is more than one Python   | [`01`](#031-python-2-vs-python-3) [`02`](#032-python-aka-cpython) [`03`](#033-cython) [`04`](#034-jython) [`05`](#035-pypy-and-rpython)
0.4   | Begin your Python journey       | [`01`](#041-how-to-get-python-and-how-to-get-to-use-it) [`02`](#042-how-to-get-python-and-how-to-get-to-use-it) [`03`](#043-how-to-get-python-and-how-to-get-to-use-it) [`04`](#044-how-to-write-and-run-your-very-first-program) [`05`](#045-how-to-write-and-run-your-very-first-program) [`06`](#046-how-to-write-and-run-your-very-first-program) [`07`](#047-how-to-write-and-run-your-very-first-program) [`08`](#048-how-to-spoil-and-fix-your-code) [`09`](#049-how-to-spoil-and-fix-your-code) [`10`](#0410-how-to-spoil-and-fix-your-code) [`11`](#0411-how-to-spoil-and-fix-your-code)
0.5   | Edube Sandbox and Lab Tool      |  
1     | Basics: Part 1                  | 
1.1   | Your first program              | [`01`](#111-your-very-first-program) [`02`](#112-the-print-function) [`03`](#113-the-print-function) [`04`](#114-the-print-function) [`05`](#115-the-print-function) [`06`](#116-the-print-function) [`07`](#117-the-print-function) [`08`](#118-the-print-function) [`09`](#119-the-print-function) [`10`](#1110-the-print-function)<br/> [`11`](#1111-the-print-function) [`12`](#1113-the-print-function) [`13`](#1114-the-print-function) [`14`](#1114-the-print-function-1) [`15`](#1115-the-print-function) [`16`](#1116-the-print-function) [`17`](#1117-the-print-function) [`18`](#1118-the-print-function) [`19`](#1119-the-print-function) [`20`](#1120-the-print-function)<br/> [`21`](#1121-the-print-function) [`22`](#1122-the-print-function) [`23`](#1123-the-print-function)
1.2   | Python literals                 | [`01`](#121-literals-%e2%80%93-the-data-in-itself) [`02`](#122-literals-%e2%80%93-the-data-in-itself) [`03`](#123-literals-%e2%80%93-integers) [`04`](#124-literals-%e2%80%93-integers) [`05`](#125-literals-%e2%80%93-integers) [`06`](#126-literals-%e2%80%93-integers) [`07`](#127-literals-%e2%80%93-integers) [`08`](#128-literals-%e2%80%93-floats) [`09`](#129-literals-%e2%80%93-floats) [`10`](#1210-literals-%e2%80%93-floats)<br/> [`11`](#1211-literals-%e2%80%93-floats) [`12`](#1212-literals-%e2%80%93-floats) [`13`](#1213-literals-%e2%80%93-floats) [`14`](#1214-literals-%e2%80%93-floats) [`15`](#1215-literals-%e2%80%93-strings) [`16`](#1216-literals-%e2%80%93-strings) [`17`](#1217-literals-%e2%80%93-strings) [`18`](#1218-literals-%e2%80%93-strings) [`19`](#1219-literals-%e2%80%93-strings) [`20`](#1220-literals-%e2%80%93-strings)<br/> [`21`](#1221-literals-%e2%80%93-strings) [`22`](#1222-literals-%e2%80%93-boolean-values)
1.3   | Operators - data manipulation tools | [`01`](#131-operators-%e2%80%93-data-manipulation-tools) [`02`](#132-operators-%e2%80%93-data-manipulation-tools) [`03`](#133-arithmetic-operators-%e2%80%93-exponentiation) [`04`](#134-arithmetic-operators-%e2%80%93-exponentiation) [`05`](#135-arithmetic-operators-%e2%80%93-multiplication) [`06`](#136-arithmetic-operators-%e2%80%93-multiplication) [`07`](#137-arithmetic-operators-%e2%80%93-division)
1.4   | Variables - data-shaped boxes   | 
1.5   | How to talk to a computer       | 
2     | Basics: Part 2                  | 
2.1   | Making decisions in Python      | 
2.2   | Python's loops                  | 
2.3   | Logic and bit operations in Python  | 
2.4   | Lists - collections of data     | 
2.5   | Sorting a simple list - the bubble sort algorithm | 
2.6   | Lists - more details            | 
2.7   | Lists in advanced applications  | 
3     | Basics: Part 3                  | 
3.1   | Writing functions in Python     | 
3.2   | How functions communicate with their environment  | 
3.3   | Returning a result from a function  | 
3.4   | Scopes in Python                | 
3.5   | Creating functions!             | 
3.6   | Tuples and dictionaries         | 
4     | Intermediate: Part 1            | 
4.1   | Using modules                   | [`01`](#411-what-is-a-module) [`02`](#412-how-to-make-use-of-a-module) [`03`](#413-how-to-make-use-of-a-module) [`04`](#414-importing-a-module) [`05`](#415-importing-a-module) [`06`](#416-importing-a-module) [`07`](#417-importing-a-module) [`08`](#418-importing-a-module) [`09`](#419-importing-a-module) [`10`](#4110-importing-a-module)<br/> [`11`](#4111-importing-a-module) [`12`](#4112-importing-a-module) [`13`](#4113-importing-a-module) [`14`](#4114-importing-a-module) [`15`](#4115-importing-a-module) [`16`](#4116-importing-a-module) [`17`](#4117-importing-a-module) [`18`](#4118-importing-a-module) [`19`](#4119-importing-a-module) [`20`](#4120-importing-a-module)
4.2   | Some useful modules             | [`01`](#421-working-with-standard-modules) [`02`](#422-working-with-standard-modules) [`03`](#423-working-with-standard-modules) [`04`](#424-some-functions-from-the-math-module) [`05`](#425-some-functions-from-the-math-module) [`06`](#426-some-functions-from-the-math-module) [`07`](#427-some-functions-from-the-math-module) [`08`](#428-some-functions-from-the-math-module) [`09`](#429-is-there-real-randomness-in-computers) [`10`](#4210-some-functions-from-the-random-module)<br/> [`11`](#4211-some-functions-from-the-random-module) [`12`](#4212-some-functions-from-the-random-module) [`13`](#4213-some-functions-from-the-random-module) [`14`](#4214-some-functions-from-the-random-module) [`15`](#4215-how-to-know-where-you-are) [`16`](#4216-some-functions-from-the-platform-module) [`17`](#4217-some-functions-from-the-platform-module) [`18`](#4218-some-functions-from-the-platform-module) [`19`](#4219-some-functions-from-the-platform-module) [`20`](#4220-some-functions-from-the-platform-module)<br/> [`21`](#4221-some-functions-from-the-platform-module) [`22`](#4222-some-functions-from-python-modules)
4.3   | What is a package?              | [`01`](#431-modules-and-packages) [`02`](#432-your-first-module) [`03`](#433-your-first-module) [`04`](#434-your-first-module) [`05`](#435-your-first-module) [`06`](#436-your-first-module) [`07`](#437-your-first-module) [`08`](#438-your-first-module) [`09`](#439-your-first-module) [`10`](#4310-your-first-module)<br/> [`11`](#4311-your-first-module) [`12`](#4312-your-first-module) [`13`](#4313-your-first-module) [`14`](#4314-your-first-package) [`15`](#4315-your-first-package) [`16`](#4316-your-first-package) [`17`](#4317-your-first-package) [`18`](#4318-your-first-package) [`19`](#4319-your-first-package) [`20`](#4320-your-first-package)<br/> [`21`](#4321-your-first-package) [`22`](#4322-your-first-package) [`23`](#4323-your-first-package) [`24`](#4324-your-first-package)
4.4   | Errors - programmer's daily bread |
4.5   | The anatomy of exceptions       |
4.6   | Some of the most useful exceptions
4.7   | Characters and strings vs. computers
4.8   | The nature of strings in Python |
4.9   | String methods                  |
4.10  | Strings in action               |
4.11  | Four simple program             |
5     | Intermediate: Part 2            | 
5.1   | Basic concepts of object programming | [`01`](#511-basic-concepts-of-object-programming) [`02`](#512-basic-concepts-of-object-programming) [`03`](#513-basic-concepts-of-object-programming) [`04`](#514-basic-concepts-of-object-programming) [`05`](#515-the-object---what-is-it) [`06`](#516-the-object---what-is-it) [`07`](#517-what-does-any-object-have) [`08`](#518-your-first-class) [`09`](#519-your-first-class)
5.2   | A short journey from procedural to object approach | [`01`](#521-what-is-a-stack) [`02`](#522-the-stack-%e2%80%93-the-procedural-approach) [`03`](#523-the-stack-%e2%80%93-the-procedural-approach) [`04`](#524-the-stack-%e2%80%93-the-procedural-approach) [`05`](#525-the-stack-%e2%80%93-the-procedural-approach) [`06`](#526-the-stack-%e2%80%93-the-procedural-approach) [`07`](#527-a-stack-from-scratch) [`08`](#528-a-stack-from-scratch) [`09`](#529-a-stack-from-scratch) [`10`](#5210-a-stack-from-scratch)<br/> [`11`](#5211-a-stack-from-scratch) [`12`](#5212-a-stack-from-scratch) [`13`](#5213-a-stack-from-scratch) [`14`](#5214-a-stack-from-scratch) [`15`](#5215-a-stack-from-scratch) [`16`](#5216-a-stack-from-scratch) [`17`](#5217-a-stack-from-scratch) [`18`](#5218-a-stack-from-scratch) [`19`](#5219-a-stack-from-scratch)
5.3   | Properties                      | [`01`](#531-properties-in-detail) [`02`](#532-instance-variables) [`03`](#533-instance-variables) [`04`](#534-properties-in-detail) [`05`](#535-class-variables) [`06`](#536-class-variables) [`07`](#537-class-variables) [`08`](#538-checking-an-attributes-existence) [`09`](#539-checking-an-attributes-existence) [`10`](#5310-checking-an-attributes-existence)<br/> [`11`](#5311-checking-an-attributes-existence) [`12`](#5312-checking-an-attributes-existence) [`13`](#5313-checking-an-attributes-existence)
5.4   | Methods                         | [`01`](#541-methods-in-detail) [`02`](#542-methods-in-detail) [`03`](#543-methods-in-detail) [`04`](#544-methods-in-detail) [`05`](#545-methods-in-detail) [`06`](#546-methods-in-detail) [`07`](#547-methods-in-detail) [`08`](#548-methods-in-detail) [`09`](#549-the-inner-life-of-classes-and-objects) [`10`](#5410-the-inner-life-of-classes-and-objects)<br/> [`11`](#5411-the-inner-life-of-classes-and-objects) [`12`](#5412-reflection-and-introspection) [`13`](#5413-investigating-classes)
5.5   | Inheritance - one of object programming foundations | [1](#551-inheritance-%e2%80%93-why-and-how) [2](#552-inheritance-%e2%80%93-why-and-how) [3](#553-inheritance-%e2%80%93-why-and-how) [4](#554-inheritance-%e2%80%93-why-and-how) [5](#555-inheritance-%e2%80%93-why-and-how) [6](#556-inheritance-%e2%80%93-why-and-how) [7](#557-inheritance-%e2%80%93-why-and-how) [8](#558-inheritance-%e2%80%93-why-and-how) [9](#559-inheritance-%e2%80%93-why-and-how) [10](#5510-inheritance-%e2%80%93-why-and-how)<br/> [11](#5511-how-python-finds-properties-and-methods) [12](#5512-how-python-finds-properties-and-methods) [13](#5513-how-python-finds-properties-and-methods) [14](#5514-how-python-finds-properties-and-methods) [15](#5515-how-python-finds-properties-and-methods) [16](#5516-how-python-finds-properties-and-methods) [17](#5517-how-python-finds-properties-and-methods) [18](#5518-how-python-finds-properties-and-methods) [19](#5519-how-to-build-a-hierarchy-of-classes) [20](#5520-how-to-build-a-hierarchy-of-classes)<br/> [21](#5521-how-to-build-a-hierarchy-of-classes) [22](#5522-inheritance-vs-composition) [23](#5523-single-inheritance-vs-multiple-inheritance) [24](#5524-diamonds-and-why-you-dont-want-them) 
5.6   | Exceptions once again           | [`01`](#561-exceptions-once-again) [`02`](#562-exceptions-once-again) [3](#563-exceptions-are-classes-too) [4](#564-exceptions-are-classes-too) [5](#565-detailed-anatomy-of-exception) [6](#566-how-to-create-your-own-exception) [7](#567-how-to-create-your-own-exception) [8](#568-how-to-create-your-own-exception) [9](#569-how-to-use-your-own-exception) [10](#5610-how-to-use-your-own-exception)
5.7   | Generators and closures         | [`01`](#571-generators-%e2%80%93-where-to-find-them) [`2`](#572-generators-%e2%80%93-where-to-find-them) [`3`](#573-generators-%e2%80%93-where-to-find-them) [`4`](#574-the-yield-statement) [`5`](#575-the-yield-statement) [`6`](#576-the-yield-statement) [`7`](#577-how-to-build-your-own-generator) [`8`](#578-how-to-build-your-own-generator) [`9`](#579-how-to-build-your-own-generator) [`10`](#5710-how-to-build-your-own-generator)<br/> [`11`](#5711-how-to-build-your-own-generator) [`12`](#5712-how-to-build-your-own-generator) [`13`](#5713-more-about-list-comprehensions) [`14`](#5714-more-about-list-comprehensions) [`15`](#5715-more-about-list-comprehensions) [`16`](#5716-more-about-list-comprehensions) [`17`](#5717-more-about-list-comprehensions) [`18`](#5718-more-about-list-comprehensions) [`19`](#5719-the-lambda-function) [`20`](#5720-the-lambda-function)<br/> [`21`](#5721-how-to-use-lambdas-and-what-for) [`22`](#5722-how-to-use-lambdas-and-what-for) [`23`](#5723-how-to-use-lambdas-and-what-for) [`24`](#5724-how-to-use-lambdas-and-what-for) [`25`](#5725-how-to-use-lambdas-and-what-for) [`26`](#5726-a-brief-look-at-closures) [`27`](#5727-a-brief-look-at-closures) [`28`](#5728-a-brief-look-at-closures)
5.8   | Processing files                | [`01`](#581-accessing-files-from-python-code) [`02`](#582-file-names) [`03`](#583-file-names) [`04`](#584-file-names) [`05`](#585-file-names) [`06`](#586-file-names) [`07`](#587-file-streams) [`08`](#588-file-streams) [`09`](#589-file-handles) [`10`](#5810-file-handles)<br/> [`11`](#5811-file-handles) [`12`](#5812-opening-the-streams) [`13`](#5813-opening-the-streams) [`14`](#5814-opening-the-streams) [`15`](#5815-opening-the-streams) [`16`](#5816-opening-the-streams) [`17`](#5817-opening-the-streams) [`18`](#5818-selecting-text-and-binary-modes) [`19`](#5819-opening-the-stream-for-the-first-time) [`20`](#5820-pre-opened-streams)<br/> [21](#5821-pre-opened-streams) [22](#5822-pre-opened-streams) [23](#5823-pre-opened-streams) [24](#5824-closing-streams) [25](#5825-diagnosing-stream-problems) [26](#5826-diagnosing-stream-problems) [27](#5827-diagnosing-stream-problems) [28](#5828-diagnosing-stream-problems) 
5.9   | Working with real files         | [`01`](#591-dealing-with-text-files) [`02`](#592-dealing-with-text-files) [`03`](#593-dealing-with-text-files) [`04`](#594-dealing-with-text-files) [`05`](#595-dealing-with-text-files) [`06`](#596-dealing-with-text-files) [`07`](#597-dealing-with-text-files) [`08`](#598-dealing-with-text-files) [`09`](#599-what-is-bytearray) [`10`](#5910-what-is-bytearray)






### 0
#### 0.1.1 How does a computer program work?
This course aims to show you what the Python language is and what it is used for. Let’s start from the absolute basics.\
A program makes a computer usable. Without a program, a computer, even the most powerful one, is nothing more than an object. Similarly, without a player, a piano is nothing more than a wooden box.\ Computers are able to perform very complex tasks, but this ability is not innate. A computer’s nature is quite different.\
It can execute only extremely simple operations, e.g., a computer cannot evaluate the value of a complicated mathematical function by itself, although this isn’t beyond the realms of possibility in the near future.\
Contemporary computers can only evaluate the results of very fundamental operations, like adding or dividing, but they can do it very fast, and can repeat these actions virtually any number of times.\
Imagine that you want to know the average speed you’ve reached during a long journey. You know the distance, you know the time, you need the speed.\
Naturally, the computer will be able to compute this, but the computer is not aware of such things as distance, speed or time.\
Therefore, it is necessary to instruct the computer to:
- **accept a number** representing the distance;
- **accept a number** representing the travel time;
- **divide the former value by the latter and store** the result in the memory;
- **display the result** (representing the average speed) in a readable format.

These four simple actions form a program. Of course, these examples are not formalized, and they are very far from what the computer can understand, but they are good enough to be translated into a language the computer can accept. Language is the keyword. 

#### 0.1.2 Natural languages vs. programming languages
A **language** is a means (and a tool) for expressing and recording thoughts. There are many languages all around us. Some of them require neither speaking nor writing, such as body language; it’s possible to express your deepest feelings very precisely without saying a word.\ Another language you use each day is your mother tongue, which you use to manifest your will and to think about reality. Computers have their own language, too, called machine language, which is very rudimentary.\
A computer, even the most technically sophisticated, is devoid of even a trace of intelligence. You could say that it is like a well-trained dog – it responds only to a predetermined set of known commands.\ The commands it recognizes are very simple. We can imagine that the computer responds to orders like “take that number, divide by another and save the result”.\
A complete set of known commands is called an instruction list, sometimes abbreviated to IL. Different types of computers may vary depending on the size of their ILs, and the instructions could be completely different in different models.\ Note: machine languages are developed by humans.\ No computer is currently capable of creating a new language. However, that may change soon.\
On the other hand, people use a number of very different languages, too, but these languages created themselves. Moreover, they are still evolving.\
New words are created every day and old words disappear. These languages are called natural languages.\
What makes a language?\
We can say that each language (machine or natural, it doesn’t matter) consists of the following elements:
- **an alphabet**: a set of symbols used to build words of a certain language (e.g., the Latin alphabet for English, the Cyrillic alphabet for Russian, Kanji for Japanese, and so on) 
- **a lexis** aka a **dictionary**: a set of words the language offers its users (e.g., the word “computer” comes from the English language dictionary, while “cmoptrue” doesn’t; the word “chat” is present both in English and French dictionaries, but their meanings are different)
- **a syntax**: a set of rules (formal or informal, written or felt intuitively) used to determine if a certain string of words forms a valid sentence (e.g., “I am a python” is a syntactically correct phrase, while “I a python am” isn’t)
- **semantics**: a set of rules determining if a certain phrase makes sense (e.g., “I ate a doughnut” makes sense, but “A doughnut ate me” doesn’t)

The IL is, in fact, the alphabet of a machine language. This is the simplest and most primary set of symbols we can use to give commands to a computer. It’s the computer’s mother tongue.\ Unfortunately, this tongue is a far cry from a human mother tongue. We all (both computers and humans) need something else, a **common language** for computers and humans, or a **bridge between the two different worlds**.\ We need a language in which humans can write their programs and a language that computers may use to execute the programs, one that is far more complex than machine language and yet far simpler than natural language.\ Such languages are often called **high-level programming languages**. They are at least somewhat similar to natural ones in that they use symbols, words and conventions readable to humans. These languages enable humans to express commands to computers that are much more complex than those offered by ILs.\
A program written in a high-level programming language is called a source code (in contrast to the machine code executed by computers).\
Similarly, the file containing the source code is called the source file.

#### 0.1.3 Compilation vs. interpretation
Computer programming is the act of composing the selected programming language’s elements in the order that will cause the desired effect. The effect could be different in every specific case – it’s up to the programmer’s imagination, knowledge and experience.\
Of course, such a composition has to be correct in many senses:
- alphabetically – a program needs to be written in a recognizable script, such as Roman, Cyrillic, etc.  
- lexically – each programming language has its dictionary and you need to master it; thankfully, it’s much simpler and smaller than the dictionary of any natural language; 
- syntactically – each language has its rules and they must be obeyed; 
- semantically – the program has to make sense.

Unfortunately, a programmer can also make mistakes with each of the above four senses. Each of them can cause the program to become completely useless.\ Let’s assume that you’ve successfully written a program. How do we persuade the computer to execute it? You have to render your program into machine language.\
Luckily, the translation can be done by a computer itself, making the whole process fast and efficient.\
There are two different ways of transforming a program from a high-level programming language into machine language:
- **compilation** – the source program is translated once (however, this act must be repeated each time you modify the source code) by getting a file (e.g., an .exe file if the code is intended to be run under MS Windows) containing the machine code; now you can distribute the file worldwide; the program that performs this translation is called a compiler or translator;
- **interpretation** – you (or any user of the code) can translate the source program each time it has to be run; the program performing this kind of transformation is called an interpreter, as it interprets the code every time it is intended to be executed; it also means that you cannot just distribute the source code as-is, because the end-user also needs the interpreter to execute it.

Due to some very fundamental reasons, a particular high-level programming language is designed to fall into one of these two categories.\
There are very few languages that can be both compiled and interpreted. Usually, a programming language is projected with this factor in its constructors’ minds – will it be compiled or interpreted?

#### 0.1.4 Compilation vs. interpretation
What does the interpreter actually do?\
Let’s assume once more that you have written a program. Now, it exists as a computer file: a computer program is actually a piece of text, so the source code is usually placed in text files. Note: it has to be pure text, without any decorations like different fonts, colors, embedded images or other media.\
Now you have to invoke the interpreter and let it read your source file.\
The interpreter reads the source code in a way that is common in Western culture: from top to bottom and from left to right. There are some exceptions – they’ll be covered later in the course.
First of all, the interpreter checks if all subsequent lines are correct (using the four aspects covered earlier). If the compiler finds an error, it finishes its work immediately. The only result in this case is an error message. The interpreter will inform you where the error is located and what caused it. However, these messages may be misleading, as the interpreter isn’t able to follow your exact intentions, and may detect errors at some distance from their real causes.\
For example, if you try to use an entity of an unknown name, it will cause an error, but the error will be discovered in the place where it tries to use the entity, not where the new entity’s name was introduced. In other words, the actual reason is usually located a little earlier in the code, e.g., in the place where you had to inform the interpreter that you were going to use the entity of the name.\
If the line looks good, the interpreter tries to execute it (note: each line is usually executed separately, so the trio “read-check-execute” can be repeated many times – more times than the actual number of lines in the source file, as some parts of the code may be executed more than once).\
It is also possible that a significant part of the code may be executed successfully before the interpreter finds an error. This is normal behavior in this execution model.\

#### 0.1.5 Compilation vs. interpretation
You may ask now: which is better? The “compiling” model or the “interpreting” model?
There is no obvious answer. If there had been, one of these models would have ceased to exist a long time ago. Both of them have their advantages and their disadvantages.
Here is a list of the main ones →
\- | Compilation  | Interpretation
:--- | :--- | :---
Advantages | <ul><li>execution of the translated code is usually faster</li><li>only the user has to have the compiler - the end-user may use the code without it</li><li>translated code is stored using machine language - as it is hard to understand it, your own inventions and programming tricks are likely to remain your secret</li></ul> | <ul><li>you can run the code as soon as you complete it - there are no additional phases of translation</li><li>the code is stored using programming language, not the machine one - this means that it can be run on computers using different machine language: you don't compile your code separately for each different architecture</li></ul>
Disadvantages | <ul><li>the compilation itself may be a very time-consuming process - you may not be able to run your code immediately after any amendment</li><li>you have to have as many compilers as hardware platforms you want your code to be run on</li></ul> | <ul><li>don't expect that interpretation will ramp your code to high speed - your code will share the computer's power with the interpreter, so it can't be really fast</li><li>both you and the end user have to have the interpreter to run your code</li></ul>

What does this all mean for you?
1. Python is an interpreted language. This means that it inherits all the described advantages and disadvantages. Of course, it adds some of its unique features to both sets.
2. If you want to program in Python, you’ll need the Python interpreter. You won’t be able to run your code without it. Fortunately, Python is free. This is one of its most important advantages.

Due to historical reasons, languages designed to be utilized in the interpretation manner are often called scripting languages, while the source programs encoded using them are called scripts.

#### 0.2.1 What is Python?
While you may know the python as a large snake, the name of the Python programming language comes from an old BBC television comedy sketch series called Monty Python’s Flying Circus.\
At the height of its success, the Monty Python team were performing their sketches to live audiences across the world, including at the Hollywood Bowl.\
Since Monty Python is considered one of the two fundamental nutrients to a programmer (the other being pizza), Python’s creator named the language in honor of the TV show.

#### 0.2.2 Who created Python?
One of the amazing features of Python is the fact that it is actually one person’s work. Usually, new programming languages are developed and published by large companies employing lots of professionals, and due to copyright rules, it is very hard to name any of the people involved in the project. Python is an exception.\
There are not many languages whose authors are known by name.\
Python was created by Guido van Rossum, born in 1956 in Haarlem, the Netherlands.\
Of course, van Rossum did not develop and evolve all the Python components himself.\
The speed with which Python has spread around the world is a result of the continuous work of thousands (very often anonymous) programmers, testers, users (many of them aren’t IT specialists) and enthusiasts, but it must be said that the very first idea (the seed from which Python sprouted) came to one head – Guido’s.\
The circumstances in which Python was created are a bit puzzling. According to van Rossum:\
In December 1989, I was looking for a “hobby” programming project that would keep me occupied during the week around Christmas. My office (...) would be closed, but I had a home computer, and not much else on my hands. I decided to write an interpreter for the new scripting language I had been thinking about lately: a descendant of ABC that would appeal to Unix/C hackers. I chose Python as a working title for the project, being in a slightly irreverent mood (and a big fan of Monty Python’s Flying Circus).

#### 0.2.3 Who created Python?
In 1999, Guido van Rossum defined his goals for Python:
- an easy and intuitive language just as powerful as those of the major competitors;
- open source, so anyone can contribute to its development;
- code that is as understandable as plain English;
- suitable for everyday tasks, allowing for short development times.
About 20 years later, it is clear that all these intentions have been fulfilled. Some sources say that Python is the third-most popular programming language in the world, while others claim it’s the fifth.\
Either way, it still occupies a high rank in the top ten of the TIOBE Programming Community Index.\
Python isn’t a young language. It is mature and trustworthy. It’s not a one-hit wonder. It’s a bright star in the programming firmament, and time spent learning Python is a very good investment.

#### 0.2.4 Why Python?
What makes Python so special? How does it happen that programmers, young and old, experienced and novice, want to use it? How did it happen that large companies adopted Python and implemented their flagship products using it?\
There are many reasons – we’ve listed some of them already, but let’s enumerate them again in a more practical manner:
- it’s easy to learn – the time needed to learn Python is shorter than for many other languages; this means that it’s possible to start the actual programming faster;
- it’s easy to teach – the teaching workload is smaller than that needed by other languages; this means that the teacher can put more emphasis on general (language-independent) programming techniques, not wasting energy on exotic tricks, strange exceptions and incomprehensible rules;
- it’s easy to use for writing new software – it’s often possible to write code faster when using Python;
- it’s easy to understand – it’s also often easier to understand someone else’s code faster if it is written in Python;
- it’s easy to obtain, install and deploy – Python is free, open and multiplatform; not all languages can boast that.

 Of course, Python has its drawbacks, too:
- it’s not a speed demon – Python does not deliver exceptional performance;
- in some cases it may be resistant to some simpler testing techniques – this may mean that debugging Python’s code can be more difficult than with other languages; fortunately, making mistakes is always harder in Python.

It should also be stated that Python is not the only solution of its kind available on the IT market.\
It has lots of followers, but there are many who prefer other languages and don’t even consider Python for their projects.\
Python has two direct competitors, with comparable properties and predispositions. These are:
- Perl – a scripting language originally authored by Larry Wall;
- Ruby – a scripting language originally authored by Yukihiro Matsumoto.

The former is more traditional, more conservative than Python, and resembles some of the good old languages derived from the classic “C” programming language.\
In contrast, the latter is more innovative and more full of fresh ideas than Python. Python itself lies somewhere between these two creations.\
The Internet is full of forums with infinite discussions on the superiority of one of these three over the others, should you wish to learn more about each of them.

#### 0.2.5 Why not Python?
Where can we see Python in action?\
We see it every day and almost everywhere.\
It’s used extensively to implement complex Internet services like search engines, cloud storage and tools, social media and so on. Whenever you use any of these services, you are actually very close to Python, although you wouldn’t know it.\
Many developing tools are implemented in Python.\
More and more everyday use applications are being written in Python. Lots of scientists have abandoned expensive proprietary tools and switched to Python.\
Lots of IT project testers have started using Python to carry out repeatable test procedures. The list is long.\
Despite Python’s growing popularity, there are still some niches where Python is absent, or is rarely seen:
- low-level programming (sometimes called “close to metal” programming): if you want to implement an extremely effective driver or graphical engine, you wouldn’t use Python;
- applications for mobile devices: although this territory is still waiting to be conquered by Python, it will most likely happen someday.

#### 0.3.1 Python 2 vs. Python 3
There are two main kinds of Python, called Python 2 and Python 3.\
Python 2 is an older version of the original Python. It’s development has since been intentionally stalled, although that doesn’t mean that there are no updates to it. On the contrary, the updates are issued on a regular basis, but they are not intended to modify the language in any significant way. They rather fix any freshly discovered bugs and security holes. Python 2’s development path has reached a dead end already, but Python 2 itself is still very much alive.\
Python 3 is the newer (to be precise, the current) version of the language. It’s going through its own evolution path, creating its own standards and habits.\
These two versions of Python aren’t compatible with each other. Python 2 scripts won’t run in a Python 3 environment and vice versa, so if you want the old Python 2 code to be run by a Python 3 interpreter, the only possible solution is to rewrite it, not from scratch, of course, as large parts of the code may remain untouched, but you do have to revise all the code to find all possible incompatibilities. Unfortunately, this process cannot be fully automatized.\
It’s too hard, too time-consuming, too expensive, and too risky to migrate an old Python 2 application to a new platform. It’s possible that rewriting the code will introduce new bugs to it. It’s easier and more sensible to leave these systems alone and to improve the existing interpreter, instead of trying to work inside the already functioning source code.\
Python 3 isn’t just a better version of Python 2 – it is a completely different language, although it’s very similar to its predecessor. When you look at them from a distance, they appear to be the same, but when you look closely, though, you notice a lot of differences.\
If you’re modifying an old existing Python solution, then it’s highly likely that it was coded in Python 2. This is the reason why Python 2 is still in use. There are too many existing Python 2 applications to discard it altogether.\
If you’re going to start a new Python project, you should use Python 3, and this is the version of Python that will be used during this course.

#### 0.3.2 Python aka CPython
In addition to Python 2 and Python 3, there is more than one version of each.\
First of all, there are the Pythons which are maintained by the people gathered around the PSF (Python Software Foundation), a community that aims to develop, improve, expand, and popularize Python and its environment. The PSF’s president is Guido von Rossum himself, and for this reason, these Pythons are called “canonical”. They are also considered to be “reference Pythons”, as any other implementation of the language should follow all standards established by the PSF.\
Guido van Rossum used the “C” programming language to implement the very first version of his language and this decision is still in force. All Pythons coming from the PSF are written in the “C” language. There are many reasons for this approach and it has many consequences. One of them (probably the most important) is that thanks to it, Python may be easily ported and migrated to all platforms with the ability to compile and run “C” language programs (virtually all platforms have this feature, which opens up many expansion opportunities for Python).\
This is why the PSF implementation is often referred to as CPython. This is the most influential Python among all the Pythons in the world.

#### 0.3.3 Cython
Another Python family member is Cython.\
Cython is one of a possible number of solutions to the most painful of Python’s trait – the lack of efficiency. Large and complex mathematical calculations may be easily coded in Python (much easier than in “C” or any other traditional language), but the resulting code’s execution may be extremely time-consuming.\
How are these two contradictions reconciled?\
One solution is to write your mathematical ideas using Python, and when you’re absolutely sure that your code is correct and produces valid results, you can translate it into “C”.\
Certainly, “C” will run much faster than pure Python.\
This is what Cython is intended to do – to automatically translate the Python code (clean and clear, but not too swift) into “C” code (complicated and talkative, but agile).

#### 0.3.4 Jython
Another version of Python is called Jython.\
“J” is for “Java”.\
Imagine a Python written in Java instead of “C”. This is useful, for example, if you develop large and complex systems written entirely in Java and want to add some Python flexibility to them. The traditional CPython may be difficult to integrate into such an environment, as “C” and Java live in completely different worlds and don’t share many common ideas.\
Jython can communicate with existing Java infrastructure more effectively. This is why some projects find it usable and needful.\
Note: the current Jython implementation follows Python 2 standards. There is no Jython conforming to Python 3, so far.
 
#### 0.3.5 PyPy and RPython
Take a look at the logo →\
It’s a rebus. Can you solve it?\
It’s a logo of the PyPy – a Python within a Python.\
In other words, it represents a Python environment written in Python-like language named RPython (Restricted Python). It is actually a subset of Python. The source code of PyPy is not run in the interpretation manner, but is instead translated into the “C” programming language and then executed separately.\
This is useful because if you want to test any new feature that may be (but doesn’t have to be) introduced into mainstream Python implementation, it’s easier to check it with PyPy than with CPython. This is why PyPy is rather a tool for people developing Python than for the rest of the users.\
This doesn’t make PyPy any less important or less serious than CPython, of course.\
In addition, PyPy is compatible with the Python 3 language.\
There are many more different Pythons in the world. You’ll find them if you look, but this course will focus on CPython.

#### 0.4.1 How to get Python and how to get to use it
There are several ways to get your own copy of Python 3, depending on the operating system you use.\
Linux users most probably have Python already installed – this is the most likely scenario, as Python’s infrastructure is intensively used by many Linux OS components.\
For example, some distributors may couple their specific tools together with the system and many of these tools, like package managers, are often written in Python. Some parts of graphical environments available in the Linux world may use Python, too.\
If you’re a Linux user, open the terminal/console, and type:
```
python3
```
at the shell prompt, press Enter and wait. If you see something like this:
```
Python 3.4.5 (default, Jan 12 2017, 02:28:40)
[GCC 4.2.1 Compatible Clang 3.7.1 (tags/RELEASE_371/final)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
```
then you don’t have to do anything else.\ If Python 3 is absent, then refer to your Linux documentation in order to find how to use your package manager to download and install a new package – the one you need is named “python3” or its name begins with that.\
All non-Linux users can download a copy [here](https://www.python.org/downloads/)

#### 0.4.2 How to get Python and how to get to use it
Because the browser tells the site you’ve entered the OS you use, the only step you have to take is to click the appropriate Python version you want.\
In this case, select Python 3. The site always offers you the latest version of it.\
If you’re a Windows user, start the downloaded .exe file and follow all the steps. Leave the default settings the installer suggests for now, with one exception – look at the checkbox named Add Python 3.x to PATH and check it. This will make things easier.\
If you’re a macOS user, a version of Python 2 may already have been preinstalled on your computer, but since we will be working with Python 3, you will still need to download and install the relevant .pkg file from the Python site.

#### 0.4.3 How to get Python and how to get to use it
Now that you have Python 3 installed, it’s time to check if it works and make the very first use of it.\
This will be a very simple procedure, but it should be enough to convince you that the Python environment is complete and functional.\
There are many ways of utilizing Python, especially if you’re going to be a Python developer.\
To start your work, you need the following tools:
- an editor which will support you in writing the code (it should have some special features, not available in simple tools); this dedicated editor will give you more than the standard OS equipment;
- a console in which you can launch your newly written code and stop it forcibly when it gets out of control;
- a tool named a debugger, able to launch your code step by step and allowing you to inspect it at each moment of execution.

Besides its many useful components, the Python 3 standard installation contains a very simple but extremely useful application named IDLE.\
IDLE is an acronym: Integrated Development and Learning Environment.\
Navigate through your OS menus, find IDLE somewhere under Python 3.x and launch it.\
This is what you should see →\
![0.4.3 How to get Python and how to get to use it](043.jpg)
The window that appears on the screen is the Python console (or just console or Python shell, or shell). You will use it to execute simple Python commands and to see the effects of your programs’ executions. 

#### 0.4.4 How to write and run your very first program
It is now time to write and run your first Python 3 program.\
It will be very simple, for now.\
The first step is to create a new source file and fill it with code.\
Click File in the IDLE’s menu and choose New file.
![0.4.4 How to write and run your very first program](044.jpg)

#### 0.4.5 How to write and run your very first program
As you can see, IDLE opens a new window for you. You can use it to write and amend your code. →\
![0.4.5 How to write and run your very first program](045.jpg)
This is the editor window. Its only purpose is to be a workplace in which your source code is treated. Do not confuse the editor window with the shell window. They perform different functions.\
The editor window is currently untitled, but it’s good practice to start work by naming the source file.\
Click File (in the new window), then click Save as..., select a folder for the new file (the desktop is a good place for your first programming attempts) and chose a name for the new file.\
Note: don’t set any extension for the file name you are going to use. Python needs its files to have the .py extension, so you should rely on the dialog window’s defaults. Using the standard .py extension enables the OS to properly open these files.

#### 0.4.6 How to write and run your very first program
Now put just one line into your newly opened and named editor window.\
The line looks like this:
```py
print("Hisssssss...")
```
You can use the clipboard to copy the text into the file.\
We’re not going to explain the meaning of the program right now. You’ll find a detailed discussion in the next chapter.\
Take a closer look at the quotation marks. These are the simplest form of quotation marks (neutral, straight, dumb, etc.) commonly used in source files. Do not try to use typographic quotes (curved, curly, smart, etc.), used by advanced text processors, as Python doesn’t accept them.\
Both left and right (opening and closing) quotes should look the same. It they don’t, replace them.\
This program simply sends a couple of letters to the user. Technically, to the output console.\
Run it. Press F5, or click Run from the window’s menu and select Run module. This step activates the interpreter and forces it to read the code and to execute it.
![0.4.6 How to write and run your very first program](046.jpg)

#### 0.4.7 How to write and run your very first program
If everything goes okay and there are no mistakes in the code, the console window will show you the effects caused by running the program.\
In this case, the program hisses.\
Try to run it once again. And once more.\
Now close both windows now and return to the desktop.
![0.4.7 How to write and run your very first program](047.jpg)

#### 0.4.8 How to spoil and fix your code
Now start IDLE again.\
Click File, Open, point to the file you saved previously and let IDLE read it in.\
Try to run it again by pressing F5 when the editor window is active.\
As you can see, IDLE is able to save your code and retrieve it when you need it again.\
IDLE contains one additional and helpful feature.\ First, remove the closing parenthesis.\
Then enter the parenthesis again.\
Your code should look like the one to the side →
![0.4.8 How to spoil and fix your code](048.jpg)
Every time you put the closing parenthesis in your program, IDLE will show the part of the text limited with a pair of corresponding parentheses. This helps you to remember to place them in pairs.\
Remove the closing parenthesis again.\
The code becomes erroneous. It contains a syntax error now. IDLE should not let you run it.\
Try to run the program again.\
IDLE will remind you to save the modified file. Follow the instructions.

#### 0.4.9 How to spoil and fix your code
Watch all the windows carefully →
![0.4.9 How to spoil and fix your code](049.jpg)
 A new window appears – it says that the interpreter has encountered an EOF (end-of-file) although (in its opinion) the code should contain some more text.\
The editor window shows clearly where it happened.\
Fix the code now.
 
#### 0.4.10 How to spoil and fix your code
We have spoiled the code once again →
![0.4.10 How to spoil and fix your code](0410.jpg)
 We’ve removed one letter from the word print.\
Run the code by pressing <kbd>F5</kbd>.\
As you can see, Python is not able to recognize the error.

#### 0.4.11 How to spoil and fix your code
You may have noticed that the error message generated for the previous error is quite different from the first one.\
This is because the nature of the error is different and the error is discovered at a different stage of interpretation.\
The editor window will not provide any useful information regarding the error, but the console windows might.\
The message (in red) shows (in the subsequent lines):
- the traceback (which is the path that the code traverses through different parts of the program – you can ignore it for now, as it is empty in such a simple code);
- the location of the error (the name of the file containing the error, line number and module name); note: the number may be misleading, as Python usually shows the place where it first notices the effects of the error, not necessarily the error itself;
- the content of the erroneous line; note: IDLE’s editor window doesn’t show line numbers, but it displays the current cursor location at the bottom-right corner; use it to locate the erroneous line in a long source code;
- the name of the error and a short explanation.

![0.4.11 How to spoil and fix your code](0411.jpg)
### 1
#### 1.1.1 Your very first program
It’s time to start writing some real, working Python code. It’ll be very simple for the time being.\
As we’re going to show you some fundamental concepts and terms, these snippets of code won’t be serious or complex.\
Launch IDLE, create a new Python source file, fill it with this code, name the file and save it.\
```py
print("Pussy cat, pussy cat where have you been?")
```
Now run it. If everything goes okay, you’ll see the rhyme’s line in the IDLE console window.\
Alternatively, launch Edube Sandbox, enter the code in the editor window, and run it.\
If everything goes okay here, you'll see the line of text in the Edube console window.\
The code you have run should look familiar. You saw something very similar when we led you through the setting up of the IDLE environment.\ Now we’ll spend some time showing you what you’re actually seeing, and why it looks like this.  
As you can see, the first program consists of the following parts:
- the word print;
- an opening parenthesis;
- a quotation mark;
- a line taken from a classic nursery rhyme;
- another quotation mark;
- a closing parenthesis.

Each of the above plays a very important role in the code.

#### 1.1.2 The `print()` function
The word print that you can see here is a function name. That doesn’t mean that wherever the word appears it is always a function name. The meaning of the word comes from the context in which the word has been used.\ You’ve probably encountered the term function many times before, during math classes. You can probably also list several names of mathematical functions, like sine or log.\
Python’s functions, however, are more flexible, and can contain more content than their mathematical siblings.\
A function (in this context) is a separate part of the computer code,able to:
- **cause some effect** (e.g., send text to the terminal, create a file, draw an image, play a sound, etc.); this is something completely unheard of in the world of mathematics;
- **evaluate a value or some values** (e.g., the square root of a value or the length of a given text); this is what makes Python’s functions the relatives of mathematical concepts.

Moreover, many of Python’s functions can do the above two things together.\
Where do the functions come from?
- They may come from Python itself; the print function is one of this kind; such a function is an added value received together with Python and its environment (it is built-in); you don’t have to do anything special (e.g., ask anyone for anything) if you want to make use of it;
- they may come from one or more of Python’s add-ons named modules; some of the modules come with Python, others may require separate installation – whatever the case, they all need to be explicitly connected with your code (we’ll show you how to do that soon);
- you can write them yourself, placing as many functions as you want and need inside your program to make it simpler, clearer and more elegant.

The name of the function should be significant (the name of the print function is self-evident).\
Of course, if you’re going to make use of any already existing function, you have no influence on its name, but when you start writing your own functions, you should consider carefully your choice of names.

#### 1.1.3 The `print()` function
As we said before, a function may have:
- an effect;
- a result.

There’s also a third, very important, function component – the arguments.\
Mathematical functions usually take one argument, e.g., sin(x) takes an x, which is the measure of an angle.\
Python functions, on the other hand, are more versatile. Depending on the individual needs, they may accept any number of arguments – as many as necessary to perform their tasks. Note: any number includes zero – some Python functions don’t need any argument.\
In spite of the number of needed/provided arguments, Python functions strongly demand the presence of a pair of parentheses – opening and closing ones, respectively.\
If you want to deliver one or more arguments to a function, you place them inside the parentheses. If you’re going to use a function which doesn’t take any argument, you still have to have the parentheses.\
Note: to distinguish ordinary words from function names, place a pair of empty parentheses after their names, even if the corresponding function wants one or more arguments. This is a standard convention.\
The function we’re talking about here is `print()`.\
Does the `print()` function in this example have any arguments? Of course it does, but what are they?

#### 1.1.4 The `print()` function
The only argument delivered to the `print()` function in this example is a string.\
As you can see, the string is delimited with quotes – in fact, the quotes make the string – they cut out a part of the code and assign a different meaning to it.\
You can imagine that the quotes say something like: the text between us is not code. It isn’t intended to be executed, and you should take it as is.\
Almost anything you put inside the quotes will be taken literally, not as code, but as data. Try to play with this particular string – modify it, enter some new content, delete some of the existing content.\
There’s more than one way to specify a string inside Python’s code, but for now, though, this one is enough.\
So far, you have learned about two important parts of the code: the function and the string. We’ve talked about them in terms of syntax, but now it’s time to discuss them in terms of semantics.\

#### 1.1.5 The `print()` function
The function name (print in this case) along with the parentheses and argument(s), forms the function invocation. We’ll discuss this in more depth soon, but we should just shed a little light on it right now.\
What happens when Python encounters an invocation like this one?
- First, Python checks if the name specified is legal (it browses its internal data in order to find an existing function of the name; if this search fails, Python aborts the code);
- second, Python checks if the function’s requirements for the number of arguments allows you to invoke the function in this way (e.g., if a specific function demands exactly two arguments, any invocation delivering only one argument will be considered erroneous, and will abort the code’s execution);
- third, Python leaves your code for a moment and jumps into the function you want to invoke; of course, it takes your argument(s) too and passes it/them to the function;
- fourth, the function executes its code, causes the desired effect (if any), evaluates the desired result(s) (if any) and finishes its task;
- finally, Python returns to your code (to the place just after the invocation) and resumes its execution.

#### 1.1.6 The `print()` function
Three important questions have to be answered as soon as possible:
1. What is the effect the `print()` function causes?
The effect is very useful and very spectacular. The function takes its arguments (it may accept more than one argument and may also accept less than one argument) converts them into human-readable form if needed (as you may suspect, strings don’t require this action, as the string is already readable) and send the resulting data to the output device (usually the console); in other words, anything you put into the `print()` function will appear on your screen. No wonder then, that from now on, you’ll utilize `print()` very intensively to see the results of your operations and evaluations.
2. What arguments does `print()` expect? 
Any. We’ll show you soon that `print()` is able to operate with virtually all types of data offered by Python. Strings, numbers, characters, logical values, objects – any of these may be successfully passed to `print()`.
3. What value does the `print()` function evaluate?

None. Its effect is enough. `print()` does not evaluate anything.

#### 1.1.7 The `print()` function
You already know that this program contains one function invocation. In turn, the function invocation is one of the possible kinds of Python instruction. Ergo, this program consists of just one instruction.\ Of course, any complex program usually contains many more instructions than one. The question is: how do you couple more than one instruction into the Python code?\
Python’s syntax is quite specific in this area. Unlike most programming languages, Python requires that there cannot be more than one instruction in a line.\
A line can be empty (i.e., it may contain no instruction at all) but it must not contain two, three or more instructions. This is strictly prohibited.\
Note: Python makes one exception to this rule – it allows one instruction to spread across more than one line (which may be helpful when your code contains complex constructions).\
Let’s expand the code a bit. This is how it looks now →
```py
print("Pussy cat, pussy cat where have you been?")
print("I've been to London to look at the queen.")
```
Run it and note what you see in the console. 

#### 1.1.8 The `print()` function
Your Python console should now look like this →
```
Pussy cat, pussy cat where have you been?
I've been to London to look at the queen. 
```
This is a good opportunity to make some observations:
- the program invokes the `print()` function twice, and you can see two separate lines in the console – this means that `print()` begins its output from a new line each time it starts its execution; you can change this behavior, but you can also use it to your advantage;
- each `print()` invocation contains a different string, as its argument and the console content reflects it – this means that the instructions in the code are executed in the same order in which they have been placed in the source file; no next instruction is executed until the previous one is completed (there are some exceptions to this rule, but you can ignore them for now)

#### 1.1.9 The `print()` function
We’ve changed the example a bit – we’ve added one empty `print()` function invocation. We call it empty because we haven’t delivered any arguments to the function →
```py
print("Pussy cat, pussy cat where have you been?")
print()
print("I've been to London to look at the queen.")
```
Follow the example and make the same amendment in your editor window (don’t forget about the parentheses).\ Run it.\ What happens?

#### 1.1.10 The `print()` function
If everything goes right, you should see something like this →
```
Pussy cat, pussy cat where have you been? 

I've been to London to look at the queen. 
```
As you can see, the empty `print()` invocation is not as empty as you may have expected – it does output an empty line, or (this interpretation is also correct) its output is just a newline.\ This is not the only way to produce a newline in the output console. We’re now going to show you another way.

#### 1.1.11 The `print()` function
We’ve modified the code again. Look at it carefully →
```py
print("Pussy cat, pussy cat where have you been?")
print()
print("I've been to London to look at the queen.")
```
There are two very subtle changes – we’ve inserted a strange pair of characters inside the rhyme. They look like this:
```
\n
```
Interestingly, while you can see two characters, Python sees one.\ The backslash (\) has a very special meaning when used inside strings – this is called the escape character.\
The word escape should be understood specifically – it means that the series of characters in the string escapes for the moment (a very short moment) to introduce a special inclusion.\
In other words, the backslash doesn’t mean anything in itself, but is only a kind of announcement, that the next character after the backslash has a different meaning too.\The letter n placed after the backslash comes from the word newline.\
Both the backslash and the n form a special symbol named a newline character, which urges the console to start a new output line.\
This convention has two important consequences:
1. if you want to put just one backslash inside a string, don’t forget its escaping nature – you have to double it, e.g., such an invocation will cause an error:
```py
print("\")
```
while this one won’t:
```py
print("\\")
```
2. not all escape pairs (the backslash coupled with another character) mean something.

Run the code. 

#### 1.1.13 The `print()` function
This is what we’re going to test now →
```py
print("Pussy cat,"," pussy cat, ","where have you been?")
```
There is one `print()` function invocation, but it contains three arguments. All of them are strings.\
The arguments are separated by commas. We’ve surrounded them with spaces to make them more visible, but it’s not really necessary, and we won’t be doing it anymore.\
In this case, the commas separating the arguments play a completely different role than the comma inside the string. The former is a part of Python’s syntax, the latter is intended to be shown in the console.\
If you look at the code again, you’ll see that there are no spaces inside the strings.\ Run the code and see what happens.

#### 1.1.14 The `print()` function 
Your console should now be showing the following text →
```
Pussy cat, pussy cat where have you been?
```
The spaces, removed from the strings, have appeared again.\
Can you explain why?\
Two conclusions emerge from this example:
- a print() function invoked with more than one argument outputs them all on one line;
- the print() function puts a space between the outputted arguments on its own initiative.

#### 1.1.14 The `print()` function 
Your console should now be showing the following text →
```
Pussy cat, pussy cat where have you been?
```
The spaces, removed from the strings, have appeared again.\
Can you explain why?\
Two conclusions emerge from this example:
- a print() function invoked with more than one argument outputs them all on one line;
- the print() function puts a space between the outputted arguments on its own initiative.

#### 1.1.15 The `print()` function
Now that you know a bit about print() function customs, we’re going to show you how to change them.\
You should be able to predict this output without running the code.\
The way in which we are passing the arguments into the print() function is the most common in Python, and is called the positional way (this name comes from the fact that the meaning of the argument is dictated by its position, e.g., the second argument will be outputted after the first, not the other way round).\
Python offers another mechanism for the passing of arguments, which can be helpful when you want to convince the print() function to change its behavior a bit.\
We aren’t going to explain it in depth right now. We plan to do this when we talk about functions. For now, we simply want to show you how it works. Feel free to use it in your own programs.\
The mechanism is called **keyword arguments**. The name stems from the fact that the meaning of these arguments is taken not from its location (position) but from the special word (keyword) used to identify them.\
The print() function has two keyword arguments that you can use for your purposes. The first of them is named end.\

#### 1.1.16 The `print()` function
To the side, you can see a very simple example of using a keyword argument →
```py
print("My name is","Python",end=" ")
print("Monty Python")
```
In order to use it, it is necessary to know some rules:
- a keyword argument consists of three elements: a keyword identifying the argument (end here); an equal sign (=); and a value assigned to that argument;
- any keyword arguments have to be put after the last positional argument (this is very important)

In our example, we have made use of the end keyword argument, and set it to a string containing one space.\
Run the code to see how it works.

#### 1.1.17 The `print()` function
The output looks as follows now →
```
My name is Python Monty Python
```
As you can see, the end keyword argument determines the characters the print() function sends to the output once it reaches the end of its positional arguments.\ The default behavior reflects the situation where the end keyword argument is implicitly used in the following way:
```
end="\n"
```
And now it’s time to try something more difficult.

#### 1.1.18 The `print()` function
If you look carefully, you’ll see that we’ve used the end argument, but the string assigned to is empty (it contains no characters at all) →
```py
print("My name is ",end="")
print("Monty Python")
```
What will happen now?\
Run the program to find out.

#### 1.1.19 The `print()` function
As the end argument has been set to nothing, the print() function outputs nothing too, once its positional arguments have been exhausted.\
The output looks like this →
```
My name is Monty Python
```
Note: no newlines have been sent to the output.\
The string assigned to the end keyword argument can be of any length. Experiment with it if you want.

#### 1.1.20 The `print()` function
We’ve said previously that the print() function separates its outputted arguments with spaces. This behavior can be changed, too.  \
The keyword argument that can do this is named sep (like separator).  \
Look at the example →
```py
print("My","name","is","Monty","Python",sep="-")
```

#### 1.1.21 The `print()` function
The sep argument delivers the following results →
```
My-name-is-Monty-Python
```
The print() function uses a dash, instead of a space, to separate the outputted arguments.\
Note: the sep argument’s value may be an empty string, too. Try it for yourself.

#### 1.1.22 The `print()` function
Both keyword arguments may be mixed in one invocation, just like here →
```py
print("My","name","is",sep="_",end="*")
print("Monty","Python",sep="*",end="*\n")
```
The example doesn’t make much sense, but it visibly presents the interactions between `end` and `sep`.\
Can you predict the output?

#### 1.1.23 The `print()` function
This is how it looks now →
```
My_name_is*Monty*Python*
```
Now that you understand the `print()` function, you’re ready to consider how to store and process data in Python.\ Without `print()`, you wouldn’t be able to see any results.

#### 1.2.1 Literals – the data in itself
Now that you have a little knowledge of some of the powerful features offered by the print() function, it’s time to learn about some new issues, and one important new term – the literal.\
A literal is data whose values are determined by the literal itself.\
As this is a difficult concept to understand, a good example may be helpful.\
Take a look at the following set of digits:\
```
123
```
Can you guess what value it represents? Of course you can – it’s one hundred twenty three.\
But what about this:
```
c
```
Does it represent any value? Maybe. It can be the symbol of the speed of light, for example. It also can be the constant of integration. Or even the length of a hypotenuse in the sense of a Pythagorean theorem. There are many possibilities.\
You cannot choose the right one without some additional knowledge.\
And this is the clue – 123 is a literal, and c is not.\
You use literals to encode data and to put them into your code. We’re now going to show you some conventions you have to obey when using Python.\
Let’s start with a simple experiment – take a look at the snippet →\
```py
print("2")
print(2) 
```
The first line looks familiar. The second seems to be erroneous due to the visible lack of quotes.\
Try to run it.

#### 1.2.2 Literals – the data in itself
If everything went okay, you should now see two identical lines.
```
2
2
```
What happened? What does it mean?
Through this example, you encounter two different types of literals – a string, which you already know, and an integer number, something completely new.\
The print() function presents them in exactly the same way – this example is obvious, as their human-readable representation is also the same. Internally, in the computer’s memory, these two values are stored in completely different ways – the string exists as just a string – a series of letters.\
The number is converted into machine representation (a set of bits). The print() function is able to show them both in a form readable to humans.\
We’re now going to be spending some time discussing numeric literals and their internal life.\

#### 1.2.3. Literals – integers
You may already know a little about how computers perform calculations on numbers. Perhaps you’ve heard of the binary system, and know that it’s the system computers use for storing numbers, and that they can perform any operation upon them.\
We won’t explore the intricacies of positional numeral systems here, but we’ll say that the numbers handled by modern computers are of two types:\
- integers, that is, those which are devoid of the fractional part;
- and floating-point numbers (or simply floats), that contain (or are able to contain) the fractional part.
This definition is not entirely accurate, but quite sufficient for now. The distinction is very important, and the boundary between these two types of numbers is very strict. Both of these kinds of numbers differ significantly in how they’re stored in a computer memory and in the range of acceptable values.\
The characteristic of the numeric value which determines its kind, range, and application, is called the type.\
If you encode a literal and place it inside Python code, the form of the literal determines the representation (type) Python will use to store it in the memory.\
For now, let’s leave the floating-point numbers aside (we’ll come back to them soon) and consider the question of how Python recognizes integers.\
The process is almost like how you would write them with a pencil on paper – it’s simply a string of digits that make up the number. But there’s a reservation – you must not interject any characters that are not digits inside the number.\
Take, for example, the number eleven million one hundred and eleven thousand one hundred and eleven. If you took a pencil in your hand right now, you would write the number like this:\
```
11,111,111
```
or like this:
```
11.111.111
```
or even like this:
```
11 111 111
```
It’s clear that this provision makes it easier to read, especially when the number consists of many digits. However, Python doesn’t accept things like these. It’s prohibited. What Python does allow, though, is the use of underscores in numeric literals.\
Therefore, you can write this number as follows →
```
11111111
11_111_111
```

#### 1.2.4 Literals – integers
How do we code negative numbers in Python? As usual – by adding a minus. You can write →
```
-11111111
```

#### 1.2.5 Literals – integers
Positive numbers do not need to be preceded by the plus sign, but it’s permissible, if you wish to do it.\
The following lines describe the same number →
```
+11111111
11111111
```

#### 1.2.6 Literals – integers
There are two additional conventions in Python that are unknown to the world of mathematics. The first allows us to use numbers in an octal representation.\
If an integer number is preceded by an 0O or 0o prefix (zero-o), it will be treated as an octal value. This means that the number must contain digits taken from the [0..7] range only.\
`0o123` is an octal number with a (decimal) value equal to 83.\
The print() function does the conversion automatically – try this →
```
print(0o123)
```

#### 1.2.7 Literals – integers
The second allows us to use hexadecimal numbers. Such numbers should be preceded by the prefix 0x or 0X (zero-x).\
0x123 is a hexadecimal number with a (decimal) value equal to 291. The print() function can manage these values too →\
```py
print(0x123)
```

#### 1.2.8 Literals – floats
Now it’s time to talk about another type, which is designed to represent and to store the numbers that (as a mathematician would say) have a non-empty decimal fraction.\
They are the numbers that have (or may have) a fractional part after the decimal point, and although such a definition is very poor, it’s certainly sufficient for what we wish to discuss.\
Whenever we use a term like two and a half or minus zero point four, we think of numbers which the computer considers floating numbers →\
```
2.5
0.4
```

#### 1.2.9 Literals – floats
Note: two and a half looks normal when you write it in a program, although if your native language prefers to use a comma instead of a point in the number, you should ensure that your number doesn’t contain any commas at all.\
Python will not accept that, or (in very rare but possible cases) may misunderstand your intentions, as the comma itself has its own reserved meaning in Python.\
If you want to use just a value of two and a half, you should write it as shown to the side. Note once again – there is a point between 2 and 5 – not a comma.\
```
2.5
```

#### 1.2.10 Literals – floats
As you can probably imagine, the value of zero point four could be written in Python as 0.4\
But don’t forget this simple rule – you can omit zero when it is the only digit in front of or after the decimal point.\
In essence, you can write the value 0.4 as →\
```
.4
```
 
#### 1.2.11 Literals – floats
For example: the value of 4.0 could be written as →
```
4.
```
This will change neither its type nor its value.\
Note: the decimal point is essentially important in recognizing floating-point numbers in Python.\
Look at these two numbers:\
```
4
4.0
```
You may think that they are exactly the same, but Python sees them in a completely different way.
- 4 is an integer number
- 4.0 is a floating-point number

The point is what makes a float.

#### 1.2.12 Literals – floats
But it’s not only points that make a float. You can also use the letter e.\
When you want to use any numbers that are very large or very small, you can use scientific notation.\
Take, for example, the speed of light, expressed in meters per second. Written directly it would look like this:\
```
300000000
```
To avoid writing out so many zeros, physics textbooks use an abbreviated form, which you have probably already seen:
```
3 × 108
```
It reads: three times ten to the power of eight\
In Python, the same effect is achieved in a slightly different way – take a look:
```
3E8
```
The letter E (you can also use the lower-case letter e – it comes from the word exponent) is a concise record of the phrase times ten to the power of.\
Note:
- the exponent (the value after the E) has to be an integer;
- the base (the value in front of the E) may be an integer.

#### 1.2.13 Literals – floats
Let’s see how this convention is used to record numbers that are very small (in the sense of their absolute value, which is close to zero).\
A physical constant called Planck’s constant (and denoted as h), according to the textbooks, has the value of\
```
6.62607 × 10−34
```
If you would like to use it in a program, you should write it this way →
```py
6.62607E-34
```
 
#### 1.2.14 Literals – floats
Note: the fact that you’ve chosen one of the possible forms of coding float values doesn’t mean that Python will present it the same way.\
Python may sometimes choose different notation than you.\
For example, let’s say you’ve decided to use the following float literal:
```
0.0000000000000000000001
```
When you run this literal through Python:
```py
print(0.0000000000000000000001)
```
this is the result →
```
1e-22
```
Python always chooses the more economical form of the number’s presentation, and you should take this into consideration when creating literals.

#### 1.2.15 Literals – strings
Strings are used when you need to process text (like names of all kinds, addresses, novels, etc.), not numbers.\
You already know a bit about them, e.g., that strings need quotes the way floats need points.\
This is a very typical string →\
```
"I am a string"
```

#### 1.2.16 Literals – strings
However, there is a catch.\
The catch is how to encode a quote inside a string which is already delimited by quotes.\
Let’s assume that we want to print a very simple message saying →\
```
I like "Monty Python"
```
How do we do it without generating an error?

#### 1.2.17 Literals – strings
There are two possible solutions.\
The first is based on the concept we already know of the escape character, which you should remember is played by the backslash.\
The backslash can escape quotes too. A quote preceded by a backslash changes its meaning – it’s not a delimiter, but just a quote.\
This will work as intended →
```py
print("I like \"Monty Python\"")
```
Note: there are two escaped quotes inside the string – can you see them both?

#### 1.2.18 Literals – strings
The second solution may be a bit surprising.\
Python can use an apostrophe instead of a quote. Either of these characters may delimit strings, but you must be consistent.\
If you open a string with a quote, you have to close it with a quote.\
If you start a string with an apostrophe, you have to end it with an apostrophe.\
This example will work too →
```py
print('I like "Monty Python"')
```
Note: you don’t need to do any escaping here.

#### 1.2.19 Literals – strings
Now, the next question is how do you embed an apostrophe into a string placed between apostrophes?\
You should already know the answer, or to be precise, two possible answers.\
Try to write a string containing the following message:\
```
I'm Monty Python
```

#### 1.2.20 Literals – strings
Here are the answers →
```py
print('I\'m Monty Python')
print("I'm Monty Python")
```
As you can see, the backslash is a very powerful tool – it can escape not only quotes, but also apostrophes.

#### 1.2.21 Literals – strings
We’ve shown it already, but we want to emphasize this phenomenon once more – a string can be empty – it may contain no characters at all.\
An empty string still remains a string.
```py
''
""
```

#### 1.2.22 Literals – Boolean values
To conclude with Python’s literals, there are two additional ones.\
They’re not as obvious as any of the previous ones, as they’re used to represent a very abstract value – truthfulness.\
Each time you ask Python if one number is greater than another, the question results in the creation of some specific data – a Boolean value.\
The name comes from George Boole (1815–1864), the author of the fundamental work, The Laws of Thought, which contains the definition of Boolean algebra – a part of algebra which makes use of only two distinct values: true and false, denoted as 1 and 0.\
A programmer writes a program, and the program asks questions. Python executes the program, and provides the answers. The program must be able to react according to the received answers.\
Fortunately, computers know only two kinds of answers: yes, this is true or no, this is false. You’ll never get a response like I don’t know or probably yes, but I don’t know for sure.\
Python, then, is a binary reptile.\
These two Boolean values have strict denotations in Python →
```py
True
False
```
You cannot change anything – you have to take these symbols as they are, including case-sensitivity.

#### 1.3.1 Operators – data manipulation tools
Now, we’re going to show you a completely new side of the print() function. You already know that the function is able to show you the values of the literals passed to it by arguments.\
In fact, it can do something more. Take a look at the snippet →
```py
print(2+2)
```
Start IDLE, create a new source file, copy our example and press the F5 key.\
You should see the number four.\
Without taking this too seriously, you’ve just discovered that Python can be used as a calculator.\
Not a very handy one, and definitely not a pocket one, but a calculator nonetheless.\
Taking it more seriously, we are now entering the province of operators and expressions.

#### 1.3.2 Operators – data manipulation tools
An operator is a symbol of the programming language, which is able to operate on the values.\
For example, just as in arithmetic, the + (plus) sign is the operator which is able to add two numbers, giving the result of the addition.\
Not all Python operators are as obvious as the plus sign, though, so let’s go through some of the operators available in Python, and we’ll explain which rules govern their use, and how to interpret the operations they perform.\
We’ll begin with the operators which are associated with the most widely recognizable arithmetic operations.\
The order of their appearance is not accidental. We’ll talk more about it once we’ve gone through them all.\
Data and operators when connected together form expressions. The simplest expression is a literal itself.

#### 1.3.3 Arithmetic operators – exponentiation
A `**` (double asterisk) sign is an exponentiation (power) operator.\
Its left argument is the base, its right, the exponent.\
Classical mathematics prefers notation with superscripts, just like this:\
2<sup>3</sup>
Pure text editors don’t accept that, so Python uses ** instead:\
```py
2**3
```
Take a look at our example →
```py
print(2 ** 3)
print(2 ** 3.)
print(2. ** 3)
print(2. ** 3.)
```
Note: we’ve surrounded the double asterisks with spaces in our example.\
It’s not compulsory, but it improves the readability of the code.\
The example shows a very important feature of virtually all Python numerical operators.\
Run the code and look carefully at the results it produces.\
Can you see any regularity here?

#### 1.3.4 Arithmetic operators – exponentiation
The results look like this →
```
8
8.0
8.0
8.0
```
It’s possible to formulate the following rules based on this result:
- when both ** arguments are integers, the result is an integer, too;
- when at least one ** argument is a float, the result is a float, too.

This is an important distinction to remember.

#### 1.3.5 Arithmetic operators – multiplication
An `*` (asterisk) sign is a multiplication operator.\ Run the code and check if our integer vs float rule is still working.
```py
print(2 * 3)
print(2 * 3.)
print(2. * 3)
print(2. * 3.)
```

#### 1.3.6 Arithmetic operators – multiplication
```
6
6.0
6.0
6.0
```
Yes, it works.

#### 1.3.7 Arithmetic operators – division 
A / (slash) sign is a divisional operator. The value in front of the slash is a dividend, the value behind the slash, a divisor.\
Run the program and analyze the results.\
```py
print(6/3)
print(6/3.)
print(6./3)
print(6./3.)
```
### 2
### 3 
### 4
#### 4.1.1 What is a module?
Computer code has a tendency to grow. We can say that code that doesn’t grow is probably completely unusable or abandoned. A real, wanted, and widely used code develops continuously, as both users’ demands and users’ expectations develop in their own rhythms. A code which is not able to respond to users’ needs will be forgotten quickly, and instantly replaced with a new, better, and more flexible code. Be prepared for this, and never think that any of your programs is eventually completed. The completion is a transition state and usually passes quickly, after the first bug report. Python itself is a good example how the rule acts.\ Growing code is in fact a growing problem. A larger code always means tougher maintenance. Searching for bugs is always easier where the code is smaller (just as finding a mechanical breakage is simpler when the machinery is simpler and smaller). Moreover, when the code being created is expected to be really big (you can use a total number of source lines as a useful, but not very accurate, measure of a code’s size) you may want (or rather, you will be forced) to divide it into many parts, implemented in parallel by a few, a dozen, several dozen, or even several hundred individual developers.\ Of course, this cannot be done using one large source file, which is edited by all programmers at the same time. This will surely lead to a spectacular disaster.\
If you want such a software project to be completed successfully, you have to have the means allowing you to:
- **divide** all the tasks among the developers;
- **join** all the created parts into one working whole.

For example, a certain project can be divided into two main parts:
- the user interface (the part that communicates with the user using widgets and a graphical screen)
- the logic (the part processing data and producing results)

Each of these parts can be (most likely) divided into smaller ones, and so on.\ Such a process is often called **decomposition**.\ For example, if you were asked to arrange a wedding, you wouldn’t do everything yourself – you would find a number of professionals and split the task between them all.
How do you divide a piece of software into separate but cooperating parts? This is the question. Modules are the answer.

#### 4.1.2 How to make use of a module
The handling of modules consists of two different issues:
- the first (probably the most common) happens when you want to use an already existing module, written by someone else, or created by yourself during your work on some complex project – in this case you are the module’s **user**;
- the second occurs when you want to create a brand new module, either for your own use, or to make other programmers’ lives easier – you are the module’s **supplier**.

Let’s discuss them separately.

#### 4.1.3 How to make use of a module
First of all, a module is identified by its **name**. If you want to use any module, you need to know the name. A (rather large) number of modules is delivered together with Python itself. You can think of them as a kind of “Python extra equipment”.\ All these modules, along with the built-in functions, form the “Python standard library” – a special sort of library where modules play the roles of books (we can even say that folders play the roles of shelves). If you want to take a look at the full list of all “volumes” collected in that library, you can find it [ here ](https://docs.python.org/3/library/index.html).\ Each module consists of entities (like a book consists of chapters). These entities can be functions, variables, constants, classes, and objects. If you know how to access a particular module, you can make use of any of the entities it stores.\ Let’s start the discussion with one of the most frequently used modules, named math. Its name speaks for itself – the module contains a rich collection of entities (not only functions) which enable a programmer to effectively implement calculations demanding the use of mathematical functions, like `sin()` or `log()`.

#### 4.1.4 Importing a module
To make a module usable, you must **import** it (think of it like of taking a book off the shelf). Importing a module is done by an instruction named `import`. Note: `import` is also a keyword (with all the consequences of this fact).\ Let’s assume that you want to use two entities provided by the `math` module:
- a symbol (constant) representing a precise (as precise as possible using double floating-point arithmetic) value of π (although using a Greek letter to name a variable is fully possible in Python, the symbol is named pi – it’s a more convenient solution, especially for that part of the world which neither has nor is going to use a Greek keyboard)
- a function named `sin()` (the computer equivalent of the mathematical sine function)

Both these entities are available through the math module, but the way in which you can use them strongly depends on how the import has been done.

#### 4.1.5 Importing a module
The simplest way to import a particular module is to use the import instruction as follows →\ The clause contains:
- the `import` keyword;
- the **name** of the module which is subject to import.

The instruction may be located anywhere in your code, but it must be placed before the first use of any of the module’s entities.

#### 4.1.6 Importing a module
If you want to (or have to) import more than one module, you can do it by repeating the import clause, or by listing the modules after the `import` keyword, like here →\
```py
import math,sys
```
The instruction imports two modules, first the one named `math` and then the second named `sys`.\ The modules’ list may be arbitrarily long.

#### 4.1.7 Importing a module
To continue, you need to become familiar with an important term →\ Don’t worry, we won’t go into great detail – this explanation is going to be as short as possible.\ A **namespace** is a space (understood in a non-physical context) in which **some names exist** and the names don’t conflict with each other (i.e., there are not two different objects of the same name). We can say that each social group is a namespace – the group tends to name each of its members in a unique way (e.g., parents won’t give their children the same first names). This uniqueness may be achieved in many ways, e.g., by using nicknames along with the first names (it will work inside a small group like a class in a school) or by assigning special identifiers to all members of the group (the US Social Security Number is a good example of such practice).\ Inside a certain namespace, each name must remain **unique**. This may mean that some names may disappear when any other entity of an already known name enters the namespace. We’ll show you how it works and how to control it, but first, let’s return to imports.

#### 4.1.8 Importing a module
If the module of a specified name **exists** and is **accessible** (a module is in fact a **Python source file**), Python imports its contents, i.e., **all the names defined in the module become known**, but they don’t enter your code’s namespace.\ This means that you can have your own entities named `sin` or `pi` and they won’t be affected by the import in any way.\ At this point, you may be wondering how to access the `pi` coming from the `math` module.\ To do this, you have to qualify the `pi` with the name of its original module.

#### 4.1.9 Importing a module
This is the way in which you qualify the names of `pi` and `sin` with the name of its originating module →\
```
math.pi
math.sin
```
It’s simple, you put: 
- the name of the module (math here)
- a dot;
- the name of the entity (pi here)

Such a form clearly indicates the namespace in which the name exists.\ Note: using this qualification is compulsory if a module has been imported by the `import` module instruction. It doesn’t matter if any of the names from your code and from the module’s namespace are in conflict or not.

#### 4.1.10 Importing a module
This first example won’t be very advanced – we just want to print the value of sin(1⁄2π).\ This is how to test it →
```py
import math
print(math.sin(math.pi/2))
```
The code outputs the expected value:
```
1.0
```
Note: removing any of the two qualifications will make the code erroneous. There is no other way to enter `math`’s namespace if you did the following:
```py
import math
```

#### 4.1.11 Importing a module
Now we’re going to show you how the two namespaces (yours and the module’s one) can coexist.\ Take a look at the example →
```py
import math
def sin(x):
  if 2 * x == pi:
    return 0.99999999
  else:
    return None
pi=3.14
print(sin(pi/2))
print(math.sin(math.pi/2))
```
We’ve defined our own `pi` and `sin` here. The code produces the following output:
```
0.99999999
1.0
``` 
As you can see, the entities don’t affect each other.

#### 4.1.12 Importing a module
In the second method, the import’s syntax precisely points out which module’s entity (or entities) are acceptable in the code →\
```py
from math import pi
```
The instruction consists of the following elements: 
- the `from` keyword;
- the **name of the module** to be (selectively) imported;
- the `import` keyword;
- the **name or list of names of the entity/entities** which are being imported into the namespace.

The instruction has this effect:
- the listed entities (and only those ones) are **imported from the indicated module**;
- the names of the imported entities **are accessible without qualification**.

Note: no other entities are imported. Moreover, you cannot import additional entities using a qualification – a line like this one:
```py
print(math.e)
```
will cause an error (e is Euler’s number: 2.71828...)\ Let’s rewrite the previous script to incorporate the new technique.

#### 4.1.13 Importing a module
Here it is →
```py
from math import sin,pi
print(sin(pi/2))
```
The output is the same as previously, as in fact we’ve used the same entities as before:
```
1.0
```
Does the code look simpler? Maybe, but the look is not the only effect of this kind of import. Let’s show you that.

#### 4.1.14 Importing a module
Analyze the code carefully →
- line 01: carry out the selective import;
- line 02: make use of the imported entities and get the expected result (1.0)
- lines 03 through 08: redefine the meaning of pi and sin – in effect, they supersede the original (imported) definitions within the code’s namespace;
- line 09: get 0.99999999, which confirms our conclusions.
```py
from math import sin,pi
print(sin(pi/2))
pi=3.14
def sin(x):
  if 2 * x == pi:
    return 0.99999999
  else:
    return None
print(Sin(pi/2))
```

#### 4.1.15 Importing a module
Here, we’ve reversed the sequence of the code’s operations →
```py
pi = 3.14
def sin(x):
  if 2 * x == pi:
    return 0.99999999
  else:
    return None
print(sin(pi/2))
from math import sin,pi
print(sin(pi/2))
```
- lines 01 through 06: define our own pi and sin;
- line 07: make use of them ( 0.99999999 appears on screen)
- line 08: carry out the import – the imported symbols supersede their previous definitions within the namespace;
- line 09: get 1.0 as a result.

Let’s do another test.

#### 4.1.16 Importing a module
In the third method, the import’s syntax is a more aggressive form of the previously presented one →
```py
from module import *
```
As you can see, the name of an entity (or the list of entities’ names) is replaced with a single asterisk (*).\ Such an instruction imports all entities from the indicated module.\ Is it convenient? Yes, it is, as it relieves you of the duty of enumerating all the names you need.\ Is it unsafe? Yes, it is – unless you know all the names provided by the module, you may not be able to avoid name conflicts. Treat this as a temporary solution, and try not to use it in regular code.

#### 4.1.17 Importing a module
If you use the import module variant and you don’t like a particular module’s name (e.g., it’s the same as one of your already defined entities, so qualification becomes troublesome) you can give it any name you like – this is called aliasing. Aliasing causes the module to be identified under a different name than the original. This may shorten the qualified names, too.\
Creating an alias is done together with importing the module, and demands the following form of the import instruction →
```py
import module as alias
```
The “module” identifies the original module’s name while the “alias” is the name you wish to use instead of the original.\ Note: `as` is a keyword.

#### 4.1.18 Importing a module
If you need to change the word math, you can introduce your own name, just like in the example →
```py
import math as M
print(M.sin(M.pi/2))
```
Note: after successful execution of an aliased import, the original module name becomes inaccessible and must not be used.

#### 4.1.19 Importing a module
In turn, when you use the from module import name variant and you need to change the entity’s name, you make an alias for the entity. This will cause the name to be replaced by the alias you choose.\ This is how it can be done → 
```py
from module import name as alias
```
As previously, the original (unaliased) name becomes inaccessible.\ The phrase name as alias can be repeated – use commas to separate the multiplied phrases, like this:
```py
from module import n as a, m as b, o as c
```
 
#### 4.1.20 Importing a module
The example may look a bit weird, but it works. →
```py
from math import pi as PI, sin as sine
print(sine(PI/2))
```
Now you’re familiar with the basics of using modules. Let us show you some modules and some of their useful entities.

#### 4.2.1 Working with standard modules
Before we start going through some standard Python modules, we want to introduce the dir() function to you. It has nothing to do with the dir command you know from Windows and Unix consoles, as dir()doesn’t show the contents of a disk directory/folder, but there is no denying that it does something really similar – it is able to reveal all the names provided through a particular module. There is one condition: the module has to have been previously imported as a whole (i.e., using the import module instruction – from module is not enough).\
The function returns an alphabetically sorted list containing all entities’ names available in the module identified by a name passed to the function as an argument. Note: if the module’s name has been aliased, you must use the alias, not the original name.\ Using the function inside a regular script doesn’t make much sense, but it is still possible.
```py
dir(module)
```

#### 4.2.2 Working with standard modules
For example, you can run the following code to print the names of all entities within the math module →
```py
import math

for name in dir(math):
  print(name,end='\t')
```
Have you noticed these strange names beginning with __ at the top of the list? We’ll tell you more about them when we talk about the issues related to writing your own modules.\ Some of the names might bring back memories from math lessons, and you probably won’t have any problems guessing their meanings.\
The example code produces the following output:
```
__doc__     __file__    __loader__  __name__    __package__      __spec__    acos  acosh asin  asinh atanatan2   atanh ceil      copysign    cos   cosh  degrees     e     erf   erfc  exp      expm1 fabs  factorial   floor fmod  frexp fsum  gamma hypot      isfinite    isinf isnan ldexp lgamma      log   log10 log1p log2      modf  pi    pow   radians     sin   sinh  sqrt  tan   tanh      trunc
```

#### 4.2.3 Working with standard modules
Using the dir() function inside a code may not seem very useful – usually you want to know a particular module’s contents before you write and run the code.\ Fortunately, you can execute the function directly in the Python console, without needing to write and run a separate script.\ This is how it can be done →
![](423.jpg)

#### 4.2.4 Some functions from the math module
Let’s start with a quick preview of some of the functions provided by the math module. We’ve chosen them arbitrarily, but that doesn’t mean that the functions we haven’t mentioned here are any less significant. Dive into the modules’ depths yourself – we don’t have the space or the time to talk about everything in detail here.\ The first group of the math’s functions are connected with trigonometry:
- sin(x)→ the sine of x;
- cos(x)→ the cosine of x;
- tan(x)→ the tangent of x.

All these functions take one argument (an angle measurement expressed in radians) and return the appropriate result (be careful with tan() – not all arguments are accepted). Of course, there are also their inversed versions:
- asin(x)→ the arcsine of x;
- acos(x)→ the arccosine of x;
- atan(x)→ the arctangent of x.

These functions take one argument (mind the domains) and return a measure of an angle in radians.\ To effectively operate on angle measurements, the math module provides you with the following entities:\
- pi→ a constant with a value that is an approximation of π;
- radians(x)→ a function that converts x from degrees to radians;
- degrees(x)→ acting in the other direction (from radians to degrees)

The example program isn’t very sophisticated, but can you predict its results? →
```py
from math import pi,radians,degrees,sin,cos,tan
ad = 90
ar = radians(ad)
ad = degrees(ar)
print(ad==90)
print(ar==pi/2.)
print(sin(ar)/cos(ar)==tan(ar))
print(asin(sin(ar))==ar)
```
Apart from the circular functions (listed above) the math module also contains a set of their hyperbolic analogues:
- sinh(x)→ the hyperbolic sine;
- cosh(x)→ the hyperbolic cosine;
- tanh(x)→ the hyperbolic tangent;
- asinh(x)→ the hyperbolic arcsine;
- acosh(x)→ the hyperbolic arccosine;
- atanh(x)→ the hyperbolic arctangent.

#### 4.2.5 Some functions from the math module
Were you able to answer the previous question? →
```
True
True
True
True
```

#### 4.2.6 Some functions from the math module
Another group of the math’s functions is formed by functions which are connected with exponentiation:
- e→ a constant with a value that is an approximation of Euler’s number (e)
- exp(x)→ finding the value of ex;
- log(x)→ the natural logarithm of x
- log(x, b)→ the logarithm of x to base b
- log10(x)→ the decimal logarithm of x (more precise than log(x,10))
- log2(x)→ the binary logarithm of x (more precise than log(x,2))

Note: the pow() function:
- pow(x,y)→ finding the value of xy (mind the domains)

This is a built-in function, and doesn’t have to be imported.\ Can you predict the code’s output? →
```py
from math import e,exp,log

print(pow(e,1)==exp(log(e)))
print(pow(2,2)==exp(2*log(2)))
print(log(e,e)==exp(0))
```

#### 4.2.7 Some functions from the math module
This is the output of the code → 
```
True
True
True
```

#### 4.2.8 Some functions from the math module
The last group consists of some general-purpose functions like:
- ceil(x)→ the ceiling of x (the smallest integer greater than or equal to x)
- floor(x)→ the floor of x (the largest integer less than or equal to x)
- trunc(x)→ the value of x truncated to an integer (be careful – it’s not an equivalent either of ceil or floor)
- factorial(x)→ returns x! (x has to be an integral and not a negative)
- hypot(x,y)→ returns the length of the hypotenuse of a right-angle triangle with the leg lengths equal to x and y (the same as sqrt(pow(x,2)+pow(y,2)) but more precise)

Analyze the example program carefully →
```py
from math import ceil,floor,trunc

x=1.4
y=2.6
print(floor(x),floor(y))
print(floor(-x),floor(-y))
print(ceil(x),ceil(y))
print(ceil(-x),ceil(-y))
print(trunc(x),trunc(y))
print(trunc(-x),trunc(-y))
```
It demonstrates the fundamental differences between ceil(), floor() and trunc().\ Its output is:
```
1 2
-2 -3
2 3
-1 -2
1 2
-1 -2
```

#### 4.2.9 Is there real randomness in computers?
Another module worth mentioning is the one named random. It delivers some mechanisms allowing you to operate with pseudorandom numbers.\ Note the prefix pseudo – the numbers generated by the modules may look random in the sense that you cannot predict their subsequent values, but don’t forget that they all are calculated using very refined algorithms.\ The algorithms aren’t random – they are deterministic and predictable. Only those physical processes which run completely out of our control (like the intensity of cosmic radiation) may be used as a source of actual random data. Data produced by deterministic computers cannot be random in any way.\ A random number generator takes a value called a seed, treats it as an input value, calculates a “random” number based on it (the method depends on a chosen algorithm) and produces a new seed value.\ The length of a cycle in which all seed values are unique may be very long, but it isn’t infinite – sooner or later the seed values will start repeating, and the generating values will repeat, too. This is normal. It’s a feature, not a mistake, or a bug.\ The initial seed value, set during the program start, determines the order in which the generated values will appear.\ The random factor of the process may be augmented by setting the seed with a number taken from the current time – this may ensure that each program launch will start from a different seed value (ergo, it will use different random numbers).\
Fortunately, such an initialization is done by Python during module import.

#### 4.2.10 Some functions from the random module
The most general function named random() (not to be confused with the module’s name) produces a float number x coming from the range (0.0, 1.0) –in other words: (0.0 <= x < 1.0).\ The example program will produce five pseudorandom values – as their values are determined by the current (rather unpredictable) seed value, you can’t guess them.
```py
from random import random
for i in range(5):
  print(random())
```

#### 4.2.11 Some functions from the random module
The `seed()` function is able to directly set the generator’s seed. We’ll show you two of its variants:
- seed() – sets the seed with the current time;
- seed(i) – sets the seed with the integer value i.

We’ve modified the previous program – in effect, we’ve removed any trace of randomness from the code →
```py
from random import random, seed
seed(0)
for i in range(5):
  print(random())
```
Due to the fact that the seed is always set with the same value, the sequence of generated values always looks the same.
This is what we’ve got:
```
0.844421851525
0.75795440294
0.420571580831
0.258916750293
0.511274721369
```
And you?\ Note: your values may be slightly different than ours if your system uses more precise or less precise floating-point arithmetic, but the difference will be seen quite far from the decimal point.

#### 4.2.12 Some functions from the random module
If you want integer random values, one of the following functions would fit better:
- randrange(end)
- randrange(beg,end)
- randrange(beg, end, step)
- randint(left, right)

The first three invocations will generate an integer taken (pseudorandomly) from the range (respectively):
- range(end)
- range(beg,end)
- range(beg,end,step)

Note the implicit right-sided exclusion!\
The last function is an equivalent of randrange(left, right+1) – it generates the integer value i, which falls in the range [left,right] (no exclusion on the right side).\ The example program will consequently output a line consisting of three zeros and either a zero or one at the fourth place →
```py
from random import randrange, randint

print(randrange(1),end=' ')
print(randrange(0,1),end=' ')
print(randrange(0,1,1),end=' ')
print(randint(0,0))
```

#### 4.2.13 Some functions from the random module
The previous functions have one important disadvantage – they may produce repeating values even if the number of subsequent invocations is not greater than the width of the specified range. The following program very likely outputs a set of numbers in which some elements are not unique.\ This is what we got in one of the launches:
```
9,4,5,4,5,8,9,4,8,4,
```

As you can see, this is not a good tool for generating numbers in a lottery. Fortunately, there is a better solution than writing your own code to check the uniqueness of the “drawn” numbers.
```py
from random import randint

for i in range(10):
  print(randint(1,10),end=',')
```

#### 4.2.14 Some functions from the random module
It’s a function named in a very suggestive way – choice:
- choice(sequence)
- sample(sequence, elements_to_chose=1)

The first variant chooses a “random” element from the input sequence and returns it.\ The second one builds a list (a sample) consisting of the elements_to_chose element (which defaults to 1) “drawn” from the input sequence.\ In other words, the function chooses some of the input elements, returning a list with the choice. The elements in the sample are placed in random order. Note: the elements_to_chose must not be greater than the length of the input sequence.\ Again, the output of the example program is not predictable →
```py
from random import choice,sample

lst=[1,2,3,4,5,6,7,8,9,10]
print(choice(lst))
print(sample(lst,5))
print(sample(lst,10))
```
Our results looked like this:
```
4
[3, 1, 8, 9, 10]
[10, 8, 5, 1, 6, 4, 3, 9, 7, 2]
```

#### 4.2.15 How to know where you are
Sometimes, it may be necessary to find out information unrelated to Python. For example, you may need to know the location of your program within the greater environment of the computer.\ Imagine your program’s environment as a pyramid consisting of a number of layers or platforms →
- your (running) code is located at the top of it;
- Python (more precisely – its runtime environment) lies directly below it;
- the next layer of the pyramid is filled with the OS (operating system) – Python’s environment provides some of its functionalities using the operating system’s services; Python, although very powerful, isn’t omnipotent – it’s forced to use many helpers if it’s going to process files or communicate with physical devices;
- the bottom-most layer is hardware – the processor (or processors), network interfaces, human interface devices (mice, keyboards, etc.) and all other machinery needed to make the computer run; the OS knows how to drive it, and uses lots of tricks to conduct all parts in a consistent rhythm.

This means than some of your (or rather your program’s) actions have to travel a long way to be successfully performed – imagine that:
- your code wants to create a file, so it invokes one of Python’s functions;
- Python accepts the order, rearranges it to meet local OS requirements (it’s like putting the stamp “approved” on your request) and sends it down (this may remind you of a chain of command)
- the OS checks if the request is reasonable and valid (e.g., whether the file name conforms to some syntax rules) and tries to create the file; such an operation, seemingly very simple, isn’t atomic – it consists of many minor steps taken by . . .
- . . . the hardware, which is responsible for activating storage devices (hard disk, solid state devices, etc.) to satisfy the OS’s needs.

Usually, you’re not aware of all that fuss – you want the file to be created and that’s that.\
But sometimes you want to know more – for example, the name of the OS which hosts Python, and some characteristics describing the hardware that hosts the OS.\ There is a module providing some means to allow you to know where you are and what components work for you. The module is named platform. We’ll show you some of the functions it provides to you.

#### 4.2.16 Some functions from the platform module
There is a function that can show you all the underlying layers in one glance, named platform. It just returns a string describing the environment; thus, its output is rather addressed to humans than to automated processing (you’ll see it soon).\ This is how you can invoke it:
```py
from platform import platform

print(platform())
print(platform(1))
print(platform(0,1))
```
- platform(aliased=False, terse=False)
- aliased→ when set to True (or any non-zero value) it may cause the function to present the alternative underlying layer names instead of the common ones;
- terse→ when set to True (or any non-zero value) it may convince the function to present a briefer form of the result (if possible)

We ran our sample program using three different platforms – this is what we got:

- Intel x86 + Windows ® Vista (32 bit)
Windows-Vista-6.0.6002-SP2
Windows-Vista-6.0.6002-SP2
Windows-Vista
- Intel x86 + Gentoo Linux (64 bit)
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-gentoo-2.3
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-gentoo-2.3
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-glibc2.3.4
- Raspberry PI2 + Raspbian Linux (32 bit)
Linux-4.4.0-1-rpi2-armv7l-with-debian-9.0
Linux-4.4.0-1-rpi2-armv7l-with-debian-9.0
Linux-4.4.0-1-rpi2-armv7l-with-glibc2.9

#### 4.2.17 Some functions from the platform module
Sometimes, you may just want to know the generic name of the processor which runs your OS together with Python and your code – a function named machine() will tell you that. As previously, the function returns a string.\
Again, we ran the sample program on three different platforms:
-Intel x86 + Windows ® Vista (32 bit)
```
x86
```
-Intel x86 + Gentoo Linux (64 bit)
```
x86_64
```
-Raspberry PI2 + Raspbian Linux (32 bit)
```
armv7l
```
```py
from platform import machine

print(machine())
```

#### 4.2.18 Some functions from the platform module
The processor() function returns a string filled with the real processor name (if possible)\ Again, we ran the sample program on three different platforms:
- Intel x86 + Windows ® Vista (32 bit)
```
x86
```
- Intel x86 + Gentoo Linux (64 bit)
```
Intel(R) Core(TM) i3-2330M CPU @ 2.20GHz
```
- Raspberry PI2 + Raspbian Linux (32 bit)
```
armv7l
```
```py
from platform import processor

print(processor())
```

#### 4.2.19 Some functions from the platform module
A function named system() returns the generic OS name as a string →\
Our example platforms presented themselves like this:
Intel x86 + Windows ® Vista (32 bit)
```
Windows
```
Intel x86 + Gentoo Linux (64 bit)
```
Linux
```
Raspberry PI2 + Raspbian Linux (32 bit)
```
Linux
```
```py
from platform import system
print(system())
```

#### 4.2.20 Some functions from the platform module
The OS version is provided as a string by the version() function →\
Intel x86 + Windows ® Vista (32 bit)
```
6.0.6002
```
Intel x86 + Gentoo Linux (64 bit)
```
#1 SMP PREEMPT Fri Jul 21 22:44:37 CEST 2017
```
Raspberry PI2 + Raspbian Linux (32 bit)
```
#1 SMP Debian 4.4.6-1+rpi14 (2016-05-05)
```
```py
from platform import version
print(version())
```

#### 4.2.21 Some functions from the platform module
If you need to know what version of Python is running your code, you can check it using a number of dedicated functions – here are two of them →
- python_implementation()→ returns a string denoting the Python implementation (expect 'CPython' here, unless you decide to use any non-canonical Python branch)
- python_version_tuple()→ returns a three-element tuple filled with:
  - the major part of Python’s version;
  - the minor part;
  - the patch level number.

Our example program produced the following output:
```
CPython
3
4
5
```

It’s very likely that your version of Python will be different.
```py
from platform import python_implementation,python_version_tuple

print(python_implementation())
for atr in python_version_tuple():
  print(atr)
```

#### 4.2.22 Some functions from Python modules
We have only covered the basics of Python modules here. Python’s modules make up their own universe, in which Python itself is only a galaxy, and we would venture to say that exploring the depths of these modules can take significantly more time than getting acquainted with “pure” Python.\ Moreover, the Python community all over the world creates and maintains hundreds of additional modules used in very niche applications like genetics, psychology, or even astrology. These modules aren’t (and won’t be) distributed along with Python, or through official channels, which makes the Python universe broader – almost infinite.\ Don’t worry – you won’t need all these modules. Many of them are very specific. All you need to do is find the modules you want, and teach yourself how to use them. It’s easy.\ Now let’s take a look at something else. We’re going to show you how to write your own module.

#### 4.3.1 Modules and packages
Writing your own modules doesn’t differ much from writing ordinary scripts. There are some specific aspects you must be aware of, but it definitely isn’t rocket science. You’ll see this soon enough.\ Let’s summarize some important issues:
- a module is a kind of container filled with functions – you can pack as many functions as you want into one module and distribute it across the world;
- of course, it’s generally a good idea not to mix functions with different application areas within one module (just like in a library – nobody expects scientific works to be put among comic books), so group your functions carefully and name the module containing them in a clear and intuitive way (e.g., don’t give the name arcade_games to a module containing functions intended to partition and format hard disks)
- making many modules may cause a little mess – sooner or later you’ll want to group your modules exactly in the same way as you’ve previously grouped functions – is there a more general container than a module?
- yes, there is – it’s a package; in the world of modules, a package plays a similar role to a folder/directory in the world of files.

#### 4.3.2 Your first module
Let’s start from scratch, just like this →\ You need two files to repeat these experiments. One of them will be the module itself. It’s empty now. Don’t worry, you’re going to fill it with actual code.\ We’ve named the file module.py. Not very creative, but simple and clear.
 
#### 4.3.3 Your first module
The second file contains the code using the new module. Its name is main.py\ Its content is very brief so far →
```py
# main.py
import module
```
Note: both files have to be located in the same folder. We strongly encourage you to create an empty, new folder for both files. Some things will be easier then.\ Run the main.py file. What do you see?\ You should see nothing. This means that Python has successfully imported the contents of the module.py file. It doesn’t matter that the module is empty for now. The very first step has been done, but before you take the next step, we want you to take a look into the folder in which both files exist.\ Do you notice something interesting?\ A new subfolder has appeared – can you see it? Its name is `__pycache__`. Take a look inside. What do you see?\ There is a file named (more or less):
```
module.cpython-xy.pyc
```
where x and y are digits derived from your version of Python (e.g., they will be 3 and 4 if you use Python 3.4).\ The name of the file is the same as your module’s name (module here). The part after the first dot says which Python implementation has created the file (CPython here) and its version number. The last part (pyc) comes from the words “Python” and “compiled”.\ You can look inside the file – the content is completely unreadable to humans. It has to be like that, as the file is intended for Python’s use only.\ When Python imports a module for the first time, it translates its contents into a somewhat compiled shape. The file doesn’t contain machine code – it’s internal Python semi-compiled code, ready to be executed by Python’s interpreter. As such a file doesn’t require lots of the checks needed for a pure source file, the execution starts faster, and runs faster, too.\ Thanks to that, every subsequent import will go quicker than interpreting the source text from scratch.\ Python is able to check if the module’s source file has been modified (in this case, the pyc file will be rebuilt) or not (when the pyc file may be run at once). As this process is fully automatic and transparent, you don’t have to keep it in mind.\ 
#### 4.3.4 Your first module
Now we’ve put a little something into the module file →\
```py
# module.py

print("I like to be a module")
```
Can you notice any differences between a module and an ordinary script? There are none so far.\
It’s possible to run this file like any other script.\ Try it for yourself.\ What happens? You should see the following line inside your console:\ ```
I like to be a module

#### 4.3.5 Your first module
Let’s go back to the main.py file →\
```py
# main.py

import module
```
Run it. What do you see?\
```
I like to be a module
```
What does it actually mean? When a module is imported, its content is implicitly executed by Python. It gives the module the chance to initialize some of its internal aspects (e.g., it may assign some variables with useful values). Note: the initialization takes place only once, when the first import occurs, so the assignments done by the module aren’t repeated unnecessarily. Imagine the following context:
- there is a module named mod1;
- there is a module named mod2 which contains the import mod1 instruction;
- there is a main file containing the import mod1 and import mod2 instructions.

At first glance, you may think that mod1 will be imported twice – fortunately, only the first import occurs. Python remembers the imported modules and silently omits all subsequent imports.

#### 4.3.6 Your first module
Python can do much more. It also creates a variable called `__name__`\ Moreover, each source file uses its own, separate version of the variable – it isn’t shared between modules.\ We’ll show you how to use it.
Modify the module a bit →
```py
# module.py

print("I like to be a module")
print(__name__)
```
Now run the module.py file. You should see the following lines:
```
I like to be a module
__main__
```
Now run the main.py file. And? Do you see the same as us?
```
I like to be a module
module
```
We can say that:
- when you run a file directly, its `__name__` variable is set to `__main__`;
- when a file is imported as a module, its `__name__` variable is set to the file’s name (excluding .py)

#### 4.3.7 Your first module
This is how you can make use of the `__main__` variable in order to detect the context in which your code has been activated →
```py
# module.py
if __name__ == '__main__':
  print("I prefr to be a module")
else:
  print("I like to be a module")
```
There’s a cleverer way to utilize the variable, however. If you write a module filled with a number of complex functions, you can use it to place a series of tests to check if the functions work properly.\ Each time you modify any of these functions, you can simply run the module to make sure that your amendments didn’t spoil the code. These tests will be omitted when the code is imported as a module.

#### 4.3.8 Your first module
This module will contain two simple functions, and if you want to know how many times the functions have been invoked, you need a counter initialized to zero when the module is being imported.\ You can do it this way →
```py
# module.py

counter = 0

if __name__ == "__main__":
  print("I prefer to be a module")
else:
  print("I like to be a module")
```

#### 4.3.9 Your first module
Introducing such a variable is absolutely correct, but may cause important side effects that you must be aware of.\ Take a look at the modified main.py file →
```py
# main.py
import module
print(module.counter)
```
As you can see, the main file tries to access the module’s counter variable. Is this legal? Yes, it is. It is usable? It may be very usable. Is it safe? That depends – if you trust your module’s users, there’s no problem; however, you may not want the rest of the world to see your personal/private variable.\ Unlike many others programming languages, Python has no means of allowing you to hide such variables from the eyes of the module’s users. You can only inform your users that this is your variable, that they may read it, but that they should not modify it under any circumstances.\
This is done by preceding the variable’s name with _ or __, but remember, it’s only a convention. Your module’s users may obey it or they may not.\ Of course, we’ll follow the convention. Now let’s put two functions into the module – they’ll evaluate the sum and product of the numbers collected in a list.\ In addition, let’s add some ornaments there and remove any superfluous remnants.

#### 4.3.10 Your first module
The module is ready →
```py
#!/usr/bin/env python3
""" module.py - an example of Python module """
__counter = 0
def sum(list):
  global __counter
  __counter += 1
  sum = 0
  for el in list:
    sum += el
  return sum

def prod(list):
  global __counter
  __counter += 1
  prod = 1
  for el in list:
    prod *= el
  return prod

if __name__ == "__main__":
  print("I prefer to be a module, but I can do some tests for you")
  l = [i + 1 for i in range(5)]
  print(sum(l)==15)
  print(prod(l) == 120)
```
A few elements need some explanation, we think:
- the line starting with `#!` has many names – it may be called shabang, shebang, hashbang, poundbang or even hashpling (don’t ask us why). The name itself means nothing here – its role is more important. From Python’s point of view, it’s just a comment as it starts with #. For Unix and Unix-like OSs (including MacOS) such a line instructs the OS how to execute the contents of the file (in other words, what program needs to be launched to interpret the text). In some environments (especially those connected with web servers) the absence of that line will cause trouble;
- a string (maybe a multiline) placed before any module instructions (including imports) is called the doc-string, and should briefly explain the purpose and contents of the module;
- the functions defined inside the module (`suml()` and prodl()) are available for import;
- we’ve used the `__name__` variable to detect when the file is run stand-alone, and seized this opportunity to perform some simple tests.

#### 4.3.11 Your first module
Now it’s possible to use the new module – this is one way →
```py
from module import suml,prodl

zeroes = [0 for i in range(5)]
ones = [1 for i in range(5)]
print(suml(zeroes))
print(prodl(ones))
```

#### 4.3.12 Your first module
It’s time to make this example more complicated – we’ve assumed here that the main Python file is located in the same folder/directory as the module to be imported.\ Let’s give up this assumption and conduct the following thought experiment →
- we are using Windows ® OS (this assumption is important, as the file name’s shape depends on it)
- the main Python script lies in C:\Users\user\py\progs and is named main.py
- the module to import is located in C:\Users\user\py\modules

How to deal with it? To answer this question, we have to talk about how Python searches for modules. There’s a special variable (actually a list) storing all locations (folders/directories) that are searched in order to find a module which has been requested by the import instruction.\ Python browses these folders in the order in which they are listed in the list – if the module cannot be found in any of these directories, the import fails.\ Otherwise, the first folder containing a module with the desired name will be taken into consideration (if any of the remaining folders contains a module of that name, it will be ignored).\ The variable is named path, and it’s accessible through the module named sys. This is how you can check its regular value →\
![](4312.png)\ We’ve launched the code inside the C:\User\user folder, and we’ve got:
```
C:\Users\user
C:\Users\user\AppData\Local\Programs\Python\Python36-32\python36.zip
C:\Users\user\AppData\Local\Programs\Python\Python36-32\DLLs
C:\Users\user\AppData\Local\Programs\Python\Python36-32\lib
C:\Users\user\AppData\Local\Programs\Python\Python36-32
C:\Users\user\AppData\Local\Programs\Python\Python36-32\lib\site-packages
```
Note: the folder in which the execution starts is listed in the first path’s element.\ Note once again: there is a zip file listed as one of the path’s elements – it’s not an error. Python is able to treat zip files as ordinary folders – this can save lots of storage.\ Can you figure out how we can solve the problem?\ You can solve it by adding a folder containing the module to the path variable (it’s fully modifiable).

#### 4.3.13 Your first module
One of several possible solutions looks like this →
```py
# main.py
from sys import path

path.append('..\\modules')

import module

zeroes = [0 for i in range(5)]
ones = [1 for i in range(5)]
print(module.suml(zeroes))
print(module.prodl(ones))
```
Note:
- we’ve doubled the \ inside folder name – do you know why? (*)
- we’ve used the relative name of the folder – this will work if you start the main.py file directly from its home folder, and won’t work if the current directory doesn’t fit the relative path; you can always use an absolute path, like this:
```py
path.append('C:\\Users\\user\\py\\modules')
```
- we’ve used the append() method – in effect, the new path will occupy the last element in the path list; if you don’t like the idea, you can use insert() instead.\
(*)because a backslash is used to escape other characters – if you want to get just a backslash, you have to escape it.

#### 4.3.14 Your first package
Imagine that in the not-so-distant future you and your associates write a large number of Python functions.\ Your team decides to group the functions in separate modules, and this is the final result of the ordering →
```py
# alpha.py
#!/usr/bin/env python3

"""module: alpha"""

def FunA():
  return "Alpha"

if __name__ == "__main__":
  print("I prefer to be a module")
```
```py
# beta.py
def FunB(): ...
```
```py
# iota.py
def FunI(): ...
```
```py
# sigma.py
def FunS(): ...
```
```py
# tau.py
def FunT(): ...
```
```py
# psi.py
def FunP(): ...
```
```py
# omegaj.py
def FunO(): ...
```
Note: we’ve presented the whole content for the omega module only – assume that all the modules look similar (they contain one function named FunX, where X is the first letter of the module’s name).

#### 4.3.15 Your first package
Suddenly, somebody notices that these modules form their own hierarchy, so putting them all in a flat structure won’t be a good idea.\ After some discussion, the team comes to the conclusion that the modules have to be grouped. All participants agree that the following tree structure perfectly reflects the mutual relationships between the modules →\
![](4315.png)\
Let’s review this from the bottom up:
- the ugly group contains two modules: psi and omega;
- the best group contains two modules: sigma and tau;
- the good group contains two modules (alpha and beta) and one subgroup (best)
- the extra group contains two subgroups (good and bad) and one module (iota)

Does it look bad? Not at all – analyze the structure carefully. It resembles something, doesn’t it?\
It looks like a directory structure.

#### 4.3.16 Your first package
This is how the tree currently looks →
Such a structure is almost a package (in the Python sense). It lacks the fine detail to be both functional and operative. We’ll complete it in a moment.\ If you assume that extra is the name of a newly created package (think of it as the package’s root), it will impose a naming rule which allows you to clearly name every entity from the tree.\ For example:
- the location of a function named FunT() from the tau package may be described as:
```py
extra.good.best.tau.FunT()
```
- a function marked as:
```py
extra.ugly.psi.FunP()
```
comes from the psi module being stored in the ugly subpackage of the extra package.

#### 4.3.17 Your first package
There are two questions to answer:
- how do you transform such a tree (actually, a subtree) into a real Python package (in other words, how do you convince Python that such a tree is not just a bunch of junk files, but a set of modules)?
- where do you put the subtree to make it accessible to Python?

The first question has a surprising answer. Packages, like modules, may require initialization.\
The initialization of a module is done by an unbound code (not a part of any function) located inside the module’s file. As a package is not a file, this technique is useless for initializing packages.\
You need to use a different trick instead – Python expects that there is a file with a very unique name inside the package’s folder:\
```
__init__.py
```
The content of the file is executed when any of the package’s modules is imported. If you don’t want any special initializations, you can leave the file empty, but you mustn’t omit it.

#### 4.3.18 Your first package
The presence of the __init.py__ file finally makes up the package →
```
extra
├── __init__.py
├── good
│   ├── alpha.py
│   ├── best
│   │   ├── sigma.py
│   │   └── tau.py
│   └── beta.py
├── iota.py
└── ugly
    ├── omega.py
    └── psi.py

3 directories, 8 files
```
Note: it’s not only the “root” folder that can contain the __init__.py file – you can put it inside any of its subfolders (subpackages) too. It may be useful if some of the subpackages require individual treatment and special kinds of initialization.\
Now it’s time to answer the second question – the answer is simple: anywhere. You only have to ensure that Python is aware of the package’s location. You already know how to do that.\ You’re ready to make use of your first package.

#### 4.3.19 Your first package
Let’s assume that the working environment looks as follows →\
![](4319.png)\
We’ve prepared a zip file containing all the files from the packages branch. You can download it and use it for your own experiments, but remember to unpack it in the folder presented in the scheme, otherwise, it won’t be accessible to the code from the main file.

You’ll be continuing your experiments using the main2.py file.


#### 4.3.20 Your first package
We are going to access the FunI() function from the iota module from the top of the extra package. It forces us to use qualified package names (associate this with naming folders and subfolders – the conventions are very similar).\
This is how to do it →\
```py
# main2.py
from sys import path
path.append('..\\packages')
import extra.iota
print(extra.iota.FunI())
```
Note:
- we’ve modified the path variable to make it accessible to Python;
- the import doesn’t point directly to the module, but specifies the fully qualified path from the top of the package;

replacing import extra.iota with import iota will cause an error.

#### 4.3.21 Your first package
The following variant is valid too →\
```py
# main2.py
from sys import path
path.append('..\\packages')
from extra.iota import FunI
print(FunI())
```
Note the qualified name of the `iota` module.

#### 4.3.22 Your first package
Now let’s reach all the way to the bottom of the tree – this is how to get access to the sigma and tau modules →
```py
# main2.py
from sys import path
path.append('..\\packages')
import extra.good.best.sigma
from extra.good.best.tau import FunT
print(extra.good.best.sigma.FunS())
print(FunT())
```

#### 4.3.23 Your first package
You can make your life easier by using aliasing →
```py
# main2.py
from sys import path
path.append('..\\packages')
import extra.good.best.sigma as sig
import extra.good.alpha as alp
print(sig.FunS())
print(alp.FunA())
```

#### 4.3.24 Your first package
Let’s assume that we’ve zipped the whole subdirectory, starting from the extra folder (including it), and let’s get a file named extrapack.zip. Next, we put the file inside the packages folder.\
Now we are able to use the zip file in a role of packages →
```py
# main2.py
from sys import path
path.append('..\\packages\\extrapack.zip')
import extra.good.best.sigma as sig
import extra.good.alpha as alp
from extra.iota import FunI
from extra.good.beta import FunB
print(sig.Funs())
print(alp.FunA())
print(FunI())
print(FunB())
```
If you want to conduct your own experiments with the package we’ve created, you can download it here. We encourage you to do so.\ Now you can create modules and combine them into packages. It’s time to start a completely different discussion – about errors, failures and crashes.
### 5
#### 5.1.1 Basic concepts of object programming
Let’s take a step outside of computer programming and computers in general, and discuss **object programming** issues.\
Nearly all of the programs and techniques you have used till now fall under the **procedural** style of programming. Admittedly, you have made use of some built-in objects, but when referring to them, we just mentioned the absolute minimum.\
The procedural style of programming was the dominant approach to software development for decades of IT, and it is still in use today. Moreover, it isn’t going to disappear in the future, as it works very well for specific types of projects (generally, not very complex ones and not large ones, but there are lots of exceptions to that rule).\
The object approach is quite young (much younger than the procedural approach) and is particularly useful when applied to big and complex projects carried out by large teams consisting of many developers. This kind of understanding of a project’s structure makes many important tasks easier, e.g., dividing the project into small, independent parts, and independent development of different project elements.\
Python is a universal tool for **both object and procedural programming**. It may be successfully utilized in both spheres.\
Furthermore, you can create lots of useful applications, even if you know nothing about classes and objects, but you have to keep in mind that some of the problems (e.g., graphical user interface handling) may require a strict object approach.\
Fortunately, object programming is relatively simple.\

#### 5.1.2 Basic concepts of object programming
In the procedural approach, it’s possible to distinguish two different and completely separate worlds: the world of data, and the world of code. The world of data is populated with variables of different kinds, while the world of code is inhabited by code grouped into modules and functions.\ Functions are able to use data, but not vice versa. Furthermore, functions are able to abuse data, i.e., to use the value in an unauthorized manner (e.g., when the sine function gets a bank account balance as a parameter).\ We said in the past that data cannot use functions. But is this entirely true? Are there some special kinds of data that can use functions?\ Yes, there are – the ones named methods. These are functions which are invoked from within the data, not beside them. If you can see this distinction, you’ve taken the first step into object programming.\ The object approach suggests a completely different way of thinking. The data and the code are enclosed together in the same world, divided into classes.\ Every class is like a **recipe** which can be used when you want to create a useful object (this is where the name of the approach comes from). You may produce as many objects as you need to solve your problem.\ Every object has a set of traits (they are called **properties** or **attributes** – we’ll use both words synonymously) and is able to perform a set of activities (which are called **methods**).\ The recipes may be modified if they are inadequate for specific purposes and, in effect, **new classes may be created**. These new classes inherit properties and methods from the originals, and usually add some new ones, creating new, more specific tools.\ Objects are **incarnations** of ideas expressed in classes, like a cheesecake on your plate is an incarnation of the idea expressed in a recipe printed in an old cookbook.\ The objects interact with each other, exchanging data or activating their methods. A properly constructed class (and thus, its objects) are able to protect the sensible data and hide it from unauthorized modifications. There is no clear border between data and code: they live as one in objects.\ All these concepts are not as abstract as you may at first suspect. On the contrary, they all are taken from real-life experiences, and therefore are extremely useful in computer programming: they don’t create artificial life – **they reflect real facts**, relationships, and circumstances.

#### 5.1.3 Basic concepts of object programming
The word “class” has many meanings, but not all of them are compatible with the ideas we want to discuss here. The “class” that we are concerned with is like a “category”, as a result of precisely defined similarities.\ We’ll try to point out a few classes which are good examples of this concept.\ Let’s look for a moment at vehicles. All existing vehicles (and those that don’t exist yet) are related by a single, important feature: the ability to move. You may argue that a dog moves, too; is a dog a vehicle? No, it isn’t. We have to improve the definition, i.e., enrich it with other criteria, distinguishing vehicles from other beings, and creating a stronger connection. Let’s take the following circumstances into consideration: vehicles are artificially created entities used for transportation, moved by forces of nature, and directed (driven) by humans.\ Based on this definition, a dog is not a vehicle.\ The “vehicles” class is very broad. Too broad. We have to define some more specialized classes, then. The specialized classes are the “subclasses”. The “vehicles” class will be a “superclass” for them all. Note: the hierarchy grows from top to bottom, like tree roots, not branches. The most general, and the widest, class is always at the top (the superclass) while its descendants are located below (the subclasses).\ By now, you can probably point out some potential subclasses for the “vehicle” superclass. There are many possible classifications. We’ve chosen subclasses based on the environment, and say that there are (at least) four subclasses: 
- land vehicles;
- water vehicles;
- air vehicles;
- space vehicles.

In this example, we’ll discuss the first subclass only –land vehicles. If you wish, you can continue with the remaining classes.\ Land vehicles may be further divided, depending on the method with which they impact the ground. So, we can enumerate:
- wheeled vehicles;
- tracked vehicles;
- hovercraft.

The hierarchy we’ve created is illustrated by the figure →\ ![](5103.jpg)
Note the direction of the arrows – they always point to the superclass. The top-level class is an exception – it doesn’t have its own superclass.

#### 5.1.4 Basic concepts of object programming
Another example is the hierarchy of the taxonomic kingdom of animals.\ We can say that all animals (our top-level class) can be divided into five subclasses:
- mammals;
- reptiles;
- birds;
- fish;
- amphibians.

We’ll take the first one for further analysis. We have identified the following subclasses:
- wild mammals;
- domesticated mammals.

We’ve shown the hierarchy here →\
![](5104.jpg)\
Try to extend it any way you want, and find the right place for humans.

#### 5.1.5 The object - what is it?
A class (among other definitions) is a set of objects. An object is a being belonging to a class. An object is an incarnation of the requirements, traits, and qualities assigned to a specific class. This may sound simple, but note the following important circumstances. **Classes form a hierarchy**. This may mean that an object belonging to a specific class belongs to **all the superclasses** at the same time. It may also mean that any object belonging to a superclass **may not belong to any of its subclasses**.\
For example: any personal car is an object belonging to the “wheeled vehicles” class. It also means that the same car belongs to all superclasses of its home class; therefore, it is a member of the “vehicles” class, too. Your dog (or your cat) is an object included in the “domesticated mammals” class, which explicitly means that it is included in the “animals” class as well.\
Each subclass is **more specialized** (or more specific) than its superclass. Conversely, each superclass is **more general** (more abstract) than any of its subclasses. Note that we’ve presumed that a class may only have one superclass – this is not always true, but we’ll discuss this issue more a bit later.

#### 5.1.6 The object - what is it?
Let’s define one of the fundamental concepts of object programming, named “inheritance”. Any object bound to a specific level of a class hierarchy inherits all the traits (as well as the requirements and qualities) defined inside any of the superclasses. The object’s home class may define new traits (as well as requirements and qualities) which will be **inherited by any of its superclasses**.\ You shouldn’t have any problems matching this rule to specific examples, whether it applies to animals, or to vehicles.

#### 5.1.7 What does any object have?
The object programming convention assumes that every existing object may be equipped with three groups of attributes:
- an object has a name that uniquely identifies it within its home namespace (although there may be some anonymous objects, too)
- an object has a set of individual properties which make it original, unique or outstanding (although it’s possible that some objects may have no properties at all)
- an object has a set of abilities to perform specific activities, able to change the object itself, or some of the other objects.

There is a hint (although this doesn’t always work) which can help you identify any of the three spheres above. Whenever you describe an object and you use:
- a **noun** – you probably define the object’s name;
- an **adjective** – you probably define the object’s property;
- a **verb** – you probably define the object’s activity.

Two sample phrases should serve as a good example:\
"Max is a large cat who sleeps all day."
- Object name = Max 
- Home class = Cat 
- Property = Size (large) 
- Activity = Sleep (all day)

"A pink Cadillac went quickly."
- Object name = Cadillac
- Home class = Wheeled vehicles
- Property = Color (pink) 
- Activity = Go (quickly)

#### 5.1.8 Your first class
Object programming is the art of defining and expanding classes. A class is a model of a very specific part of reality, reflecting properties and activities found in the real world.\ The classes defined at the beginning are too general and imprecise to cover the largest possible number of real cases.\ There’s no obstacle to defining new, more precise subclasses. They’ll inherit everything from their superclass, so the work that went into its creation isn’t wasted.\ The new class may add new properties and new activities, and therefore may be more useful in specific applications. Obviously, it may be used as a superclass for any number of newly created subclasses.\ The process doesn’t need to have an end. You can create as many classes as you need.\ The class you define has nothing to do with the object: the existence of a class does not mean that any of the compatible objects will automatically be created. The class itself isn’t able to create an object – you have to create it yourself, and  Python allows you to do this.\ It’s time to define the simplest class and to create an object. Take a look at the example on the right →
```py
class OurClass:
  pass
```
We’ve defined a class there. The class is rather poor: it has neither properties nor activities. It’s empty, actually, but that doesn’t matter for now. The simpler the class, the better for our purposes.\ The definition begins with the keyword class. The keyword is followed by an identifier which will name the class (note: don’t confuse it with the object’s name – these are two different things).\ Next, you add a colon, as classes, like functions, form their own nested block. The content inside the block define all the class’s properties and activities.\ The pass keyword fills the class with nothing. It doesn’t contain any methods or properties.

#### 5.1.9 Your first class
The newly defined class becomes a tool that is able to create new objects. The tool has to be used explicitly, on demand.  Imagine that you want to create one (exactly one) object of the OurClass class.\ To do this, you need to assign a variable to store the newly created object of that class, and create an object at the same time.\ You do it in the following way →
```py
ourobject = OurClass()
```
Note:
- the class name tries to pretend that it’s a function – can you see this? We’ll discuss it soon;
- the newly created object is equipped with everything the class brings; as this class is completely empty, the object is empty, too.

The act of creating an object of the selected class is also called an instantiation (as the object becomes an instance of the class).\ Let’s leave classes alone for a moment, as we’re now going to tell you about stacks.


#### 5.2.1 What is a stack?
A stack is a structure developed to store data in a very specific way. Imagine a stack of coins. You aren’t able to put a coin anywhere else but on the top of the stack. Similarly, you can’t get a coin off the stack from any place other than the top of the stack. If you want to get the coin that lies on the bottom, you have to remove all the coins from the higher levels.\
The alternative name for a stack (but only in IT terminology) is LIFO. It’s an abbreviation for a very clear description of the stack’s behavior: “Last In – First Out”. The coin that came last onto the stack will leave first.\
A stack is an object with two elementary operations, conventionally named push (when a new element is put on the top) and pop (when an existing element is taken away from the top).\
Stacks are used very often in many classical algorithms, and it’s hard to imagine the implementation of many widely used tools without the use of stacks.\
Let’s implement a stack in Python. This will be a very simple stack, and we’ll show you how to do it in two independent approaches: procedural and objective.\
Let’s start with the first one.
![5.2.1 What is a stack?](5201.png)

#### 5.2.2 The stack – the procedural approach
First, you have to decide how to store the values which will arrive onto the stack. We suggest using the simplest of methods and employing a list for this job. Let’s assume that the size of the stack is not limited in any way. Let’s also assume that the last element of the list stores the top element.\ The stack itself is already created →
```py
stack = []
```

#### 5.2.3 The stack – the procedural approach
We’re ready to define a function that puts a value onto the stack. Here are the presuppositions for it:
- the name for the function is push;
- the function gets one parameter (this is the value to be put onto the stack)
- the function returns nothing;
- the function appends the parameter’s value to the end of the stack;

This is how we’ve done it – take a look →
```py
def push(val):
  stack.append(val)
```

#### 5.2.4 The stack – the procedural approach
Now it’s time for a function to take a value off the stack. This is how you can do it:
- the name of the function is pop;
- the function doesn’t get any parameters;
- the function returns the value taken from the stack
- the function reads the value from the top of the stack and removes it.

The function is here →
```py
def pop():
  val = stack[-1]
  del stack[-1]
  return val
```
Note: the function doesn’t check if there is any element in the stack. 

#### 5.2.5 The stack – the procedural approach
Let’s assemble all the pieces together to set the stack in motion. The complete program pushes three numbers onto the stack, pulls them off, and prints their values on the screen.\ Here it is →
```py
stack = []
def push(val):
  stack.append(val)

def pop():
  val = stack[-1]
  del stack[-1]
  return val

push(3)
push(2)
push(1)
print(pop())
print(pop())
print(pop())
```
The program outputs the following text to the screen:
```
1 
2 
3
```

#### 5.2.6 The stack – the procedural approach
The procedural stack is ready. Of course, there are some weaknesses, and the implementation could be improved in many ways (harnessing exceptions to work is a good idea), but in general the stack is fully implemented, and you can use it if you need to.\ But the more often you use it, the more disadvantages you’ll encounter. Here are some of them:
- the essential variable (the stack list) is highly **vulnerable**; anyone can modify it in an uncontrollable way, destroying the stack, in effect; this doesn’t mean that it’s been done maliciously – on the contrary, it may happen as a result of carelessness, e.g., when somebody confuses variable names; imagine that you have accidentally written something like this:
```py
stack[0] = 0
```
The functioning of the stack will be completely disorganized;
- it may also happen that one day you need more than one stack; you’ll have to create another list for the stack’s storage, and probably other push and pop functions too;
- it may also happen that you need not only push and pop functions, but also some other conveniences; you could certainly implement them, but try to imagine what would happen if you had dozens of separately implemented stacks.

The objective approach delivers solutions for each of the above problems. Let’s name them first:
- the ability to **hide** (protect) selected values against unauthorized access is called **encapsulation**; the encapsulated values can be neither accessed nor modified if you want to use them exclusively;
- when you have a class implementing all the needed stack behaviors, you can **produce as many stacks as you want**; you needn’t copy or replicate any part of the code;
- the ability to enrich the stack with new functions comes from **inheritance**; you can create a new class (a subclass) which inherits all the existing traits from the superclass, and adds some new ones.

Let’s now write a brand new stack implementation from scratch. This time, we’ll use the objective approach, guiding you step by step into the world of object programming.

#### 5.2.7 A stack from scratch
Of course, the main idea remains the same. We’ll use a list as the stack’s storage. We only have to know how to put the list into the class.\ Let’s start from the absolute beginning – this is how the objective stack begins →
```py
class Stack:
```

#### 5.2.8 A stack from scratch
Now, we expect two things from it:
- we want the class to have one property as the stack’s storage – we have to ‘install’ a list inside each object of the class (note: each object has to have its own list – the list mustn’t be shared among different stacks)
- then, we want the list to be hidden from the class users’ sight.

How is this done? In contrast to other programming languages, Python has no means of allowing you to declare such a property just like that.\ Instead, you need to add a specific statement or instruction. The properties have to be added to the class manually.\ How do you guarantee that such an activity takes place every time the new stack is created?\ There is a simple way to do it – you have to equip the class with a specific function – its specificity is dual:
- it has to be named in a strict way;
- it is invoked implicitly, when the new object is created.

Such a function is called a **constructor**, as its general purpose is to construct a new object. The constructor should know everything about the object’s structure, and must perform all the needed initializations.\
Let’s add a very simple constructor to the new class. Take a look at the snippet →
- the constructor’s name is **always** `__init__`;
- it has to have at least **one parameter** (we’ll discuss this later); the parameter is used to represent the newly created object – you can use the parameter to manipulate the object, and to enrich it with the needed properties; you’ll make use of this soon;
- note: the obligatory parameter is usually named `self` – it’s only a convention, but you should follow it – it simplifies the process of reading and understanding your code.

Run the code now. Here is its output:
```
Hi
```
Note – there is no trace of invoking the constructor inside the code. It has been invoked implicitly and automatically. Let’s make use of that now.

#### 5.2.9 A stack from scratch
Any change you make inside the constructor that modifies the state of the self parameter will reflect the newly created object.\ This means you can add any property to the object and the property will remain there until the object finishes its life or the property is explicitly removed.\ Now let’s add just one property to the new object – a list for a stack. We’ll name it `stk`.\ Just like here →
```py
class Stack:
  def __init__(self):
    self.stk = []
stack = Stack()
print(len(stack.stk))
```
Note:
- we’ve used the dotted notation, just like when invoking methods; this is the general convention for accessing an object’s properties – you need to name the object, put a dot after it, and specify the desired property’s name; don’t use parentheses! You don’t want to invoke a method – you want to **access a property**;
- if you set a property’s value for the very first time (like in the constructor), you are creating it; from that moment on, the object has got the property and is ready to use its value;
- we’ve done something more in the code – we’ve tried to access the stk property from outside the class immediately after the object has been created; we want to check the current length of the stack – have we succeeded?

Yes, we have – the code produces the following output:
```
0
```
This is not we want from the stack. We prefer the `stk` to be **hidden** from the outside world. Is that possible?\
Yes, and it’s simple, but not very intuitive.

#### 5.2.10 A stack from scratch
Take a look – we’ve added two underscores before the stk name – nothing more →
```py
class Stack:
  def __init__(self):
    self.__stk=[]
stack = Stack()
print(len(stack.__stk))
```
The change invalidates the program. Why?\
When any class component has a name starting with two underscores, it becomes private – this means that it can be accessed only from within the class.\
You cannot see it from the outside world.\ This is how Python implements the encapsulation concept.

#### 5.2.11 A stack from scratch
Now it’s time for the two functions (methods) implementing the push and pop operations. Python assumes that a function of this kind (a class activity) should be immersed inside the class body – just like a constructor.\
We want to invoke these functions to push and pop values. This means that they should both be accessible to every class’s user (in contrast to the previously constructed list, which is hidden from the ordinary class’s users).\
Such a component is called public, so you can’t begin its name with two (or more) underscores. There is one more requirement – the name must have no more than one trailing underscore. As no trailing underscores at all fully meets the requirement, you can assume that the name is acceptable.\
The functions themselves are simple. Take a look →
```py
class Stack:
  def __init__(self):
    self.__stk=[]
  def push(self,val):
    self.__stk.append(val)
  def pop(self):
    val=self.__stk[-1]
    del self.__stk[-1]
    return val
stack = Stack()
stack.push(3)
stack.push(2)
stack.push(1)
print(stack.pop())
print(stack.pop())
print(stack.pop())
```
However, there’s something really strange in the code. The functions look familiar, but they have more parameters than their procedural counterparts.\
Here, both functions have a parameter named self at the first position of the parameters list.\
Is it needed? Yes, it is.\
All methods have to have this parameter. It plays the same role as the first constructor parameter.\
It allows the method to access entities (properties and activities/methods) carried out by the actual object. You cannot omit it. Every time Python invokes a method, it implicitly sends the current object as the first argument.\
This means that a method is obligated to have at least one parameter, which is used by Python itself – you don’t have any influence on it.\
If your method needs no parameters at all, this one must be specified anyway. If it’s designed to process just one parameter, you have to specify two, and the first one’s role is still the same.\
There is one more thing that requires explanation – the way in which methods are invoked from within the __stk variable.\ Fortunately, it’s much simpler than it looks.
- the first stage delivers the object as a whole – this is why you write:
```py
self
```
- next, you need to get to the `__stk` list:
```py
self.__stk
```
- with `__stk` ready to be used, you can perform the third and last step:
```py
self.__stk.append(val)
```
The class declaration is complete, and all its components have been listed. The class is ready for use.

#### 5.2.12 A stack from scratch
Having such a class opens up some new possibilities. For example, you can now have more than one stack behaving in the same way. Each stack will have its own copy of private data, but will utilize the same set of methods.\
This is exactly what we want for this example.\
Let’s try it →
```py
class Stack:
  def __init__(self):
    self.__stk=[]
  def push(self,val):
    self.__stk.append(val)
  def pop(self):
    val=self.__stk[-1]
    del self.__stk[-1]
    return val
stack1 = Stack()
stack2 = Stack()
stack1.push(3)
stack2.push(stack1.pop())
print(stack2.pop())
```
There are two stacks created from the same base class. They work independently. You can make more of them if you want to.

#### 5.2.13 A stack from scratch
Analyze the snippet →
```py
class Stack:
  def __init__(self):
    self.__stk=[]
  def push(self,val):
    self.__stk.append(val)
  def pop(self):
    val=self.__stk[-1]
    del self.__stk[-1]
    return val

little_stack = Stack()
another_stack = Stack()
funny_stack = Stack()
little_stack.push(1)
another_stack.push(little_stack.pop() + 1)
funny_stack.push(another_stack.pop()-2)
print(funny_stack.pop())
```
We’ve created three objects of the class Stack. Next, we’ve juggled them up. Try to predict the value outputted to the screen. The result is zero.

#### 5.2.14 A stack from scratch
Now let’s go a little further. Let’s add a new class for handling stacks. The new class should be able to evaluate the sum of all the elements currently stored on the stack.\
We don’t want to modify the previously defined stack. It’s already good enough in its applications, and we don’t want it changed in any way. We want a new stack with new capabilities.\
In other words, we want to construct a subclass of the already existing Stack class.\
The first step is easy: just define a new subclass pointing to the class which will be used as the superclass.\
This is what it looks like →
```py
class AddingStack(Stack):
  pass
```
The class doesn’t define any new component yet, but that doesn’t mean that it’s empty. It gets all the components defined by its superclass – the name of the superclass is written after the colon directly after the new class name.\
This is what we want from the new stack:
1. we want the push method not only to push the value onto the stack but also to add the value to the `sum` variable;
2. we want the pop function not only to pop the value off the stack but also to subtract the value from the `sum` variable.

#### 5.2.15 A stack from scratch
Firstly, let’s add a new variable to the class. It’ll be a private variable, like the stack list. We don’t want anybody to manipulate the sum value.\
As you already know, adding a new property to the class is done by the constructor. You already know how to do that, but there is something really intriguing inside the constructor.\
Take a look →
```py
class AddingStack(Stack):
  def __init__(self):
    Stack.__init__(self)
    self.__sum = 0
```
The second line of the constructor’s body creates a property named `__sum` – it will store the total of all the stack’s values.\
But the line before it looks different. What does it do? Is it really necessary? Yes, it is.
Contrary to many other language, Python forces you to explicitly invoke a superclass’ constructor. Omitting this point will have harmful effects – the object will be deprived of the `__stk` list. Such a stack will not function properly.
This is the only time you can invoke any of the available constructors explicitly – it can be done inside the superclass’s constructor.
Note the syntax:
- you specify the superclass’s name (this is the class whose constructor you want to run)
- you put a dot after it;
- you specify the name of the constructor;
- you have to point to the object (the class’s instance) which has to be initialized by the constructor – this is why you have to specify the argument and use the self variable here; note: invoking any method (including constructors) from outside the class never requires you to put the self argument at the argument’s list – invoking a method from within the class demands explicit usage of the self argument, and it has to be put first on the list.

Note: it’s generally a recommended practice to invoke the superclass’s constructor before any other initializations you want to perform inside the subclass. This is the rule we have followed in the snippet.

#### 5.2.16 A stack from scratch
Secondly, let’s add two methods. But let us ask you: is it really adding? We have these methods in the superclass already. Can we do something like that?\
Yes, we can. It means that we’re going to change the functionality of the methods, not their names. We can say more precisely that the interface (the way in which the objects are handled) of the class remains the same when changing the implementation at the same time.\ Let’s start with the implementation of the push function. This is what we expect from it:
- to add the value to the `__sum` variable;
- to push the value onto the stack.

Note: the second activity has already been implemented inside the superclass – so we can use that. Furthermore, we have to use it, as there’s no other way to access the __stk variable.\
This is how the `push` method looks in the subclass →
```py
def push(self,val):
  self.__sum += val
  Stack.push(self,val)
```
Note the way we’ve invoked the previous implementation of the push method (the one available in the superclass):\ - we have to specify the superclass’s name; this is necessary in order to clearly indicate the class containing the method, to avoid confusing it with any other function of the same name;
- we have to specify the target object and to pass it as the first argument (it’s not implicitly added to the invocation in this context)

We say that the `push` method has been overridden – the same name as in the superclass now represents a different functionality.

#### 5.2.17 A stack from scratch
This is the new pop function →
```py
def pop(self):
  val = Stack.pop(self)
  self.__sum -= val
  return val
```

#### 5.2.18 A stack from scratch
So far, we’ve defined the __sum variable, but we haven’t provided a method to get its value. It seems to be hidden. How can we reveal it and do it in a way that still protects it from modifications?\
We have to define a new method. We’ll name it getSum. Its only task will be to return the __sum value.\
Here it is →
```py
def getSum(self): 
  return self.__sum
```

#### 5.2.19 A stack from scratch
Here is the complete code of the class →
```py
class AddingStack(Stack):
  def __init__(self):
    Stack.__init__(self)
    self.__sum = 0
  def getSum(self):
    return self.__sum
  def push(self, val):
    self.__sum += val
    Stack.push(self, val)
  def pop(self):
    val = Stack.pop(self)
    self.__sum -= val
    return val
stack = AddingStack()
for i in range(5):  
  stack.push(i)
print(stack.getSum())
for i in range(5):
  print(stack.pop())
```
We can check its functioning now, and we do it with the help of a very few additional lines of code. As you can see, we add five subsequent values onto the stack, print their sum, and take them all off the stack.\
Note: to make the code shorter, we’ve omitted the Stack class code.\
This has been a very brief introduction to Python’s object programming., but later we’re going to tell you about it all in more detail.

#### 5.3.1 Properties in detail
In general, a class can be equipped with two different kinds of data to form a class’s properties. You already saw one of them when we were looking at stacks.\
This kind of class property exists when and only when it is explicitly created and added to an object. As you already know, this can be done during the object’s initialization, performed by the constructor.\
Moreover, it can be done in any moment of the object’s life. Furthermore, any existing property can be removed at any time.\ Such an approach has some important consequences:
- different objects of the same class may possess different sets of properties;
- there must be a way to safely check if a specific object owns the property you want to utilize (unless you want to provoke an exception – it’s always worth considering)
- each object carries its own set of properties – they don’t interfere with one another in any way.

Such variables (properties) are called **instance variables**. The word instance suggests that they are closely connected to the objects (which are class instances), not to the classes themselves. Let’s take a closer look at them. 

#### 5.3.2 Instance variables
Here is an example →
```py
class Class:
  def __init__(self,val=1):
    self.First = val
  def setSecond(self,val):  
    self.Second = val
object1 = Class()
object2 = Class(2)
object2.setSecond(3)
object3 = Class(4)
object3.Third = 5

print(object1.__dict__)
print(object2.__dict__)
print(object3.__dict__)
```
It needs one additional explanation before we go into any more detail. Take a look at the last three lines of the code.\ Python objects, when created, are gifted with a small set of predefined properties and methods. Each object has got them, whether you want them or not. One of them is a variable named __dict__ (it’s a dictionary).\
The variable contains the names and values of all the properties (variables) the object is currently carrying. Let’s make use of it to safely present an object’s contents.\
Let’s dive into the code now:
- the class named Class has a constructor, which unconditionally creates an instance variable named First, and sets it with the value passed through the first argument (from the class user’s perspective) or the second argument (from the constructor’s perspective); note the default value of the parameter – any trick you can do with a regular function parameter can be applied to methods, too;
- the class also has a method which creates another instance variable, named Second;
- we’ve created three objects of the class Class, but all these instances differ:
  - object1 only has the property named First;
  - object2 has two properties: First and Second;
  - object3 has been enriched with a property named Third just on the fly, outside the class’s code – this is possible and fully permissible.

The program’s output clearly shows that our assumptions are correct – here it is:
```
{'First': 1}
{'Second': 3, 'First': 2}
{'Third': 5, 'First': 4}
```
There is one additional conclusion that should be stated here: modifying an instance variable of any object has no impact to all the remaining objects. Instance variables are perfectly isolated from each other. 

#### 5.3.3 Instance variables
Take a look at the modified example →
```py
class Class:
	def __init__(self,val=1):
		self.__First = val

	def setSecond(self,val=2):
		self.__Second = val

object1 = Class()
object2 = Class(2)
object2.setSecond(3)
object3 = Class(4)
object3.__Third = 5

print(object1.__dict__)
print(object2.__dict__)
print(object3.__dict__)
```
 
It’s nearly the same as the previous one. The only difference is in the property names. We’ve added two underscores in front of them.\ As you know, such an addition makes the instance variable private – it becomes inaccessible from the outer world.\ The actual behavior of these names is a bit more complicated, so let’s run the program. This is the output:
```py
{'_Class__First': 1}
{'_Class__First': 2, '_Class__Second': 3}
{'_Class__First': 4, '__Third': 5}
```
Can you see these strange names full of underscores? Where did they come from?\ When Python sees that you want to add an instance variable to an object and you’re going to do it inside any of the object’s methods, it mangles the operation in the following way:
- it puts a class name before your name;
- it puts an additional underscore at the beginning.

This is why the `__First` becomes `_Class__First`. The name is now fully accessible from outside the class. You can run a code like this:
```py
print(object1._Class__First)
```
and you’ll get a valid result with no errors or exceptions.  As you can see, making a property private is limited.\ The mangling won’t work if you add an instance variable outside the class code. In this case, it’ll behave like any other ordinary property.

#### 5.3.4 Properties in detail
A class variable is a property which exists in just one copy and is stored outside any object.\ Note: no instance variable exists if there is no object in the class; a class variable exists in one copy even if there are no objects in the class.\
Class variables are created differently to their instance siblings.  The example will tell you more. 

#### 5.3.5 Class Variables
Here it is →
```py
class Class:
	
	def __init__(self,val=1):
		self.__First = val
		Class.Counter += 1
	Counter = 0

object1 = Class()
object2 = Class(2)
object3 = Class(4)

print(object1.__dict__, object1.Counter)
print(object2.__dict__, object2.Counter)
print(object3.__dict__, object3.Counter)
```
Look:
- there is an assignment in the first list of the class definition – it sets the variable named Counter to 0; initializing the variable inside the class but outside any of its methods makes the variable a class variable;
- accessing such a variable looks the same as accessing any instance attribute – you can see it in the constructor body; as you can see, the constructor increments the variable by one; in effect, the variable counts all the created objects.

Running the code will cause the following output
```
{'_Class__First': 1} 3
{'_Class__First': 2} 3
{'_Class__First': 4} 3
```
Two important conclusions come from the example:
- class variables aren’t shown in an object’s __dict__ (this is natural as class variables aren’t parts of an object) but you can always try to look into the variable of the same name, but at the class level – we’ll show you this very soon;
- a class variable always presents the same value in all class instances (objects)

#### 5.3.6 Class Variables
Mangling a class variable’s name has the same effects as those you’re already familiar with.\ Look at the example →
```py
class Class:
	__Counter = 0
	def __init__(self,val=1):
		self.__First = val
		Class.__Counter += 1

object1 = Class()
object2 = Class(2)
object3 = Class(4)

print(object1.__dict__, object1._Class__Counter)
print(object2.__dict__, object2._Class__Counter)
print(object3.__dict__, object3._Class__Counter)
```
Everything works as expected. 

#### 5.3.7 Class Variables
We told you before that class variables exist even when no class instance (object) had been created.\
Now we’re going to take the opportunity to show you the difference between these two __dict__ variables, the one from the class and the one from the object.\
Here’s the proof →
```py
class Class:
	Var = 1
	def __init__(self,val):
		Class.Var = val

print(Class.__dict__)
object = Class(2)
print(Class.__dict__)
print(object.__dict__)
```
Let’s take a closer look at it:
- we define one class named Class;
- the class defines one class variable named Var;
- the class constructor sets the variable with the par parameter’s value;
- naming the variable is the most important aspect of the example because:
  - changing the assignment to
```py
self.Var = val
```
would create an instance variable of the same name as the class’s one;
  - changing the assignment to
```py
Var = val
```
would operate on a method’s local variable;\
We strongly encourage you to test both of the above cases – this will make it easier for you to remember the difference;
- the first line of the off-class code prints the value of the Class.Var attribute; note – we use the value before the very first object of the class is instantiated.

The code’s output is:
```
{'__dict__': <attribute '__dict__' of 'Class' objects>, 'Var': 1, '__init__': <function Class.__init__ at 0x7f3a60bf4598>, '__doc__': None, '__module__': '__main__', '__weakref__': <attribute '__weakref__' of 'Class' objects>}
{'__dict__': <attribute '__dict__' of 'Class' objects>, 'Var': 2, '__init__': <function Class.__init__ at 0x7f3a60bf4598>, '__doc__': None, '__module__': '__main__', '__weakref__': <attribute '__weakref__' of 'Class' objects>}
{}
```
As you can see, the class’ `__dict__` contains much more data than its object’s counterpart. Most of them are useless now – the one we want you to check carefully shows the current `Var` value.\ Note that the object’s `__dict__` is empty – the object has no instance variables.

#### 5.3.8 Checking an attribute's existence
Python’s attitude to object instantiation raises one important issue – in contrast to other programming languages, you may not expect that all objects of the same class have the same sets of properties.\
Just like here →
```py
class Class:
	def __init__(self,val):
		if val % 2 != 0:
			self.a = 1
		else:
			self.b = 1

object = Class(1)
print(object.a)
print(object.b)
```
The object created by the constructor can have only one of two possible attributes: `a` or `b`.\ Executing the code will produce the following output:
```
1
Traceback (most recent call last):
  File "5.3.8.py", line 10, in <module>
    print(object.b)
AttributeError: Class instance has no attribute 'b'
```
As you can see, accessing no existing object (class) attribute causes an `AttributeError` exception.

#### 5.3.9 Checking an attribute's existence
The `try-except` instruction gives you the chance to avoid issues with non-existent properties.\
It’s easy →
```py

class Class:
	def __init__(self,val):
		if val % 2 != 0:
			self.a = 1
		else:
			self.b = 1

object = Class(1)
print(object.a)
try:
	print(object.b)
except AttributeError:	
	pass
```
As you can see, this action isn’t very sophisticated. Essentially, we’ve just swept the issue under the carpet.\ Fortunately, there is one more way to cope with the issue.

#### 5.3.10 Checking an attribute's existence
Python provides a function which is able to safely check if any object/class contains a specified property. The function is named hasattr, and expects two arguments to be passed to it:
- the class or the object being checked;
- the name of the property whose existence has to be reported (note: it has to be a string containing the attribute name, not the name alone)

The function returns `True` or `False`.  This is how you can utilize it →
```py
class Class:
	def __init__(self,val):
		if val % 2 != 0:
			self.a = 1
		else:
			self.b = 1

object = Class(1)
print(object.a)
if hasattr(object,'b'):
	print(object.b)
```

#### 5.3.11 Checking an attribute's existence
Don’t forget that the `hasattr()` function can operate on classes, too. You can use it to find out if a class variable is available, just like here →
```py
class Class:
	Attr = 1

print(hasattr(Class,'Attr'))
print(hasattr(Class,'Prop'))
```
The code’s output looks as follows:
```
True
False
```

#### 5.3.12 Checking an attribute's existence
Try to predict this code’s output →
```py
class Class:
	a = 1
	def __init__(self):
		self.b = 2

object = Class()
print(hasattr(object,'b'))
print(hasattr(object,'a'))
print(hasattr(Class,'b'))
print(hasattr(Class,'a'))
```

#### 5.3.13 Checking an attribute's existence
This is the answer →
```
True
True
False
True
```
Now it’s time to discuss methods, as methods drive the objects and make them active.

#### 5.4.1 Methods in detail
Let’s summarize all the facts regarding the use of methods in Python classes.\
Fortunately, the issue is simpler than discussing properties, as there aren’t two kinds of methods (neither instance nor class) – there are just methods.\
As you already know, a method is a function embedded inside a class.  There is one fundamental requirement – a method is obliged to have at least one parameter (there are no such thing as parameterless method – a method may be invoked without an argument, but not declared without parameters).
The first (or only) parameter is usually named self. We suggest you follow the convention – it’s commonly used, and you’ll cause a few surprises by using other names for it.
The name self suggests the parameter’s purpose – it identifies the object for which the method is invoked.\
If you’re going to invoke a method, you mustn’t pass the argument for the self parameter – Python will set it for you.\
The example shows the difference →
```py
class Classy:
	def method(self):
		print("method")

obj = Classy()
obj.method()
```
The code outputs:
```
method
```
Note the way we’ve created the object – we’ve treated the class name like a function, returning a newly instantiated object of the class.

#### 5.4.2 Methods in detail
If you want the method to accept parameters other than self, you should:
- place them after self in the method’s definition;
- deliver them during invocation without specifying self (as previously)

Just like here →
```py
class Classy:
  def method(self,par):
    print("method:",par)
obj = Classy()
obj.method(1)
```
The code outputs:
```
method 1
```

#### 5.4.3 Methods in detail
The self parameter is used to obtain access to the object’s instance and class variables. The example shows both ways of utilizing `self`→
```py
class Classy:
	Variable = 2
	def method(self):
		print(self.Variable, self.var)

obj = Classy()
obj.var = 3
obj.method()
```
The code outputs:
```
2 3
```

#### 5.4.4 Methods in detail
The self parameter is also used to invoke other object/class methods from inside the class.  Just like here →
```py
class Classy:
	def other(self):
		print("other")
	def method(self):
		print("method")
		self.other()

obj = Classy()
obj.method()
```
The code outputs:
```
method
other
```

#### 5.4.5 Methods in detail 
If you name a method `__init__`, it won’t be a regular method – it will be a constructor.\
If a class has a constructor, it is invoked automatically and implicitly when the object of the class is instantiated.\
The constructor:
- is obliged to have the self parameter (it’s set automatically, as usual);
- may (but doesn’t need to) have more parameters than just self; if this happens, the way in which the class name is used to create the object must reflect the __init__ definition;
- should be (or rather can be) used to set up the object, i.e., properly initialize its internal state, create instance variables, instantiate any other objects if their existence is needed, etc.

The example shows a very simple constructor at work →
```py
class Classy:
	def __init__(self,value):
		self.var = value

obj1 = Classy("object")
print(obj1.var)
```
The code outputs:
```
object 
```
Note that the constructor:
- cannot return a value,as it is designed to return a newly created object and nothing else;
- cannot be invoked directly either from the object or from inside the class (you can invoke a constructor from any of the object’s superclasses, but we’ll discuss this issue later).


#### 5.4.6 Methods in detail
As `__init__` is a method, and a method is a function, you can do the same tricks with constructors/methods as you do with ordinary functions.\ The example shows how to define a constructor with a default argument value →
```py
class Classy:
	def __init__(self,value = None):
		self.var = value

obj1 = Classy("object")
obj2 = Classy()
print(obj1.var)
print(obj2.var)
```
The code outputs:
```
object
None
```

#### 5.4.7 Methods in detail
Everything we’ve said about property name mangling applies to method names, too – a method whose name starts with `__` is (partially) hidden.\
The example shows this effect →
```py
class Classy:
  def visible(self):
    print("visible")
  def __hidden(self):
    print("hidden")

obj = Classy()
obj.visible()
try:
  obj.__hidden()
except
  print("failed")
obj._Classy__hidden()
```
The code outputs:
```
visible
failed
hidden
```

#### 5.4.8 Methods in detail
Each Python class and each Python object is pre-equipped with a set of useful attributes which can be used to examine its capabilities.\
You already know one of these – it’s the `__dict__` property.\ Let’s observe how it deals with methods →
```py
class Classy:
	Variable = 1
	def __init__(self):
		self.var = 2
	def method(self):
		pass
	def __hidden(self):
		pass

obj = Classy()
print(obj.__dict__)
print(Classy.__dict__)
```
The code outputs:
```
{'var': 2}
{'__module__': '__main__', '__init__': <function Classy.__init__ at 0x7f48cfc7fd90>, 'Variable': 1, '__doc__': None, '__dict__': <attribute '__dict__' of 'Classy' objects>, 'method': <function Classy.method at 0x7f48cfc7fe18>, '_Classy__hidden': <function Classy.__hidden at 0x7f48cfc7fea0>, '__weakref__': <attribute '__weakref__' of 'Classy' objects>}
```
Read the output carefully. Find all the defined methods and attributes. Locate the context in which they exist: inside the object or inside the class.

#### 5.4.9 The inner life of classes and objects
`__dict__` is a dictionary. Another built-in property worth mentioning is `__name__`, which is a string.\
The property contains the name of the class. It’s nothing exciting, just a string.\
Note: the `__name__` attribute is absent from the object – it exists only inside classes.\ If you want to find the class of a particular object, you can use a function named `type()`, which is able (among other things) to find a class which has been used to instantiate any object.\
See for yourself →
```py
class Classy:
	pass

print(Classy.__name__)
obj = Classy()
print(type(obj).__name__)
```
The code outputs:
```
Classy
Classy
```
Note: a statement like this one:
```py
print(obj.__name__)
```
will cause an error.

#### 5.4.10 The inner life of classes and objects
`__module__` is a string, too – it stores the name of the module which contains the definition of the class.\
Let’s check it →
```py
class Classy:
	pass

print(Classy.__module__)
obj = Classy()
print(obj.__module__)
```
The code outputs:
```
__main__
__main__
```
As you know, any module named `__main__` is actually not a module, but the file currently being run.

#### 5.4.11 The inner life of classes and objects
`__bases__` is a tuple. The tuple contains classes (not class names) which are direct superclasses for the class.\
The order is the same as that used inside the class definition.\
We’ll show you only a very basic example, as we want to highlight how inheritance works.\
Moreover, we’re going to show you how to use this attribute when we discuss the objective aspects of exceptions.\
Note: only classes have this attribute – objects don’t.\
We’ve defined a function named `printbases()`, designed to present the tuple’s contents clearly.\
Here is our example →
```py
class Super1:
	pass

class Super2:
	pass

class Sub(Super1, Super2):
	pass

def printbases(cls):
	print('( ',end='')
	for x in cls.__bases__:
		print(x.__name__,end=' ')
	print(')')

printbases(Super1)
printbases(Super2)
printbases(Sub)
```
The code outputs:
```
( object )
( object )
( Super1 Super2 )
```
Note: a class without explicit superclasses points to object (a predefined Python class) as its direct ancestor.

#### 5.4.12 Reflection and introspection
All these means allow the Python programmer to perform two important activities specific to many objective languages. They are:
- **introspection**, which is the ability of a program to examine the type or properties of an object at runtime;
- **reflection**, which goes a step further, and is the ability of a program to manipulate the values, properties and/or functions of an object at runtime.

In other words, you don’t have to know a complete class/object definition to manipulate the object, as the object and/or its class contain the metadata allowing you to recognize its features during program execution. 

#### 5.4.13 Investigating classes
What can you find out about classes in Python?\
The answer is simple – everything.\
 Both reflection and introspection enable a programmer to do anything with every object, no matter where it comes from.\
Analyze the following code →
```py
class Class:
	pass

obj = Class()
obj.a = 1
obj.b = 2
obj.i = 3
obj.ireal = 3.5
obj.integer = 4
obj.z = 5

def incIntsI(obj):
	for name in obj.__dict__.keys():
		if name.startswith('i'):
			val = getattr(obj,name)
			if isinstance(val,int):
				setattr(obj,name,val + 1)

print(obj.__dict__)
incIntsI(obj)
print(obj.__dict__)
```
The function named `incIntsI()` gets an object of any class, scans its contents in order to find all integer attributes with names starting with i, and increments them by one.\
Impossible? Not at all!\
This is how it works:
- line 01: define a very simple class . . .
- lines 03 through 10: . . . and fill it with some attributes;
- line 12: this is the function!
- line 13: scan the `__dict__` attribute, looking for all attribute names;
- line 14: if a name starts with `i` . . .
- line 15: . . . use the `getattr()` function to get its current value; note: `getattr()` takes two arguments: an object, and its property name (as a string), and returns the current attribute’s value;
- line 16: check if the value is of type integer, and use the function `isinstance()` for this purpose (we’ll discuss this later);
- line 17: if the check goes well, increment the property’s value by making use of the `setattr()` function; the function takes three arguments: an object, the property name (as a string), and the property’s new value.

That’s all!\
The code outputs:
```
{'a': 1, 'integer': 4, 'b': 2, 'i': 3, 'z': 5, 'ireal': 3.5}
{'a': 1, 'integer': 5, 'b': 2, 'i': 4, 'z': 5, 'ireal': 3.5}
```


#### 5.5.1 Inheritance – why and how?
Before we start talking about inheritance, we want to present a new, handy mechanism utilized by Python’s classes and objects – it’s the way in which the object is able to introduce itself.\ Let’s start with the following example →
```py
class Star:
  def __init__(self, name, galaxy):
    self.name = name
    self.galaxy = galaxy
sun = Star("Sun","Milky Way")
print(sun)
```
The program prints out just one line of text, which in our case is this:
```
<__main__.Star object at 0x7f1074cc7c50>
```
If you run the same code on your computer, you’ll see something very similar, although the hexadecimal number (the substring starting with 0x) will be different, as it’s just an internal object identifier used by Python, and it’s unlikely that it would appear the same when the same code is run in a different environment. As you can see, the printout here isn’t really useful, and something more specific, or just prettier, may be more preferable.\ Fortunately, Python offers just such a function.

#### 5.5.2 Inheritance – why and how?
When Python needs any class/object to be presented as a string (putting an object as an argument in the print() function invocation fits this condition) it tries to invoke a method named `__str__()` from the object and to use the string it returns. The default `__str__()` method returns the previous string – ugly and not very informative. You can change it just by defining your own method of the name.\ We’ve just done it here →
```py
class Star:
  def __init__(self,name,galaxy):
    self.name = name
    self.galaxy = galaxy
  def __str__(self):
    return self.name + ' in ' + self.galaxy
sun = Star("Sun","Milky Way")
print(sun)
```
This new `__str__()` method makes a string consisting of the star’s and galaxy’s names – nothing special, but the print results look better now:\ ```
Sun in Milky Way
```

#### 5.5.3 Inheritance – why and how?
The term inheritance is older than computer programming, and it describes the common practice of passing different goods from one person to another upon that person’s death. The term, when related to computer programming, has an entirely different meaning.\ Let’s define the term for our purposes:\
Inheritance is a common practice (in object programming) of passing attributes and methods from the superclass (defined and existing) to a newly created class, called the subclass.\
In other words, inheritance is a way of building a new class, not from scratch, but by using an already defined repertoire of traits. The new class inherits (and this is the key) all the already existing equipment, but is able to add some new ones if needed. Thanks to that, it’s possible to build more specialized (more concrete) classes using some sets of predefined general rules and behaviors.\ The most important factor of the process is the relation between the superclass and all of its subclasses (note: if B is a subclass of A and C is a subclass of B, this also means than C is a subclass of A, as the relationship is fully transitive).

#### 5.5.4 Inheritance – why and how?
A very simple example of two-level inheritance is presented here →\
```py
class Vehicle:
  pass
class LandVehicle(Vehicle):
  pass
class TrackedVehicle(LandVehicle):
  pass
```
All the presented classes are empty for now, as we’re going to show you how the mutual relations between the super- and subclasses work. We’ll fill them with contents soon.\ We can say that:
- The Vehicle class is the superclass for both the LandVehicle and TrackedVehicle classes;
- The LandVehicle class is a subclass of Vehicle and a superclass of TrackedVehicle at the same time;
- The TrackedVehicle class is a subclass of both the Vehicle and LandVehicle classes.

The above knowledge comes from reading the code (in other words, we know it because we can see it). Does Python know the same? Is it possible to ask it about it? Yes, it is.

#### 5.5.5 Inheritance – why and how?
Python offers a function which is able to identify a relationship between two classes, and although its diagnosis isn’t complex, it can check if a particular class is a subclass of any other class.\ This is how it looks →
```py
issubclass(class1,class2)
```
The function returns True if class1 is a subclass of class2, and False otherwise.\ Let’s see it in action – it may surprise you.

#### 5.5.6 Inheritance – why and how? 
Read the code carefully →
```py
class Vehicle:
  pass

class LandVehicle(Vehicle):
  pass

class TrackedVehicle(LandVehicle):
  pass

for cl1 in [Vehicle, LandVehicle, TrackedVehicle]:
  for cl2 in [Vehicle, LandVehicle, TrackedVehicle]:
    print(issubclass(cl1,cl2),end='\t')
  print()
```
There are two nested loops. Their purpose is to check all possible ordered pairs of classes, and to print the results of the check to determine whether the pair matches the subclass-superclass relationship.\ The program produces the following output:
```
True  False False True  True  False True  True  True
```
There is one important observation to make: each class is considered to be a subclass of itself.

#### 5.5.7 Inheritance – why and how?
As you already know, an object is an incarnation of a class. This means that the object is like a cake baked using a recipe which is included inside the class.\ This can generate some important issues. Let’s assume that you’ve got a cake (e.g., as an argument passed to your function). You want to know what recipe has been used to make it. Why? Because you want to know what to expect from it, e.g., whether it contains nuts or not, which is crucial information to some people.\ Similarly, it can be crucial if the object does have (or doesn’t have) certain characteristics. In other words, whether it is an object of a certain class or not.\ Such a fact could be detected by the function named isinstance()→
```py
isinstance(object,class)
```
The functions returns `True` if the object is an instance of the class, or `False` otherwise.\ Being an instance of a class means that the object (the cake) has been prepared using a recipe contained in either the class or one of its superclasses.\ Don’t forget: if a subclass contains at least the same equipment as any of its superclasses, it means that objects of the subclass can do the same as objects derived from the superclass, ergo, it’s an instance of its home class and any of its superclasses.\ Let’s test it.

#### 5.5.8 Inheritance – why and how? 
This is the code which tests the function →
```py
class Vehicle:
  pass

class LandVehicle(Vehicle):
  pass

class TrackedVehicle(LandVehicle):
  pass

vehicle = Vehicle()
landvehicle = LandVehicle()
trackedvehicle = TrackedVehicle()

for ob in [vehicle, landvehicle, trackedvehicle]:
  for cl in [Vehicle, LandVehicle, TrackedVehicle]:
    print(isinstance(ob,cl),end='\t')
  print()
```
We’ve created three objects, one for each of the classes. Next, using two nested loops, we check all possible object-class pairs to find out if the objects are instances of the classes.\ This is what we get:
```
True  False False True  True  False True  True  True 
```

#### 5.5.9 Inheritance – why and how?
There is also a Python operator worth mentioning, as it refers directly to objects – here it is →
```py
object1 is object2
```
The operator checks whether two variables (object1 and object2 here) refer to the same object.\ Don’t forget that variables don’t store the objects themselves, but only the handles pointing to the internal Python memory. Assigning a value of an object variable to another variable doesn’t copy the object, but only its handle. This is why an operator like is may be very useful in particular circumstances.

#### 5.5.10 Inheritance – why and how?
Take a look at the code →
```py
class ThisIsClass:
  def __init__(self,val):
    self.val = val

ob1 = ThisIsClass(0)
ob2 = ThisIsClass(2)
ob3 = ob1
ob3.val += 1
print(ob1 is ob2)
print(ob2 is ob3)
print(ob3 is ob1)
print(ob1.val, ob2.val, ob3.val)

str1 = "Mary had a little "
str2 = "Mary had a little lamb"
str1 += "lamb"
print(str1 == str2, str1 is str2)
```
There is a very simple class equipped with a simple constructor, creating just one property. The class is used to instantiate two objects. The former is then assigned to another variable, and its val property is incremented by one.\ Afterward, the is operator is applied three times to check all possible pairs of objects, and all val property values are also printed.\ The last part of the code carries out another experiment. After three assignments, both strings contain the same texts, but these texts are stored in different objects.\ The code prints:
```
False
False
True
1 2 1
True False
```
The results prove that ob1 and ob3 are actually the same objects, while str1 and str2 aren’t, despite their contents being the same.

#### 5.5.11 How Python finds properties and methods?
Now we’re going to look at how Python deals with inheriting methods.\ Take a look at the example → 
```py
class Super:
  def __init__(self,name):
    self.name = name
  def __str__(self):
    return "My name is " + self.name + "."

class Sub(Super):
  def __init__(self,name):
    Super.__init__(self,name)

object = Sub("Andy")
print(object)
```
There is a class named Super, which defines its own constructor used to assign the object’s property, named name. The class defines the `__str__()` method, too, which makes the class able to present its identity in clear text form.\
The class is next used as a base to create a subclass named Sub. The Sub class defines its own constructor, which invokes the one from the superclass. Note how we’ve done it: 
```py
Super.__init__(self,name)
```
We’ve explicitly named the superclass, and pointed to the method to invoke `__init__()`, providing all needed arguments.\ We’ve instantiated one object of class `Sub` and printed it.\ The code outputs:
```
My name is Andy.
```
Note: As there is no `__str__()` method within the Sub class, the printed string is to be produced within the Super class. This means that the `__str__()` method has been inherited by the `Sub` class.

#### 5.5.12 How Python finds properties and methods? 
We’ve modified the code to show you another method of accessing any entity defined inside the superclass. In the last example, we explicitly named the superclass. In this example, we make use of the `super()` function, which accesses the superclass without needing to know its name → 
```py
class Super:
  def __init__(self,name):
    self.name = name
  def __str__(self):
    return "My name is " + self.name + "."

class Sub(Super):
  def __init__(self,name):
    super().__init__(name)

object = Sub("Andy")
print(object)
```
The `super()` function creates a context in which you don’t have (moreover, you mustn’t) pass the self argument to the method being invoked – this is why it’s possible to activate the superclass constructor using only one argument.\ Note: you can use this mechanism not only to invoke the superclass constructor, but also to get access to any of the resources available inside the superclass.

#### 5.5.13 How Python finds properties and methods?
Let’s try to do something similar, but with properties (more precisely: with class variables).\ Take a look at the example →
```py
class Super:
  SupVar = 1
class Sub(Super):
  SubVar = 2

object = Sub()
print(object.SubVar)
print(object.SupVar)
```
As you can see, the Super class defines one class variable named SupVar, and the Sub class defines a variable named SubVar. Both these variables are visible inside the object of class Sub – this is why the code outputs:
```
2
1
```

#### 5.5.14 How Python finds properties and methods?
The same effect can be observed with instance variables – take a look →
```py
class Super:
  def __init__(self):
    self.supvar = 11

class Sub(Super):
  def __init__(self):
    super().__init__()
    self.subvar = 12

object = Sub()
print(object.subvar)
print(object.supvar)
```
The Sub class constructor creates an instance variable named subvar, while the Super constructor does the same with a variable named supvar. As previously, both variables are accessible from within the object of class Sub. The program’s output is:
```
12
11
```
Note: the existence of the supvar variable is obviously conditioned by the Super class constructor invocation. Omitting it would result in the absence of the variable in the created object (try it yourself).

#### 5.5.15 How Python finds properties and methods?
It’s now possible to formulate a general statement describing Python’s behavior:\
When you try to access any object’s entity, Python will try (in this order)
- to find it inside the object itself;
- to find it in all classes involved in the object’s inheritance line from bottom to top;
- if both of the above fail, an exception (AttributeError) is raised.

The first condition may need some additional attention. As you know, all objects deriving from a particular class may have different sets of attributes, and some of the attributes may be added to the object a long time after the object’s creation.\ The example summarizes this in a three-level inheritance line →
```py
class Level0:
  Var0 = 100
  def __init__(self):
    self.var0 = 101
  def fun0(self):
    return 102

class Level1(Level0):
  Var1 = 200
  def __init__(self):
    super().__init__()
    self.var1 = 201
  def fun1(self):
    return 202

class Level2(Level1):
  Var2 = 300
  def __init__(self):
    super().__init__()
    self.var2 = 301
  def fun2(self):
    return 302

object = Level2()
print(object.Var0, object.var0, object.fun0())
print(object.Var1, object.var1, object.fun1())
print(object.Var2, object.var2, object.fun2())
```
All the previous comments referred to single inheritance, when a subclass has exactly one superclass. This is the most common situation (and the recommended one, too) but Python offers more here. Let’s have a look at this.

#### 5.5.16 How Python finds properties and methods?
Multiple inheritance occurs when a class has more than one superclass.\ Syntactically, such inheritance is presented as a comma-separated list of superclasses put inside parentheses after the new class name – just like here →
```py
class SuperA:
  VarA = 10
  def funa(self):
    return 11

class SuperB:
  VarB = 20
  def funb(self):
    return 21

class Sub(SuperA,SuperB):
  pass

object = Sub()

print(object.VarA, object.funa())
print(object.VarB, object.funb())
```
The Subclass has two superclasses, SuperA and SuperB. This means that the Sub class inherits all the goods offered by both SuperA and SuperB.\
The code prints:
```
10 11 
20 21
```
Now it’s time to introduce a brand new term – overriding.\ What do you think will happen if more than one of the superclasses defines an entity of a particular name?

#### 5.5.17 How Python finds properties and methods?
This is what the example shows →
```py
class Level0:
  Var = 100
  def fun(self):
    return 101

class Level1(Level0):
  Var = 200
  def fun(self):
    return 201

class Level2(Level1):
  pass

object = Level2()
print(object.Var, object.fun())
```
Both, Level0 and Level1 classes define a method named fun() and a property named Var. Does this mean that the Level2 class object will be able to access two copies of each entity? Not at all.\ The entity defined later (in the inheritance sense) overrides the same entity defined earlier. This is why the code produces the following output:
```
200 201
```
As you can see, the Var class variable and fun() method from Level1 class override the entities of the same names derived from the Level0 class.\ This feature can be intentionally used to modify default (or previously defined) class behaviors when any of its classes needs to act in a different way to its ancestor.\ We can also say that Python looks for an entity from bottom to top, and is fully satisfied with the first entity of the desired name.\ How does it work when a class has two ancestors offering the same entity, and they lie on the same level? In other words, what should you expect when a class emerges using multiple inheritance?\ Let’s look at this.

#### 5.5.18 How Python finds properties and methods?
The Sub class inherits goods from two superclasses, Left and Right (these names are intended to be meaningful) →
```py
class Left:
  Var = 'L'
  VarL = 'LL'
  def fun(self):
    return 'left'

class Right:
  Var = 'R'
  VarR = 'RR'
  def fun(self):
    return 'right'

class Sub(Left,Right):
  pass

object = Sub()

print(object.Var, object.VarL, object.VarR, object.fun())
```
There is no doubt that the class variable VarR comes from the Right class, and VarL comes from Left respectively. This is clear. But where does Var come from? Is it possible to guess it? The same problem is encountered with the fun() method – will it be invoked from Left or from Right? Let’s run the program – its output is: L LL RR left\
This proves that both unclear cases have a solution inside the Left class. Is this a sufficient premise to formulate a general rule? Yes, it is.\
We can say that Python looks for object components in the following order:
- inside the object itself;
- in its superclasses, from bottom to top;
- if there is more than one class on a particular inheritance path, Python scans them from left to right.
Do you need anything more? Just make a small amendment in the code – replace:
```py
class Sub(Left,Right):
```
with:
```py
class Sub(Right,Left):
```
What do you see now? We see:
```
R LL RR right
```
Do you see the same, or something different?

#### 5.5.19 How to build a hierarchy of classes
Building a hierarchy of classes isn’t just art for art’s sake. If you divide a problem among classes and decide which of them should be located at the top and which should be placed at the bottom of the hierarchy, you have to carefully analyze the issue, but before we show you how to do it (and how not to do it), we want to highlight an interesting effect. It’s nothing extraordinary (it’s just a consequence of the general rules presented earlier), but remembering it may be key to understanding how some codes work, and how the effect may be used to build a flexible set of classes.\
Take a look →
```py
class One:
  def doit(self):
    print("doit from One")
  def doanything(self):
    self.doit()

class Two(One):
  def doit(self):
    print("doit from Two")

one = One()
two = Two()

one.doanything()
two.doanything()
```
There are two classes, named One and Two, while Two is derived from One. Nothing special. However, one thing looks remarkable – the doit() method.\
It’s defined twice: originally inside One and subsequently inside Two. The essence of the example lies in the fact that it is invoked just once – inside One.\
The question is – which of the two methods will be invoked by the last two lines of the code?\
The first invocation seems to be simple, and it is simple, actually – invoking doanything() from the  object named one will obviously activate the first of the methods.\
The second invocation needs some attention. It’s simple, too if you keep in mind how Python finds class components.\
The second invocation will launch doit() in the form existing inside the Two class, regardless of the fact that the invocation takes place within the One class.\
In effect, the code produces the following output:
```
doit from One
doit from Two
```
Note: the situation in which the subclass is able to modify its superclass behavior (just like in the example) is called polymorphism. The word comes from Greek (polys: “many, much” and morphē, “form, shape”), which means that one and the same class can take various forms depending on the redefinitions done by any of its subclasses. The method, redefined in any of the superclasses, thus changing the behavior of the superclass, is called virtual.\ In other words, no class is given once and for all. Each class’s behavior may be modified at any time by any of its subclasses.\ We’re going to show you how to use polymorphism to extend class flexibility.

#### 5.5.20 How to build a hierarchy of classes?
Take a look at the example → 
```py
import time 
class TrackedVehicle:
  def controltrack(left,stop):
    pass

  def turn(left):
    controltrack(left,True)
    time.sleep(0.25)
    controltrack(left,False)

class WheeledVehicle:
  def turnfrontwheels(left,on):
    pass

  def turn(left):
    turnfrontwheels(left,True)
    time.sleep(0.25)
    turnfrontwheel(left,False)
```
Does it resemble anything? Yes, of course it does. It refers to the example shown in the beginning of the chapter when we talked about the general concepts of objective programming.\
It may look weird, but we didn’t use inheritance in any way – just to show you that it doesn’t limit us, and we managed to get ours.\
We defined two separate classes able to produce two different kinds of land vehicles. The main difference between them is in how they turn. A wheeled vehicle just turns the front wheels (generally). A tracked vehicle has to stop one of the tracks.\
Can you follow the code?
- a tracked vehicle perform a turn by stopping and moving on one of its tracks (this is done by the controltrack() method, which will be implemented later)
- a wheeled vehicle turns when its front wheels turn (this is done by the turnfrontwheels() method)
- the `turn()` method uses the method suitable for each particular vehicle.

Can you see what’s wrong with the code? The `turn()` methods look too similar to leave them in this form. Let’s rebuild the code – we’re going to introduce a superclass to gather all the similar aspects of the driving vehicles, moving all the specifics to the subclasses.

#### 5.5.21 How to build a hierarchy of classes?
This is what we’ve done → 
```py
import time 

class Vehicle:
  def changedirection(left,on):
    pass
  def turn(left):
    changedirection(left,True)
    time.sleep(0.25)
    changedirection(left,False)

class TrackedVehicle(Vehicle):
  def controltrack(left,stop):
    pass
  def changedirection(left,on):
    controltrack(left,on)

class WheeledVehicle(Vehicle):
  def turnfrontwheels(left,on):
    pass
  def changedirection(left,on):
    turnfrontwheels(left,on)
```
- we defined a superclass named Vehicle, which uses the turn() method to implement a general scheme of turning, while the turning itself is done by a method named changedirection(); note: the former method is empty, as we are going to put all the details into the subclass (such a method is often called an abstract method, as it only demonstrates some possibility which will be instantiated later)
- we defined a subclass named TrackedVehicle (note: it’s derived from the Vehicle class) which instantiated the changedirection() method by using the specific (concrete) method named controltrack()
- respectively, the subclass named WheeledVehicle does the same trick, but uses the turnfrontwheel() method to force the vehicle to turn.

The most important advantage (omitting readability issues) is that this form of code enables you to implement a brand new turning algorithm just by modifying the turn() method, which can be done in just one place, as all the vehicles will obey it. This is how polymorphism helps the developer to keep the code clean and consistent.

#### 5.5.22 Inheritance vs. composition
Inheritance is not the only way of constructing adaptable classes. You can achieve the same goals (not always, but very often) by using a technique named composition.\
Composition is the process of composing an object using other different objects. The objects used in the composition deliver a set of desired traits (properties and/or methods) so we can say that they act like blocks used to build a more complicated structure.\
It can be said that:
- inheritance extends a class’s capabilities by adding new components and modifying existing ones; in other words, the complete recipe is contained inside the class itself and all its ancestors; the object takes all the class’s belongings and makes use of them;
- composition projects a class as a container able to store and use other objects (derived from other classes) where each of the objects implements a part of a desired class’s behavior.

Let us illustrate the difference by using the previously defined vehicles. The previous approach led us to a hierarchy of classes in which the top-most class was aware of the general rules used in turning the vehicle, but didn’t know how to control the appropriate components (wheels or tracks). The subclasses implemented this ability by introducing specialized mechanisms. Let’s do (almost) the same thing, but using composition. The class – like in the previous example – is aware of how to turn the vehicle, but the actual turn is done by a specialized object stored in a property named controller. The controller is able to control the vehicle by manipulating the relevant vehicle’s parts.\
This is how it could look →
```py
import time 

class Tracks:
  def changedirection(self,left,on):
    print("tracks: ", left, on)

class Wheels:
  def changedirection(self,left,on):
    print("wheels: ", left, on)

class Vehicle:
  def __init__(self, controller):
    self.controller = controller
  def turn(self,left):
    self.controller.changedirection(left, True)
    time.sleep(0.25)
    self.controller.changedirection(left, False)

wheeled = Vehicle(Wheels())
tracked = Vehicle(Tracks())

wheeled.turn(True)
tracked.turn(False)
```
There are two classes named Tracks and Wheels – they know how to control the vehicle’s direction. There is also a class named Vehicle which can use any of the available controllers (the two already defined, or any other defined in the future) – the controller itself is passed to the class during initialization. In this way, the vehicle’s ability to turn is composed using an external object, not implemented inside the Vehicle’s class.\
In other words, we have a universal vehicle and can install either tracks or wheels onto it.\
The code produces the following output:
```
wheels:  True True
wheels:  True False
tracks:  False True
tracks:  False False
```

#### 5.5.23 Single inheritance vs. multiple inheritance
As you already know, there are no obstacles to using multiple inheritance in Python. You can derive any new class from more than one previously defined classes.\ There is only one but. The fact that you can do it does not mean you have to.\ Don’t forget that:
- a single inheritance class is always simpler, safer, and easier to understand and maintain;
- multiple inheritance is always risky, as you have many more opportunities to make a mistake in identifying these parts of the superclasses which will effectively influence the new class;
- multiple inheritance may make overriding extremely tricky; moreover, using the super() function becomes  ambiguous;
- multiple inheritance violates the single responsibility principle (more details here: https://en.wikipedia.org/wiki/Single_responsibility_principle) as it makes a new class of two (or more) classes that know nothing about each other;
- we strongly suggest multiple inheritance as the last of all possible solutions – if you really need the many different functionalities offered by different classes, composition may be a better alternative.

#### 5.5.24 Diamonds and why you don’t want them?
The spectrum of issues possibly coming from multiple inheritance is illustrated by a classical problem named the diamond problem. The name reflects the shape of the inheritance diagram – take a look →
- there is the top-most superclass named A;
- there are two subclasses derived from A – B and C;
- and there is also the bottom-most subclass named D, derived from B and C (or C and B, as these two variants mean different things in Python)

Can you see the diamond there? Python, however, doesn’t like diamonds, and won’t let you implement anything like this. If you try to build a hierarchy like this one:
```py
class A:
  pass
class B(A):
  pass
class C(A):
  pass
class D(A,B):
  pass
d = D()
```
you will get a TypeError exception, along with the following message:
```
Cannot create a consistent method resolution order (MRO) for bases B, A
```
where MRO stands for Method Resolution Order – this is the algorithm Python uses to look up the inheritance tree in order to find the needed methods.\
Diamonds are precious and valuable . . . but not in programming. Avoid them for your own good.

#### 5.6.1 Exceptions once again
Discussing object programming offers a very good opportunity to return to exceptions. The objective nature of Python’s exceptions makes them a very flexible tool, able to fit to specific needs, even those you don’t yet know about.\
Before we dive into the objective face of exceptions, we want to show you some syntactical and semantic aspects of the way in which Python treats the try-except block, as it offers a little more than what we have presented so far.\
The first feature we want discuss here is an additional, possible branch that can be placed inside (or rather, directly behind) the try-except block – it’s the part of the code starting with else – just like here → 
```py
def reciprocal(n):
  try:
    n = 1 / n
  except ZeroDivisionError:
    print("Division failed")
    return None
  else:
    print("Everything went fine")
    return n

print(reciprocal(2))
print(reciprocal(0))
```
A code labelled in this way is executed when (and only when) no exception has been raised inside the try part. We can say that exactly one branch can be executed after try: either the one beginning with except (don’t forget that there can be more than one branch of this kind) or the one starting with else.\
Note: the else branch has to be located after the last `except` branch.\
The example code produces the following output:
```
Everything went fine
0.5
Division failed
None
```

#### 5.6.2 Exceptions once again
The `try-except` block can be extended in one more way – by adding a part headed by the `finally` keyword (it must be the last branch of the code designed to handle exceptions).\
Note: these two variants (`else` and `finally)` aren’t dependent in any way, and they can coexist or occur independently.\
The `finally` block is always executed (it finalizes the `try-except` block execution, hence its name), no matter what happened earlier, even when raising an exception, no matter whether this has been handled or not.
Look at the code →
```py
def reciprocal(n):
  try:
    n = 1 / n
  except ZeroDivisionError:
    print("Division failed")
    n = None
  else:
    print("Everything went fine")
  finally:
    print("It's time to say good bye")
    return n

print(reciprocal(2))
print(reciprocal(0))
```
It outputs:
```
Everything went fine
It's time to say good bye 
0.5
Division failed 
It's time to say good bye
None
```

#### 5.6.3 Exceptions are classes, too
All the previous examples were content with detecting a specific kind of exception and responding to it in an appropriate way. Now we’re going to delve deeper, and look inside the exception itself.\
You probably won’t be surprised to learn that exceptions are classes. Furthermore, when an exception is raised, an object of the class is instantiated, and goes through all levels of program execution, looking for the `except` branch that is prepared to deal with it.\
Such an object carries some useful information which can help you to precisely identify all aspects of the pending situation. To achieve that goal, Python offers a special variant of the exception clause – you can find it here →
```py
try:
  i = int("hello!")
except Exception as e:
  print(e)
  print(e.__str__())
``` 
As you can see, the `except` statement is extended, and contains an additional phrase starting with the `as` keyword, followed by an identifier. The identifier is designed to catch the exception object so you can analyze its nature and draw proper conclusions. Note: the identifier’s scope covers its `except` branch, and doesn’t go any further.\
The example presents a very simple way of utilizing the received object –just print it out (as you can see, the output is produced by the object’s `__str__()` method) and it contains a brief message describing the reason.\
The same message will be printed if there is no fitting `except` block in the code, and Python is forced to handle it alone.

#### 5.6.4 Exceptions are classes, too
All the built-in Python exceptions form a hierarchy of classes. There is no obstacle to extending it if you find it reasonable.\ This program dumps all predefined exception classes in the form of a tree-like printout.\ Take a look at it → 
```py
def PrintExcTree(thisclass, nest = 0):
  if nest > 1:
    print("   |" * (nest - 1), end = '')
  if nest > 0:
    print("   +---", end = '')
  print(thisclass.__name__)
  for subclass in thisclass.__subclasses__():
    PrintExcTree(subclass, nest + 1)

PrintExcTree(BaseException)
```
As a tree is a perfect example of a recursive data structure, a recursion seems to be the best tool to traverse through it. The `PrintExcTree()` function takes two arguments:
- a point inside the tree from which we start traversing the tree;
- a nesting level (we’ll use it to build a simplified drawing of the tree’s branches)

Let’s start from the tree’s root – the root of Python’s exception classes is the BaseException class (it’s a superclass of all other exceptions).\ For each of the encountered classes, perform the same set of operations:
- print its name, taken from the `__name__` property;
- iterate through the list of subclasses delivered by the `__subclasses__()` method, and recursively invoke the `PrintExcTree(),` incrementing the nesting level respectively.

Note how we’ve drawn the branches and forks. The printout isn’t sorted in any way – you can try to sort it yourself, if you want a challenge. Moreover, there are some subtle inaccuracies in the way in which some branches are presented. That can be fixed, too, if you wish.\
This is how it looks:
``` 
BaseException 
+---Exception 
|   +---TypeError 
|   +---StopIteration 
|   +---MemoryError 
|   +---NameError 
|   |   +---UnboundLocalError 
|   +---ValueError 
|   |   +---UnicodeError 
|   |   |   +---UnicodeEncodeError 
|   |   |   +---UnicodeDecodeError 
|   |   |   +---UnicodeTranslateError 
|   |   +---UnsupportedOperation 
|   +---Warning 
|   |   +---UserWarning 
|   |   +---DeprecationWarning 
|   |   +---UnicodeWarning 
|   |   +---BytesWarning 
|   |   +---SyntaxWarning 
|   |   +---ResourceWarning 
|   |   +---RuntimeWarning 
|   |   +---FutureWarning 
|   |   +---ImportWarning 
|   |   +---PendingDeprecationWarning 
|   +---AttributeError 
|   +---EOFError 
|   +---LookupError 
|   |   +---IndexError 
|   |   +---KeyError 
|   |   +---CodecRegistryError 
|   +---ReferenceError 
|   +---ArithmeticError 
|   |   +---FloatingPointError 
|   |   +---OverflowError 
|   |   +---ZeroDivisionError 
|   +---Error 
|   +---ImportError 
|   |   +---ZipImportError 
|   +---BufferError 
|   +---SyntaxError 
|   |   +---IndentationError 
|   |   |   +---TabError 
|   +---OSError 
|   |   +---ConnectionError 
|   |   |   +---BrokenPipeError 
|   |   |   +---ConnectionAbortedError 
|   |   |   +---ConnectionRefusedError 
|   |   |   +---ConnectionResetError 
|   |   +---BlockingIOError 
|   |   +---ProcessLookupError 
|   |   +---FileNotFoundError 
|   |   +---ItimerError 
|   |   +---NotADirectoryError 
|   |   +---UnsupportedOperation 
|   |   +---PermissionError 
|   |   +---FileExistsError 
|   |   +---ChildProcessError 
|   |   +---TimeoutError 
|   |   +---IsADirectoryError 
|   |   +---InterruptedError 
|   +---SystemError 
|   |   +---CodecRegistryError 
|   +---AssertionError 
|   +---RuntimeError 
|   |   +---NotImplementedError 
|   |   +---_DeadlockError 
+---GeneratorExit 
+---SystemExit 
+---KeyboardInterrupt
```

#### 5.6.5 Detailed anatomy of exception
Let’s take a closer look at the exception’s object, as there are some really interesting elements here (we’ll return to the issue soon when we consider Python’s input/output base techniques, as their exception subsystem extends these objects a bit).\ The `BaseException` class introduces a property named args. It’s a tuple designed to gather all arguments passed to the class constructor. It is empty if the construct has been invoked without any arguments, or contains just one element when the constructor gets one argument (we don’t count the self argument here), and so on.\ We’ve prepared a simple function to print the args property in an elegant way. You can see the function here →
```py
def printargs(args):
  lng = len(args)
  if lng == 0:
    print("")
  elif lng == 1:
    print(args[0])
  else:
    print(str(args))

try:
  raise Exception
except Exception as e:
  print(e,e.__str__(),sep=' : ',end=' : ')
  printargs(e.args)

try:
  raise Exception("my exception")
except Exception as e:
  print(e,e.__str__(),sep=' : ',end=' : ')
  printargs(e.args)

try:
  raise Exception("my", "exception")
except Exception as e:
  print(e,e.__str__(),sep=' : ',end=' : ')
  printargs(e.args)
```
We’ve used the function to print the contents of the args property in three different cases, where the exception of the `Exception` class is raised in three different ways. To make it more spectacular, we’ve also printed the object itself, along with the result of the `__str__()` invocation.\ The first case looks routine – there is just the name `Exception` after the `raise` keyword. This means that the object of this class has been created in a most routine way.\ The second and third cases may look a bit weird at first glance, but there’s nothing odd here – these are just the constructor invocations. In the second raise statement, the constructor is invoked with one argument, and in the third, with two.\ As you can see, the program output reflects this, showing the appropriate contents of the args property.
```
:  : 
my exception : my exception : my exception 
('my', 'exception') : ('my', 'exception') : ('my', 'exception')
```

#### 5.6.6 How to create your own exception?
The exceptions hierarchy is neither closed nor finished, and you can always extend it if you want or need to create your own world populated with your own exceptions. It may be useful when you create a complex module which detects errors and raises exceptions, and you want the exceptions to be easily distinguishable from any others brought by Python.\ This is done by defining your own, new exceptions as subclasses derived from predefined ones.\ Note: if you want to create an exception which will be utilized as a specialized case of any built-in exception, derive it from just this one. If you want to build your own hierarchy, and don’t want it to be closely connected to Python’s exception tree, derive it from any of the top exception classes, like Exception.\ Imagine that you’ve created a brand new arithmetic, ruled by your own laws and theorems. It’s clear that division has been redefined, too, and has to behave in a different way than routine dividing. It’s also clear that this new division should raise its own exception, different from the built-in `ZeroDivisionError,` but it’s reasonable to assume that in some circumstances, you (or your arithmetic’s user) may want to treat all zero divisions in the same way.\ Demands like these may be fulfilled in the way presented here →
```py
class MyZeroDivisionError(ZeroDivisionError):
  pass

def doTheDivision(mine):
  if mine:
    raise MyZeroDivisionError("worse news")
  else:    
    raise ZeroDivisionError("bad news")

for mode in [False, True]:
  try:
    doTheDivision(mode)
  except ZeroDivisionError:
    print('Division by zero')


for mode in [False, True]:
  try:
    doTheDivision(mode)
  except MyZeroDivisionError:
    print('My division by zero')
  except ZeroDivisionError:
    print('Original division by zero')    
```
We’ve defined our own exception, named `MyZeroDivisionError,` derived from the built-in `ZeroDivisionError.` As you can see, we’ve decided not to add any new components to the class.\ In effect, an exception of this class can be – depending of the desired point of view – treated like a plain `ZeroDivisionError,` or considered separately.\ The `doTheDivision()` function raises either a  `MyZeroDivisionError` or `ZeroDivisionError` exception, depending on the argument’s value. The function is invoked four times in total, while the first two invocations are handled using only one `except` branch (the more general one) and the last two ones with two different branches, able to distinguish the exceptions (don’t forget: the order of the branches makes a fundamental difference!)

#### 5.6.7 How to create your own exception?
When you’re going to build a completely new universe filled with completely new creatures that have nothing in common with all the familiar things, you may want to build your own exception structure. For example, if you work on a large simulation system which is intended to model the activities of a pizza restaurant, it can be desirable to form a separate hierarchy of exceptions.
```py
class PizzaError(Exception):
  def __init__(self, pizza, message):
    Exception.__init__(message)
    self.pizza = pizza
```
You can start to build it by defining a general exception as a new base class for any other specialized exception. We’ve done in in the following way →\ Note: we’re going to collect more specific information here than a regular Exception does, so our constructor will take two arguments: one specifying a pizza as a subject of the process, and one containing a more or less precise description of the problem. As you can see, we pass the second parameter to the superclass constructor, and save the first inside our own property. 

#### 5.6.8 How to create your own exception? 
A more specific problem (like an excess of cheese) can require a more specific exception. It’s possible to derive the new class from the already defined `PizzaError` class, like we’ve done here →
```py
class TooMucCheeseError(PizzaError):
  def __init__(self, pizza, cheese, message):
    PizzaError.__init__(self, pizza, message)
    self.cheese = cheese
```
The TooMuchCheese exception needs more information than a regular `PizzaError` exception, so we add it to the constructor –the name `cheese` is then stored for further processing.

#### 5.6.9 How to use your own exception?
We’ve coupled together the two previously defined exceptions and harnessed them to work in a small example snippet →
```py
class PizzaError(Exception):
    def __init__(self, pizza, message):
        Exception.__init__(self,message)
        self.pizza = pizza

class TooMuchCheeseError(PizzaError):
    def __init__(self, pizza, cheese, message):
        PizzaError.__init__(self,pizza,message)
        self.cheese = cheese

def makePizza(pizza,cheese):
  if pizza not in ['margherita', 'capricciosa', 'calzone']:
    raise PizzaError(pizza,"no such pizza in menu")
  if cheese > 100:
    raise TooMuchCheeseError(pizza, cheese, "too much cheese")
  print("Pizza ready!")

for (pz,ch) in [('calzone',0),('margherita',110),('mafia',20)]:
  try:
    makePizza(pz,ch)
  except TooMuchCheeseError as tmce:
    print(tmce, ':', tmce.cheese)
  except PizzaError as pe:
    print(pe, ':', pe.pizza)
```

One of these is raised inside the `makePizza()` function when any of these two erroneous situations is discovered: a wrong pizza request, or a request for too much cheese.

Note:
- removing the branch starting with except `TooMuchCheeseError` will cause all appearing exceptions to be classified as `PizzaError;`
- removing the branch starting with except `PizzaError` will cause the `TooMuchCheeseError` exceptions to remain unhandled, and will cause the program to terminate.

#### 5.6.10 How to use your own exception?
The previous solution, although elegant and efficient, has one important weakness. Due to the somewhat easygoing way of declaring the constructors, the new exceptions cannot be used as-is, without a full list of required arguments.\
We’ll remove this weakness by setting the default values for all constructor parameters. Take a look →
```py
class PizzaError(Exception):
    def __init__(self, pizza='uknown', message=''):
        Exception.__init__(self,message)
        self.pizza = pizza

class TooMuchCheeseError(PizzaError):
    def __init__(self, pizza='uknown', cheese='>100', message=''):
        PizzaError.__init__(self,pizza,message)
        self.cheese = cheese

def makePizza(pizza,cheese):
  if pizza not in ['margherita', 'capricciosa', 'calzone']:
    raise PizzaError
  if cheese > 100:
    raise TooMuchCheeseError
  print("Pizza ready!")

for (pz,ch) in [('calzone',0),('margherita',110),('mafia',20)]:
  try:
    makePizza(pz,ch)
  except TooMuchCheeseError as tmce:
    print(tmce, ':', tmce.cheese)
  except PizzaError as pe:
    print(pe, ':', pe.pizza)
```
Now, if the circumstances permit, it is possible to use the class names alone.

#### 5.7.1 Generators – where to find them
Generator – what do you associate this word with? Perhaps it refers to some electronic device. Or perhaps it refers to a heavy and serious machine designed to produce power, electrical or other.\
A Python generator is a piece of specialized code able to produce a series of values, and to control the iteration process. This is why generators are very often called iterators, and although some may find a very subtle distinction between these two, we’ll treat them as one.\
You may not realize it, but you’ve encountered generators many, many times before. Take a look at the very simple snippet →
```py
for i in range(5):
  print(i)
```
The `range()` function is, in fact, a generator, which is (in fact, again) an iterator.\
What is the difference?\
A function returns one, well-defined value – it may be the result of a more or less complex evaluation of, e.g., a polynomial, and is invoked once – only once.\
A generator returns a series of values, and in general, is (implicitly) invoked more than once.\
In the example, the `range()` generator is invoked six times, providing five subsequent values from zero to four, and finally signaling that the series is complete.\ The above process is completely transparent. Let’s shed some light on it. Let’s show you the iterator protocol. 

#### 5.7.2 Generators – where to find them
The iterator protocol is a way in which an object should behave to conform to the rules imposed by the context of the for and in statements.\ An object conforming to the iterator protocol is called an iterator.\ An iterator must provide two methods:
- `__iter__()` which should return the object itself and which is invoked once (it’s needed for Python to successfully start the iteration)
- `__next__()` which is intended to return the next value (first, second, and so on) of the desired series – it will be invoked by the for/in statements in order to pass through the next iteration; if there are no more values to provide, the method should raise the StopIteration exception.

Does it look strange? Not at all. Look at the example → 
```py
class Fib:
  def __init__(self, nn):
    self.__n = nn
    self.__i = 0
    self.__p1 = self.__p2 = 1

  def __iter__(self):
    return self

  def __next__(self):
    self.__i += 1
    if self.__i > self.__n:
      raise StopIteration
    if self.__i in [1,2]:
      return 1
    ret = self.__p1 + self.__p2
    self.__p1, self.__p2 = self.__p2, ret
    return ret

class Class:
  def __init__(self,n):
    self.__iter = Fib(n)

  def __iter__():
    return self.__iter;

object = Class(8)

for i in object:
  print(i)
``` 
We’ve built a class able to iterate through the first n values (where n is a constructor parameter) of the Fibonacci numbers.\ Let us remind you – the Fibonacci numbers (Fibi) are defined as follows:
- Fib1 = 1
- Fib2 = 1
- Fibi = Fibi-1 + Fibi-2

In other words:
- the first two Fibonacci numbers are equal to 1;
- any other Fibonacci number is the sum of the two previous ones (e.g. Fib3 = 2, Fib4 = 3, Fib5 = 5, and so on)

Let’s dive into the code:
- lines 02 through 06: the class constructor prints a message (we’ll use this to trace the class’s behavior), prepares some variables (`__n` to store the series limit, `__i` to track the current Fibonacci number to provide, and `__p1` along with `__p2` to save the two previous numbers);
- lines 08 through 10: the `__iter__` method is obliged to return the iterator object itself; its purpose may be a bit ambiguous here, but there’s no mystery; try to imagine an object which is not an iterator (e.g., it’s a collection of some entities), but one of its components is an iterator able to scan the collection; the `__iter__` method should extract the iterator and entrust it with the execution of the iteration protocol; as you can see, the method starts its action by printing a message;
- lines 12 through 21: the `__next__` method is responsible for creating the sequence; it’s somewhat wordy, but this should make it more readable; first, it prints a message, then it updates the number of desired values, and if it reaches the end of the sequence, the method breaks the iteration by raising the StopIteration exception; the rest of the code is simple, and it precisely reflects the definition we showed you earlier;
- lines 23 and 24 make use of the iterator.

The code produces the following output:
``` 
__init__
__iter__
__next__
1
__next__
1
__next__
2
__next__
3
__next__
5
__next__
8
__next__
13
__next__
21
__next__
34
__next__
55
__next__
``` 
Look:
- the iterator object is instantiated first;
- next, Python invokes the `__iter__` method to get access to the actual iterator;
- the `__next__` method is invoked 11 times – the first ten times produce useful values, while the 11th terminates the iteration.

#### 5.7.3 Generators – where to find them
The previous example shows you a solution where the iterator object is a part of a more complex class.\ The code isn’t really sophisticated, but it presents the concept in a clear way.\ Take a look →
```py
class Fib:
  def __init__(self, nn):
    self.__n = nn
    self.__i = 0
    self.__p1 = self.__p2 = 1

  def __iter__(self):
    print("Fib iter")
    return self

  def __next__(self):
    self.__i += 1
    if self.__i > self.__n:
      raise StopIteration
    if self.__i in [1,2]:
      return 1
    ret = self.__p1 + self.__p2
    self.__p1, self.__p2 = self.__p2, ret
    return ret

class Class:
  def __init__(self,n):
    self.__iter = Fib(n)

  def __iter__(self):
    print("Class iter")
    return self.__iter;

object = Class(8)

for i in object:
  print(i)
``` 
We’ve built the Fib iterator into another class (we can say that we’ve composed it into the `Class` class). It’s instantiated along with Class’s object.\ The object of the class may be used as an iterator when (and only when) it positively answers to the `__iter__` invocation – this class can do it, and if it’s invoked in this way, it provides an object able to obey the iteration protocol.\ This is why the output of the code is the same as previously, although the object of the Fib class isn’t used explicitly inside the `for` loop’s context.

#### 5.7.4 The yield statement
The iterator protocol isn’t particularly difficult to understand and use, but it is also indisputable that the protocol is rather inconvenient.\ The main discomfort it brings is the need to save the state of the iteration between subsequent `__iter__` invocations.\ For example, the Fib iterator is forced to precisely store the place in which the last invocation has been stopped (i.e., the evaluated number and the values of the two previous elements). This makes the code larger and less comprehensible.\ This is why Python offers a much more effective, convenient, and elegant way of writing iterators.\ The concept is fundamentally based on a very specific and powerful mechanism provided by the keyword `yield`\ You may think of the `yield` keyword as a smarter sibling of the `return` statement, with one essential difference.

#### 5.7.5 The yield statement 
Take a look at this function →
```py
def fun(n):
  for i in range(n):
    return i
``` 
It looks strange, doesn’t it? It’s clear that the for loop has no chance to finish its first execution, as the return will break it irrevocably.\ Moreover, invoking the function won’t change anything – the for loop will start from scratch and will be broken immediately.\ We can say that such a function is not able to save and restore its state between subsequent invocations.\ This also means that a function like this cannot be used as a generator.

#### 5.7.6 The yield statement
We’ve replaced exactly one word in the code – can you see it?  → 
```py
def fun(n):
  for i in range(n):
    yield i
```
We’ve added `yield` instead of `return.`\ This little amendment turns the function into a generator, and executing the `yield` statement has some very interesting effects.\ First of all, it provides the value of the expression specified after the `yield` keyword, just like `return,` but doesn’t lose the state of the function.\ All the variables’ values are frozen, and wait for the next invocation, when the execution is resumed (not taken from scratch, like after `return).`\ There is one important limitation: such a function should not be invoked explicitly as – in fact – it isn’t a function anymore; it’s a generator object.\ The invocation will return the object’s identifier, not the series we expect from the generator.\ Due to the same reasons, the previous function (the one with the `return` statement) may only be invoked explicitly, and must not be used as a generator.\ Let us show you the new generator in action.

#### 5.7.7 How to build your own generator
This is how we’ve used it →
```py
def fun(n):
  for i in range(n):
    yield i
for v in fun(5):
  print(v)
``` 
The code produces the following output:
```
0
1
2
3
4
```

#### 5.7.8 How to build your own generator
What if you need a generator to produce the first n powers of 2?\ Nothing easier.\ Just look →
```py
def PowersOf2(n):
  pow = 1
  for i in range(n):
    yield pow
    pow *= 2
for v in PowersOf2(8):
  print(v)
``` 
The code prints:
```
1
2
4
8
16
32
64
128
```

#### 5.7.9 How to build your own generator
Generators may also be used within list comprehensions, just like here → 
```py
def PowersOf2(n):
  pow = 1
  for i in range(n):
    yield pow
    pow *= 2
t = [ x for x in PowersOf2(5) ]
print(t)
```
 This is the output you’ll see:
```
[1, 2, 4, 8, 16]
```

#### 5.7.10 How to build your own generator
The list() function can transform a series of subsequent generator invocations into a real list →
```py
def PowersOf2(n):
  pow = 1
  for i in range(n):
    yield pow
    pow *= 2
t = [ x for x in PowersOf2(5) ]
print(t)
``` 
The output looks as follows:
```
[1, 2, 4, 8, 16]
```

#### 5.7.11 How to build your own generator
Moreover, the context created by the in operator allows you to use a generator, too.
The example shows how to do it →
```py
def PowersOf2(n):
  pow = 1
  for i in range(n):
    yield pow
    pow *= 2
for i in range(20):
  if i in PowersOf2(4):
    print(i)
``` 
The code’s output is:
```
1
2
4
8
```

#### 5.7.12 How to build your own generator
Now let’s see a Fibonacci number generator, and ensure that it looks much better than the objective version based on the direct iterator protocol implementation.\ Here it is → 
```py
def Fib(n):
  p = pp = 1
  for i in range(n):
    if i in [0,1]:
      yield 1
    else:
      n = p + pp
      pp, p = p, n
      yield n
fibs = list(Fib(10))
print(fibs)
``` 
And this is the list produced by the generator:
```
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

#### 5.7.13 More about list comprehensions
You should be able to remember the rules governing the creation and use of a very special Python phenomenon named list comprehension – a simple and very impressive way of creating lists and their contents.\ In case you need it, here is a quick reminder → 
```py
list1 = []
for ex in range(6):
  list1.append(10 ** ex)
list2 = [10 ** ex for ex in range(6)]
print(list1)
print(list2)
``` 
There are two parts inside the code, both creating a list containing a few of the first natural powers of ten.\ The former uses a routine way of utilizing the for loop, while the latter makes use of the list comprehension and builds the list in situ, without needing a loop, or any other extended code.\ It looks like the list is created inside itself – it’s not true, of course, as Python has to perform nearly the same operations as in the first snippet, but it is indisputable that the second formalism is simply more elegant, and lets the reader to avoid any unnecessary details.\ The example outputs two identical lines containing the following text:
```
[1, 10, 100, 1000, 10000, 100000]
```

#### 5.7.14 More about list comprehensions
There is a very interesting syntax we want to show you now. Its usability is not limited to list comprehensions, but we have to admit that comprehensions are the ideal environment for it.\ It’s a conditional expression – a way of selecting one of two different values based on the result of a Boolean expression.\ Look →
```py
expression1 if condition else expression2
```
It may look a bit surprising at first glance, but you have to keep in mind that it is not a conditional instruction. Moreover, it’s not an instruction at all. It’s an operator.\ The value it provides is equal to `expression1` when the condition is true, and `expression2` otherwise.\ A good example will tell you more. 

#### 5.7.15 More about list comprehensions
And here is the example → 
```py
list = []
for x in range(10):
  list.append( 1 if x % 2 == 0 else 0 )
print(list)
``` 
The code fills a list with 1’s and 0’s – if the index of a particular element is odd, the element is set to 0, and to 1 otherwise.\ Simple? Maybe not at first glance.\ Elegant? Indisputably. Can you use the same trick within a list comprehension? Yes, you can.

#### 5.7.16 More about list comprehensions
This is how it can be done → 
```py
list = [ 1 if x % 2 == 0 else 0 for x in range(10) ]
``` 
Compactness and elegance – these two words come to mind when looking at the code.\
What do they have in common, generators and list comprehensions?  Is there any connection between them? Yes. A rather loose connection, but an unequivocal one. Just one change can turn any comprehension into a generator. 

#### 5.7.17 More about list comprehensions
Look at the code and see if you can find the detail that turns a list comprehension into a generator → 
```py
list = [ 1 if x % 2 == 0 else 0 for x in range(10) ]
genr = ( 1 if x % 2 == 0 else 0 for x in range(10) )
for v in list:
  print(v, end=" ")
print()
for v in genr:
  print(v, end=" ")
print()
``` 
It’s the parentheses.\ The brackets make a comprehension – the parentheses make a generator.\ The code, however, when run, produces two identical lines: 
```
1 0 1 0 1 0 1 0 1 0
1 0 1 0 1 0 1 0 1 0
```
 How can you know that the second assignment creates a generator, not a list? There is some proof we can show you. Apply the len() function to both these entities. `len(list)` will evaluate to 10. Clear and predictable. `len(genr)` will raise an exception, and you will see the following message: 
```
TypeError: object of type 'generator' has no len()
```

#### 5.7.18 More about list comprehensions
Of course, saving either the list or the generator is not necessary – you can create them exactly in the place where you need them – just like here →
```py
for v in [ 1 if x % 2 == 0 else 0 for x in range(10) ]:
  print(v, end=" ")
print()
for v in ( 1 if x % 2 == 0 else 0 for x in range(10) ):
  print(v, end=" ")
print()
```
Note: the same appearance of the output doesn’t mean that both loops work in the same way. In the first loop, the list is created (and iterated through) as a whole – it actually exists when the loop is being executed. In the second loop, there is no list at all – there are only subsequent values produced by the generator, one by one.

#### 5.7.19 The lambda function
The lambda function is a concept borrowed from mathematics, more specifically, from a part called the Lambda calculus, but these two phenomena are not the same. Mathematicians use the Lambda calculus in many formal systems connected with logic, recursion, or theorem provability. Programmers use the lambda function to simplify the code, to make it clearer and easier to understand.\ A lambda function is a function without a name (you can also call it an anonymous function). Of course, such a statement immediately raises the question: how do you use anything that cannot be identified?\ Fortunately, it’s not a problem, as you can name such a function if you really need, but, in fact, in many cases the lambda function can exist and work while remaining fully incognito.\ The declaration of the lambda function doesn’t resemble a normal function declaration in any way – see for yourself →
```py
lambda {parameters}: {expression}
```
Such a clause returns the value of the expression when taking into account the current value of the current lambda argument. As usual, an example will be helpful.

#### 5.7.20 The lambda function
The first example uses three lambda functions, but gives them names. Look at it carefully →
```py
two = lambda : 2
sqr = lambda x : x * x
pwr = lambda x,y : x ** y
for a in range(-2,3):
  print(sqr(a), end = ' ')
  print(pwr(a,two()))
```
The first lambda is an anonymous parameterless function that always returns 2. As we’ve assigned it to a variable named two, we can say that the function is not anonymous anymore, and we can use the name to invoke it. The second one is a one-parameter anonymous function that returns the value of its squared argument. We’ve named it as such, too. The third lambda takes two parameters and returns the value of the first one raised to the power of the second one. The name of the variable which carries the lambda speaks for itself. We don’t use pow to avoid confusion with the built-in function of the same name and the same purpose.\ The program produces the following output
```
4 4
1 1 
0 0 
1 1 
4 4
```
This example is clear enough to show how lambdas are declared and how they behave, but it says nothing about why they’re necessary, and what they’re used for, since they can all be replaced with routine Python functions. Where is the benefit?

#### 5.7.21 How to use lambdas and what for?
The most interesting part of using lambdas appears when you can use them in their pure form – as anonymous parts of code intended to evaluate a result.\ Imagine that we need a function (we’ll name it `printfunction`) which prints the values of a given (other) function for a set of selected arguments. We want `printfunction` to be universal – it should accept a set of arguments put in a list and a function to be evaluated, both as arguments – we don’t want to hardcode anything.\ This is how we’ve implemented the idea →
```py
def printfunction(args, fun):
  for x in args:
    print('f(',x,')=',fun(x),sep='')
def poly(x):
  return 2 * x**2 - 4 * x + 2
printfunction([x for x in range(-2,3)], poly)
```
The `printfunction()` function takes two parameters:
- the first, a list of arguments for which we want to print the results;
- the second, a function which should be invoked as many times as the number of values that are collected inside the first parameter.

Note: we’ve also defined a function named poly() – this is the function whose values we’re going to print. The calculation the function performs isn’t very sophisticated – it’s the polynomial (hence its name) of a form:
```
f(x) = 2x2 - 4x + 2
```
The name of the function is then passed to the `printfunction()` along with a set of five different arguments – the set is built with a list comprehension clause.\
The code prints the following lines:
```
f(-2)=18 
f(-1)=8 
f(0)=2 
f(1)=0 
f(2)=2
```
Can we avoid defining the poly() function, as we’re not going to use it more than once? Yes, we can – this is the benefit a lambda can bring.

#### 5.7.22 How to use lambdas and what for?
Can you see the difference? → 
```py
def printfunction(args, fun):
  for x in args:
    print('f(',x,')=',fun(x),sep='')
printfunction([x for x in range(-2,3)], lambda x: 2 * x**2 - 4 * x + 2)
```
The `printfunction()` has remained exactly the same, but there is no `poly()` function. We don’t need it anymore, as the polynomial is now directly inside the `printfunction()` invocation in the form of a lambda defined in the following way:
```py
lambda x: 2 * x**2 - 4 * x + 2
```
The code has become shorter, clearer, and more legible. Let us show you another place where lambdas can be useful. We’ll start with a description of `map(),` a built-in Python function. Its name isn’t too descriptive, its idea is simple, and the function itself is really usable.

#### 5.7.23 How to use lambdas and what for?
In the simplest of all possible cases, the `map()` function takes two arguments →
- a `function`;
- a `list`.
```py
map(function, list)
```
The above description is extremely simplified, as:
- the second `map()` argument may be any entity that can be iterated (e.g., a tuple, or just a generator)
- `map()` can accept more than two arguments.

The `map()` function applies the function passed by its first argument to all its second argument’s elements, and returns an iterator delivering all subsequent function results. You can use the resulting iterator in a loop, or convert it into a list using the list() function. Can you see a role for any lambda here?

#### 5.7.24 How to use lambdas and what for?
Here is some code for two lambdas → 
```py
list1 = [ x for x in range(5) ]
list2 = list(map(lambda x: 2 ** x, list1))
print(list2)
for x in map(lambda x: x * x, list2):
  print(x, end=' ')
print()
``` 
This is the intrigue:
- build the list1 with values from 0 to 4;
- next, use map along with the first lambda to create a new list in which all elements have been evaluated as two raised to the power taken from the corresponding element from list1;
- list2 is printed then;
- in the next step, use the map() function again to make use of the generator it returns and to directly print all the values it delivers; as you can see, we’ve engaged the second lambda here – it just squares each element from list2.

Try to imagine the same code without lambdas. Would it be any better? It’s unlikely.

#### 5.7.25 How to use lambdas and what for?
Another Python function which can be significantly beautified by the application of a lambda is `filter().` It expects the same kind of arguments as map(), but does something different – it filters its second argument while being guided by directions flowing from the function specified as the first argument (the function is invoked for each list element, just like in map()).\
The elements which return True from the function pass the filter – the others are rejected.\ The example shows the `filter()` function in action →\ ```py
from random import seed, randint
seed()
data = [ randint(-10,10) for x in range(5) ]
filtered = list(filter(lambda x: x > 0 and x % 2 == 0, data))
print(data)
print(filtered)
```
Note: we’ve made use of the random module to initialize the random number generator (not to be confused with the generators we’ve just talked about) with the `seed()` function, and to produce five random integer values from -10 to 10 using the `randint()` function. The list is then filtered, and only the numbers which are even and greater than zero are accepted.\ Of course, it’s not likely that you’ll receive the same results, but this is what our results looked like:
```
[6, 3, 3, 2, -7]
[6, 2]
```

#### 5.7.26 A brief look at closures
Let’s start with a definition: closure is a technique which allows the storing of values in spite of the fact that the context in which they have been created does not exist anymore. Intricate? A bit.\ Let’s start with a simple example → 
```py
def outer(par):
  loc = par
var = 1
outer(var)
print(var)
print(loc)
```
The example is obviously erroneous. The last two lines will cause a `NameError` exception – neither `par` nor `loc` is accessible outside the function. Both the variables exist when and only when the `outer()` function is being executed.

#### 5.7.27 A brief look at closures
We’ve modified the code significantly →
```py
def outer(par):
  loc = par
  def inner():
    retrn loc
  return inner
var = 1
fun = outer(var)
print(fun())
```
There is a brand new element in it – a function (named inner) inside another function (named outer).\ How does it work? Just like any other function except for the fact that `inner()` may be invoked only from within `outer().` We can say that `inner()` is `outer()’s` private tool – no other part of the code can access it.\ Look carefully:
- the `inner()` function returns the value of the variable accessible inside its scope, as `inner()` can use any of the entities at the disposal of `outer()`
- the `outer()` function returns the `inner()` function itself; more precisely, it returns a copy of the `inner()` function, the one which was frozen at the moment of `outer()’s` invocation; the frozen function contains its full environment, including the state of all local variables, which also means that the value of loc is successfully retained, although `outer()` ceased to exist a long time ago.

In effect, the code is fully valid, and outputs:
```
1
```
The function returned during the `outer()` invocation is a closure.

#### 5.7.28 A brief look at closures
A closure has to be invoked in exactly the same way in which it has been declared.\ In the previous example, the `inner()` function was parameterless, so we had to invoke it without arguments.\ It is fully possible to declare a closure equipped with an arbitrary number of parameters, e.g., one, just like the `power()` function →
```py
def makeclosure(par):
  loc = par
  def power(p):
    return p ** loc
  return power
fsqr = makeclosure(2)
fcub = makeclosure(3)
for i in range(5):
  print(i,fsqr(i),fcub(i))
```
This means that the closure not only makes use of the frozen environment, but it can also modify its behavior by using values taken from the outside.\ This example shows one more interesting circumstance – you can create as many closures as you want using one and the same piece of code. This is done with a function named `makeclosure().`\
Note:
- the first closure obtained from `makeclosure()` defines a tool squaring its argument;
- the second one is designed to cube the argument.

This is why the code produces the following output:
```
0 0 0 
1 1 1 
2 4 8 
3 9 27 
4 16 64
```

#### 5.8.1 Accessing files from Python code
One of the most common issues in the developer’s job is to process data stored in files while the files are usually physically stored using storage devices – hard, optical, network, or solid-state disks.\ It’s easy to imagine a program that sorts 20 numbers, and it’s equally easy to imagine the user of this program entering these twenty numbers directly from the keyboard.\
It’s much harder to imagine the same task when there are 20,000 numbers to be sorted, and there isn’t a single user who is able to enter these numbers without making a mistake.\ It’s much easier to imagine that these numbers are stored in the disk file which is read by the program. The program sorts the numbers and doesn’t send them to the screen, but instead creates a new file and saves the sorted sequence of numbers there.\ If we want to implement a simple database, the only way to store the information between program runs is to save it into a file (or files if your database is more complex).\ In principle, any non-simple programming problem relies on the use of files, whether it processes images (stored in files), multiplies matrices (stored in files), or calculates wages and taxes (reading data stored in files).\ You may ask why we have waited until now to show you these issues.\ The answer is very simple – Python’s way of accessing and processing files is implemented using a consistent set of objects. There is no better moment to talk about it.

#### 5.8.2 File names
Different operating systems can treat the files in different ways. For example, Windows uses a different naming convention than the one adopted in Unix/Linux systems.\ If we use the notion of a canonical file name (a name which uniquely defines the location of the file regardless of its level in the directory tree) we can realize that these names look different in Windows and in Unix/Linux →\
```
Windows
C:\directory\file

Unix
/directory/file
```
As you can see, systems derived from Unix/Linux don’t use the disk drive letter (e.g., C:) and all the directories grow from one root directory called / ,while Windows systems recognize the root directory as \.

#### 5.8.3 File names
In addition, Unix/Linux system file names are case-sensitive. Windows systems store the case of letters used in the file name, but don’t distinguish between their cases at all.\ This means that these two strings → describe two different files in Unix/Linux systems, but are the same name for just one file in Windows systems.\ The main and most striking difference is that you have to use two different separators for the directory names: \ in Windows, and / in Unix/Linux.\ This difference is not very important to the normal user, but is very important when writing programs in Python.\ To understand why, try to recall the very specific role played by the \ inside Python strings. 

#### 5.8.4 File names
Suppose you’re interested in a particular file located in the directory dir, and named file.\ Suppose also that you want to assign a string containing the name of the file.\ In Unix/Linux systems, it may look as follows →
```
name = '/dir/file'
```

#### 5.8.5 File names
But if you try to code it for the Windows system:\
```py
name = "\dir\file"
```
you’ll get an unpleasant surprise: either Python will generate an error, or the execution of the program will behave strangely, as if the file name has been distorted in some way.\ In fact, it’s not strange at all, but quite obvious and natural. Python uses the \ as an escape character (like \n).\ This means that Windows file names must be written as follows →\ Fortunately, there is also one more solution. Python is smart enough to be able to convert slashes into backslashes each time it discovers that it’s required by the OS.\ This means that any the following assignments:
```py
name = "/dir/file"
name = "c:/dir/file"
```
will work with Windows, too.

#### 5.8.6 File names
Any program written in Python (and not only in Python, because that convention applies to virtually all programming languages) does not communicate with the files directly, but through some abstract entities that are named differently in different languages or environments – the most-used terms are handles or streams (we’ll use them as synonyms here).\ The programmer, having a more- or less-rich set of functions/methods, is able to perform certain operations on the stream, which affect the real files using mechanisms contained in the operating system kernel.\
In this way, you can implement the process of accessing any file, even when the name of the file is unknown at the time of writing the program.\ The operations performed with the abstract stream reflect the activities related to the physical file.\ To connect (bind) the stream with the file, it’s necessary to perform an explicit operation.\ The operation of connecting the stream with a file is called opening the file, while disconnecting this link is named closing the file.\ Hence, the conclusion is that the very first operation performed on the stream is always open and the last one is close. The program, in effect, is free to manipulate the stream between these two events and to handle the associated file.\ This freedom is limited, of course, by the physical characteristics of the file and the way in which the file has been opened.\ Let us say again that the opening of the stream can fail, and it may happen due to several reasons: the most common is the lack of a file with a specified name.\ It can also happen that the physical file exists, but the program is not allowed to open it. There’s also the risk that the program has opened too many streams, and the specific operating system may not allow the simultaneous opening of more than n files (e.g., 200).\ A well-written program should detect these failed openings, and react accordingly.

#### 5.8.7 File streams
The opening of the stream is not only associated with the file, but should also declare the manner in which the stream will be processed. This declaration is called an open mode.\ If the opening is successful, the program will be allowed to perform only the operations which are consistent with the declared open mode.\ There are two basic operations performed on the stream:
- read from the stream: the portions of the data are retrieved from the file and placed in a memory area managed by the program (e.g., a variable);
- write to the stream: the portions of the data from the memory (e.g., a variable) are transferred to the file.

#### 5.8.8 File streams
There are three basic modes used to open the stream:
1. read mode: a stream opened in this mode allows read operations only; trying to write to the stream will cause an exception (the exception is named UnsupportedOperation, which inherits OSError and ValueError, and comes from the io module);
2. write mode: a stream opened in this mode allows write operations only; attempting to read the stream will cause the exception mentioned above;
3. update mode: a stream opened in this mode allows both writes and reads.

Before we discuss how to manipulate the streams, we owe you some explanation. The stream behaves almost like a tape recorder.\ When you read something from a stream, a virtual head moves over the stream according to the number of bytes transferred from the stream.\ When you write something to the stream, the same head moves along the stream recording the data from the memory.\ Whenever we talk about reading from and writing to the stream, try to imagine this analogy. The programming books refer to this mechanism as the current file position, and we’ll also use this term.\ It’s necessary now to show you the object responsible for representing streams in programs.

#### 5.8.9 File handles
Python assumes that every file is hidden behind an object of an adequate class.\ Of course, it’s hard not to ask how to interpret the word adequate.\ Files can be processed in many different ways – some of them depend on the file’s contents, some on the programmer’s intentions. In any case, different files may require different sets of operations, and behave in different ways.\ An object of an adequate class is created when you open the file and annihilate it at the time of closing.\ Between these two events, you can use the object to specify what operations should be performed on a particular stream. The operations you’re allowed to use are imposed by the way in which you’ve opened the file.\ In general, the object comes from one of the classes shown here →
![](5809.jpg)
Note: you never use constructors to bring these objects to life. The only way you obtain them is to invoke the function named open().\
The function analyses the arguments you’ve provided, and automatically creates the required object.\ If you want to get rid of the object, you invoke the method named close().\ The invocation will sever the connection to the object, and the file and will remove the object.\ For our purposes, we’ll concern ourselves only with streams represented by BufferIOBase and TextIOBase objects. You’ll understand why soon.

#### 5.8.10 File handles
Due to the type of the stream’s contents, all the streams are divided into text and binary streams.\
The latter ones are structured in lines; that is, they contain typographical characters (letters, digits, punctuation, etc.) arranged in rows (lines), as seen with the naked eye when you look at the contents of the file in the editor.\ This file is written (or read) mostly character by character, or line by line.\ The former files don’t contain text but a sequence of bytes of any value. This sequence can be, for example, an executable program, an image, an audio or a video clip, a database file, etc.\ Because these files don’t contain lines, the reads and writes relate to portions of data of any size. Hence the data is read/written byte by byte, or block by block, where the size of the block usually ranges from one to an arbitrarily chosen value.\ Then comes a subtle problem. In Unix/Linux systems, the line ends are marked by a single character named LF (ASCII code 10) designated in Python programs as \n.\ Other operating systems, especially these derived from the prehistoric CP/M system (which applies to Windows family systems, too) use a different convention: the end of line is marked by a pair of characters, CR and LF (ASCII codes 13 and 10) which can be encoded as \r\n.\ This ambiguity can cause various unpleasant consequences. If you create a program responsible for processing a text file, and it is written for Windows, you can recognize the ends of the lines by finding the \r\n characters, but the same program running in a Unix/Linux environment will be completely useless, and vice versa: the program written for Unix/Linux systems might be useless in Windows.\ Such undesirable features of the program, which prevent or hinder the use of the program in different environments, is called non-portability.\ Similarly, the trait of the program allowing execution in different environments is called portability. A program endowed with such a trait is called a portable program.

#### 5.8.11 File handles
Since portability issues were (and still are) very serious, a decision was made to definitely resolve the issue in a way that doesn’t engage the developer’s attention.\ It was done at the level of classes, which are responsible for reading and writing characters to and from the stream. It works in the following way:
1. when the stream is open and it’s advised that the data in the associated file will be processed as text (or there is no such advisory at all), it is switched into text mode;
2. during reading/writing of lines from/to the associated file, nothing special occurs in the Unix environment, but when the same operations are performed in the Windows environment, a process called a translation of newline characters occurs: when you read a line from the file, every pair of \r\n characters is replaced with a single \n character, and vice versa; during write operations, every \n character is replaced with a pair of \r\n characters;
3. the mechanism is completely transparent to the program, which can be written as if it was intended for processing Unix/Linux text files only; the source code run in a Windows environment will work properly, too;
4. when the stream is open and it’s advised to do so, its contents are taken as-is, without any conversion – no bytes are added or omitted.

#### 5.8.12 Opening the streams
The opening of the stream is performed by a function which can be invoked in the following way →
```py
stream = open(file,mode='r',encoding=None)
```
Note: the mode and encoding arguments may be omitted – their default values are assumed then:
- the name of the function speaks for itself;
- if the opening is successful, the function returns a stream object; otherwise, an exception is raised (e.g., FileNotFoundError if the file you’re going to read doesn’t exist);
- the first parameter of the function specifies the name of the file to be associated with the stream;
- the second parameter specifies the open mode used for the stream; it’s a string filled with a sequence of characters, and each of them has its own special meaning (more details soon);
- the opening must be the very first operation performed on the stream.

Let us now present you with the most important and useful open modes.

#### 5.8.13 Opening the streams
“r” open mode: read
- the stream will be opened in “read” mode
- the file associated with the stream must exist and has to be readable, otherwise open() function raises exception 

#### 5.8.14 Opening the streams
“w” open mode: write
- the stream will be opened in “write” mode
- the file associated with the stream doesn't need to exist; if it doesn't exist it will be created; if it exists it will truncated to the length of zero (erased);  if the creation isn't possible (e.g. due to system permissions) the open() function raises an exception

#### 5.8.15 Opening the streams
“a” open mode: append
- the stream will be opened in “append” mode;
- the file associated with the stream doesn't need to exist; if it doesn't exist it will be created; if it exists the virtual recording head will be set at the end of the file (the previous content of the file remains untouched)

#### 5.8.16 Opening the streams
“r+” open mode: read and update
- the stream will be opened in “read and update” mode;
- the file associated with the stream must exist and has to be writeable, otherwise the open() function raises an exception
- both read and write operations are allowed for the stream

#### 5.8.17 Opening the streams
“w+” open mode: write and update
- the stream will be opened in “write and update” mode;
- the file associated with the stream doesn't need to exist; if it doesn't exist it will be created; the previous content of the file remains untouched
- both read and write operations are allowed for the stream 

#### 5.8.18 Selecting text and binary modes
If there is a letter b at the end of the mode string it means that the stream is to be opened in the binary mode. If the mode string ends with a letter t the stream is opened in the text mode. This is the default behaviour assumed when no binary/text mode specifier was used.\ Finally, the successful opening of the file will set the current file position (the virtual reading/writing head) before the first byte of the file if the mode is not a and after the last byte of file if the mode is set to a.

#### 5.8.19 Opening the stream for the first time
Imagine that we want to develop a program that reads content of the text file named:
```
C:\Users\User\Desktop\file.txt
```
How to open that file for reading? Here's the relevant snippet of the code → 
```py
try: 
  stream = open("c:/users/user/Desktop/file.txt","r")
  # actual processing goes here
  stream.close()
except Exception as exc:
  print("open failed:", exc)
```
What's going on here?
- we've open the try-except block as we want to handle runtime errors softly
- we use the open() function to try to open the specified file (note the way we've specified the file name)
- the open mode is defined as text to read (as text is default setting, we can skip the t in mode string)
- in case of success we get an object from the open() function and we assign it to the stream variable;
- if open() fails, we handle the exception printing full error information (it's definitely good to know what exactly happened) 

#### 5.8.20 Pre-opened streams
We said earlier that any stream operation must be preceded by the open() function invocation. There are three well-defined exceptions to the rule. When our program starts the three streams are already opened and don't require any extra preparations. What's more, your program can use these streams explicitly if you take care to import the sys module:
```py
import sys
```
because that's where the declaration of the three streams is placed.\ The names of these streams look as follows →
- `sys.stdin`
- `sys.stdout`
- `sys.stderr`

#### 5.8.21 Pre-opened streams
stdin (as standard input)
- the stdin stream is normally associated with the keyboard, pre-open for reading and regarded as the primary data source for the running programs
- the well-known input() function reads data from stdin by default

#### 5.8.22 Pre-opened streams
stdout (as standard output)
- the stdout stream is normally associated with the screen, pre-open for writing, regarded as the primary target for outputting data by the running program
- the well-known print()function outputs the data to stdout stream

#### 5.8.23 Pre-opened streams
stderr (as standard error output)
- the stderr stream is normally associated with the screen, pre-open for writing, regarded as the primary place where the running program should send information on the errors encountered during its work
- we haven't presented any method to send the data to this stream (we will do it soon, we promise)
- The separation of stdout (useful results produced by the program) from the stderr (error messages, undeniably useful but does not provide results) gives the possibility of redirecting these two types of information to the different targets. More extensive discussion of this issue is beyond the scope of our course. The operation system handbook will provide more information on these issues.  

#### 5.8.24 Closing streams
The last operation performed on a stream (this doesn't include the stdin, stdout, and stderr streams which don't require it) should be closing. That action is performed by a method invoked from within open stream object →
- the name of the function is definitely self-commenting
- the function expects exactly no arguments;  the stream doesn't need to be opened
- the function returns nothing but raises IOError exception in case of error
- most developers believe that the close() function always succeeds and thus there is no need to check if it's done its task properly. This belief is only partly justified. If the stream was opened for writing and then a series of write operations were performed it may happen that the data sent to the stream has not been transferred to the physical device yet (due to mechanism called caching or buffering). Since the closing of the stream forces the buffers to flush them, it may be that the flushes fail and therefore the close() fails too.

We have already mentioned failures caused by functions operating with streams but not mentioned a word how exactly we can identify the cause of the failure. The possibility of making a diagnosis exists and is provided by one of streams' exception component which we are going to tell you about just now.

#### 5.8.25 Diagnosing stream problems
The IOError object is equipped with a property named errno (the name comes from the phrase error number) and you can access it as follows →\ The value of the errno attribute can be compared with one of the predefined symbolic constants defined in the errno module. 
```py
try:
  # some operations
except IOError as exc:
  print(exc.errno)
```

#### 5.8.26 Diagnosing stream problems
We present a couple of constants useful for detecting stream errors →
- `errno.EACCES` (Permission denied) occurs when you try to open a file with the "read only" attribute for writing, for example
- `errno.EBADF` (Bad file number) occurs when you try to operate with the unopened stream, for example
- `errno.EEXIST` (File exists) occurs when you try to rename a file with its previous name, for example
- `errno.EFBIG` (File too big) occurs when you create a file that is larger than the maximum allowed by the OS
- `errno.EISDIR` (Is a directory) occurs when you try to treat the directory name as the name of the ordinary file
- `errno.EMFILE` (too many open files) occurs when you try to simultaneously open more streams than acceptable for your operating system
- `errno.ENOENT` (no such file or directory) occurs when you try to access non-existent file/directory
- `erno.ENOSPC` (no space left) occurs when there is no free space on the media
  
The complete list is much longer (it includes also some error codes not related to the stream processing)

#### 5.8.27 Diagnosing stream problems
If you are a very careful programmer, you may feel the need to use the sequence of statements similar to those presented aside →
```py
import errno
try: 
  stream = open("c:/users/user/Desktop/file.txt","r")
  # actual processing goes here
  stream.close()
except Exception as exc:
  if exc.errno == errno.ENOENT:
    print("The file doesn't exist")
  elif exc.errno == errno.EMFILE:
    print("You've opened to many files")
  else:
    printf("The error number is",exc.errno)
```

#### 5.8.28 Diagnosing stream problems
Fortunately, there is a function that can dramatically simplify the error handling code. It’s named strerror(), it comes from os module and expects just one argument – an error number.\ Its role is simple: you give an error number and get a string describing the meaning of the error.\ Note: if you pass a non-existent error code (a number which is not bound to any actual error), the function will raise ValueError exception.\ Now we can simplify our code in the following way →
```py
from os import strerror
try: 
  stream = open("c:/users/user/Desktop/file.txt","r")
  # actual processing goes here
  stream.close()
except Exception as exc:
  print("File could not be opened:",strerror(exc.errno));
```

#### 5.9.1 Dealing with text files
Prepare a simple text file with some short, simple content.\
We’re going to show you some basic techniques you can utilize to read the file contents in order to process them.\
The processing will be very simple – you’re going to copy the file’s contents to the console, and count all the characters the program has read in.\ But remember – our understanding of a text file is very strict. In our sense, it’s a plain text file – it may contain only text, without any additional decorations (formatting, different fonts, etc.).\ Don’t create the file using any advanced text processor like MS Word, LibreOffice Writer, or something like this. Use the very basics your OS offers: Notepad, vim, gedit, etc.\ If your text files contain some national characters not covered by the standard ASCII charset, you may need an additional step. Your open() function invocation may require an argument denoting specific text encoding.\ For example, if you’re using a Unix/Linux OS configured to use UTF-8 as a system-wide setting, the open() function may look as follows:\
```py
str = open('file.txt', 'rt', encoding='utf-8')
```
where the encoding argument has to be set to a value which is a string representing proper text encoding (UTF-8, here).\ Consult your OS documentation to find an encoding name adequate to your environment.\ We’ve assumed that your sample text is placed in a text file name text.txt. We’ll use this name in all our snippets.

#### 5.9.2 Dealing with text files
Reading the text file’s contents can be performed using several different methods – none of them is any better or worse than any other. It’s up to you which of them you prefer and like. Some of them will sometimes be handier, and sometimes more troublesome. Be flexible. Don’t be afraid to change your preferences.\ The most basic of these methods is the one offered by the read() function.\ If applied to a text file, the function is able to:
- read a desired number of characters (including just one) from the file, and return them as a string;
- read all the file contents, and return them as a string;
- if there is nothing more to read (the virtual reading head reaches the end of the file), the function returns an empty string.

We’ll start with the simplest variant →
```py
from os import strerror
try:
  cnt = 0
  s = open('text.txt',"rt")
  ch = s.read(1)
  while ch != '':
    print(ch,end='')
    cnt += 1
    ch = s.read(1)
  s.close()
  print("Characters in file:", cnt)
except IOError as e:
  print("I/O error occurred: ", strerror(e.errno))
``` 
The routine is rather simple:
- use the try-except mechanism and open the file of the predetermined name;
- try to read the very first character from the file;
- if you succeed (this is proven by a positive result of the while condition check) output the character (note the end= argument – it’s important! You don’t want to skip to a new line after every character!);
- update the counter, too;
- try to read the next character, and the process repeats.  

#### 5.9.3 Dealing with text files
If you’re absolutely sure that the file’s length is safe and you can read the whole file to the memory at once, you can do it – the read() function, invoked without any arguments or with an argument that evaluates to None, will do the job for you.\
Remember – reading a terabyte-long file using this method may corrupt your OS.\Don’t expect miracles – computer memory isn’t stretchable.\
What do you think of it? →
```py
from os import strerror
try:
  cnt = 0
  s = open('text.txt','rt')
  content = s.read()
  for ch in content:
    print(ch,end='')
    cnt += 1
  s.close()
  print("Characters in file:", cnt)
except IOError as e:
  print("I/O error occurred: ", strerr(e.errno))
``` 
1. open the file as previously;
2. read its contents by one read() function invocation;
3. next, process the text, iterating through it with a regular for loop, and updating the counter value at  each turn of the loop;

The result will be exactly the same as previously.

#### 5.9.4 Dealing with text files
If you want to treat the file’s contents as a set of lines, not a bunch of characters, the readline() method will help you with that.\ The method tries to read a complete line of text from the file, and returns it as a string in the case of success. Otherwise, it returns an empty string.\ This opens up new opportunities – you can also count lines easily, not only characters.\ Let’s make use of it. Just like here → 
```py
from os import strerror
try:
  ccnt = lcnt = 0
  s = open('text.txt','rt')
  line = s.readline()
  while line != '':
    lcnt += 1
    for ch in line:
      print(ch,end='')
      ccnt += 1
    line = s.readline()
  s.close()
  print("Characters in file:", ccnt)
  print("Lines in file:     ", lcnt)
except IOError as e:
  print("I/O error occurred: ", strerr(e.errno))
```
As you can see, the general idea is exactly the same as in both previous examples.

#### 5.9.5 Dealing with text files
Another method, which treats text file as a set of lines, not characters, is readlines().\ The readlines() method, when invoked without arguments, tries to read all the file contents, and returns a list of strings, one element per file line.\ If you’re not sure that the file size is small enough and don’t want to test the OS, you can convince the readlines() method to read not more than a specified number of bytes at once (the returning value remains the same – it’s a list of a string).\ The maximum accepted input buffer size is passed to the method as its argument.\ You may expect that readlines() can process a file’s contents more effectively than readline(), as it may need to be invoked fewer times.\ Note: when there is nothing to read from the file, the method returns an empty list. Use it to detect the end of the file.\ To the extent of the buffer’s size, you can expect that increasing it may improve input performance, but there is no golden rule for it – try to find the optimal values yourself.\ We’ve modified the code to show you how to use readlines()→ 
```py
from os import strerror
try:
  ccnt = lcnt = 0
  s = open('text.txt','rt')
  lines = s.readlines(20)
  while len(lines) != 0:
    for line in lines:
      lcnt += 1
      for ch in line:
        print(ch,end='')
        ccnt += 1
    lines = s.readline(10)
  s.close()
  print("Characters in file:", ccnt)
  print("Lines in file:     ", lcnt)
except IOError as e:
  print("I/O error occurred: ", strerr(e.errno))
```
We’ve decided to use a 15-byte-long buffer. Don’t think it’s a recommendation.\
We’ve used such a value to avoid the situation in which the first `readlines()` invocation consumes the whole file.\ We want the method to be forced to work harder, and to demonstrate its capabilities.\ There are two nested loops in the code – the outer one uses readlines()’s result to iterate through it, while the inner one prints the lines character by character.

#### 5.9.6 Dealing with text files
The last example we want to present shows a very interesting trait of the object returned by the `open()` function in text mode.\
We think it may surprise you – the object is an instance of the iterable class.\
Strange? Not at all.\
Usable? Yes, absolutely.\
The iteration protocol defined for the file object is very simple – its `__next__` method just returns the next line read in from the file.\
Moreover, you can expect that the object automatically invokes close() when any of the file reads reaches the end of the file.\
Look how simple and clear the code has now become →
```py
from os import strerror
try:
  ccnt = lcnt = 0
  for line in open('text.txt','rt'):
    lcnt += 1
    for ch in line:
      print(ch,end='')
      ccnt += 1
  print("Characters in file:", ccnt)
  print("Lines in file:     ", lcnt)
except IOError as e:
  print("I/O error occurred: ", strerr(e.errno))
```

#### 5.9.7 Dealing with text files
Writing text files seems to be simpler, as in fact there is one method that can be used to perform such a task.\
The method is named write() and it expects just one argument – a string that will be transferred to an open file (don’t forget – the open mode should reflect the way in which the data is transferred – writing a file opened in read mode won’t succeed).\
No newline character is added to the write()’s argument, so you have to add it yourself if you want the file to be filled with a number of lines.\
The example presented here → shows a very simple code that creates a file named newtext.txt (note: the open mode w ensures that the file will be created from scratch, even if it exists and contains data) and then puts ten lines into it.\
The string to be recorded consists of the word line, followed by the line number. We’ve decided to write the string’s contents character by character (this is done by the inner for loop) but you’re not obliged to do it in this way.\
We just wanted to show you that write() is able to operate on single characters.\
The code creates a file filled with the following text:
```
line #1
line #2
line #3
line #4
line #5
line #6
line #7
line #8
line #9
line #10
```
```py
from os import strerror
try:
  fo = open('newtext.txt','wt')
  for i in range(10):
    s = "line #" + str(i+1) + "\n"
    for ch in s:
      fo.write(ch)
  fo.close()
except IOError as e:
  print("I/O error occurred: ", strerr(e.errno))
```

#### 5.9.8 Dealing with text files
We’ve modified the previous code to write whole lines to the text file – this is how it looks →
```py
from os import strerror
try:
  fo = open('newtext.txt','wt')
  for i in range(10):
    fo.write("line #" + str(i+1) + "\n")
  fo.close()
except IOError as e:
  print("I/O error occurred: ", strerr(e.errno))
```
The contents of the newly created file are the same.\
Note: you can use the same method to write to the stderr stream, but don’t try to open it, as it’s always open implicitly.\
For example, if you want to send a message string to stderr to distinguish it from normal program output, it may look like this:
```py
import sys
sys.stderr.write("Error message") 
```

#### 5.9.9 What is bytearray?
Before we start talking about binary files, we have to tell you about one of the specialized classes Python uses to store amorphous data.\
Amorphous data is data which have no specific shape or form – they are just a series of bytes.\
This doesn’t mean that these bytes cannot have their own meaning, or cannot represent any useful object, e.g., bitmap graphics.\
The most important aspect of this is that in the place where we have contact with the data, we are not able to, or simply don’t want to, know anything about it.\
Amorphous data cannot be stored using any of the previously presented means – they are neither strings nor lists.\
There should be a special container able to handle such data.\
Python has more than one such container – one of them is a specialized class name bytearray – as the name suggests, it’s an array containing (amorphous) bytes.\
If you want to have such a container, e.g., in order to read in a bitmap image and process it in any way, you need to create it explicitly, using one of available constructors.\
Take a look →
```py
data = bytearray(100)
```
Such an invocation creates a bytearray object able to store ten bytes.\
Note: such a constructor fills the whole array with zeros.

#### 5.9.10 What is bytearray?
Byte arrays resemble lists in many respects. For example, they are mutable, they’re a subject of the len() function, and you can access any of their elements using conventional indexing.\
There is one important limitation – you mustn’t set any byte array elements with a value which is not an integer (violating this rule will cause a TypeError exception) and you’re not allowed to assign a value that doesn’t come from the range 0 to 255 inclusive (unless you want to provoke a ValueError exception).\
You can treat any byte array elements as integer values – just like in this example →
```py
data = bytearray(10)
for i in range(len(data)):
  data[i] = 10 - i
for b in data:
  print(hex(b))
```
Note: we’ve used two methods to iterate the byte arrays, and made use of the hex() function to see the elements printed as hexadecimal values.\
Now we’re going to show you how to write a byte array to a binary file – binary, as we don’t want to save its readable representation – we want to write a one-to-one copy of the physical memory content, byte by byte.
