# Certified Associate of Python Programming, Module 4
#### 4.1.1 What is a module?
Computer code has a tendency to grow. We can say that code that doesn’t grow is probably completely unusable or abandoned. A real, wanted, and widely used code develops continuously, as both users’ demands and users’ expectations develop in their own rhythms. A code which is not able to respond to users’ needs will be forgotten quickly, and instantly replaced with a new, better, and more flexible code. Be prepared for this, and never think that any of your programs is eventually completed. The completion is a transition state and usually passes quickly, after the first bug report. Python itself is a good example how the rule acts.\
Growing code is in fact a growing problem. A larger code always means tougher maintenance. Searching for bugs is always easier where the code is smaller (just as finding a mechanical breakage is simpler when the machinery is simpler and smaller). Moreover, when the code being created is expected to be really big (you can use a total number of source lines as a useful, but not very accurate, measure of a code’s size) you may want (or rather, you will be forced) to divide it into many parts, implemented in parallel by a few, a dozen, several dozen, or even several hundred individual developers.\
Of course, this cannot be done using one large source file, which is edited by all programmers at the same time. This will surely lead to a spectacular disaster.\
If you want such a software project to be completed successfully, you have to have the means allowing you to:
- **divide** all the tasks among the developers;
- **join** all the created parts into one working whole.

For example, a certain project can be divided into two main parts:
- the user interface (the part that communicates with the user using widgets and a graphical screen)
- the logic (the part processing data and producing results)

Each of these parts can be (most likely) divided into smaller ones, and so on.\
Such a process is often called **decomposition**.\
For example, if you were asked to arrange a wedding, you wouldn’t do everything yourself – you would find a number of professionals and split the task between them all.
How do you divide a piece of software into separate but cooperating parts? This is the question. Modules are the answer.

#### 4.1.2 How to make use of a module
The handling of modules consists of two different issues:
- the first (probably the most common) happens when you want to use an already existing module, written by someone else, or created by yourself during your work on some complex project – in this case you are the module’s **user**;
- the second occurs when you want to create a brand new module, either for your own use, or to make other programmers’ lives easier – you are the module’s **supplier**.

Let’s discuss them separately.

#### 4.1.3 How to make use of a module
First of all, a module is identified by its **name**. If you want to use any module, you need to know the name. A (rather large) number of modules is delivered together with Python itself. You can think of them as a kind of “Python extra equipment”.\
All these modules, along with the built-in functions, form the “Python standard library” – a special sort of library where modules play the roles of books (we can even say that folders play the roles of shelves). If you want to take a look at the full list of all “volumes” collected in that library, you can find it [ here ](https://docs.python.org/3/library/index.html).\
Each module consists of entities (like a book consists of chapters). These entities can be functions, variables, constants, classes, and objects. If you know how to access a particular module, you can make use of any of the entities it stores.\
Let’s start the discussion with one of the most frequently used modules, named math. Its name speaks for itself – the module contains a rich collection of entities (not only functions) which enable a programmer to effectively implement calculations demanding the use of mathematical functions, like `sin()` or `log()`.

#### 4.1.4 Importing a module
To make a module usable, you must **import** it (think of it like of taking a book off the shelf). Importing a module is done by an instruction named `import`. Note: `import` is also a keyword (with all the consequences of this fact).\
Let’s assume that you want to use two entities provided by the `math` module:
- a symbol (constant) representing a precise (as precise as possible using double floating-point arithmetic) value of π (although using a Greek letter to name a variable is fully possible in Python, the symbol is named pi – it’s a more convenient solution, especially for that part of the world which neither has nor is going to use a Greek keyboard)
- a function named `sin()` (the computer equivalent of the mathematical sine function)

Both these entities are available through the math module, but the way in which you can use them strongly depends on how the import has been done.

#### 4.1.5 Importing a module
The simplest way to import a particular module is to use the import instruction as follows →\
The clause contains:
- the `import` keyword;
- the **name** of the module which is subject to import.

The instruction may be located anywhere in your code, but it must be placed before the first use of any of the module’s entities.

#### 4.1.6 Importing a module
If you want to (or have to) import more than one module, you can do it by repeating the import clause, or by listing the modules after the `import` keyword, like here →\
```py
import math,sys
```
The instruction imports two modules, first the one named `math` and then the second named `sys`.\
The modules’ list may be arbitrarily long.

#### 4.1.7 Importing a module
To continue, you need to become familiar with an important term →\
Don’t worry, we won’t go into great detail – this explanation is going to be as short as possible.\
A **namespace** is a space (understood in a non-physical context) in which **some names exist** and the names don’t conflict with each other (i.e., there are not two different objects of the same name). We can say that each social group is a namespace – the group tends to name each of its members in a unique way (e.g., parents won’t give their children the same first names). This uniqueness may be achieved in many ways, e.g., by using nicknames along with the first names (it will work inside a small group like a class in a school) or by assigning special identifiers to all members of the group (the US Social Security Number is a good example of such practice).\
Inside a certain namespace, each name must remain **unique**. This may mean that some names may disappear when any other entity of an already known name enters the namespace. We’ll show you how it works and how to control it, but first, let’s return to imports.

#### 4.1.8 Importing a module
If the module of a specified name **exists** and is **accessible** (a module is in fact a **Python source file**), Python imports its contents, i.e., **all the names defined in the module become known**, but they don’t enter your code’s namespace.\
This means that you can have your own entities named `sin` or `pi` and they won’t be affected by the import in any way.\
At this point, you may be wondering how to access the `pi` coming from the `math` module.\
To do this, you have to qualify the `pi` with the name of its original module.

#### 4.1.9 Importing a module
This is the way in which you qualify the names of `pi` and `sin` with the name of its originating module →\
```
math.pi
math.sin
```
<<<<<<< HEAD
It’s simple, you put:
=======
It’s simple, you put: 
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
- the name of the module (math here)
- a dot;
- the name of the entity (pi here)

Such a form clearly indicates the namespace in which the name exists.\
Note: using this qualification is compulsory if a module has been imported by the `import` module instruction. It doesn’t matter if any of the names from your code and from the module’s namespace are in conflict or not.

#### 4.1.10 Importing a module
This first example won’t be very advanced – we just want to print the value of sin(1⁄2π).\
This is how to test it →
```py
import math
print(math.sin(math.pi/2))
```
The code outputs the expected value:
```
1.0
```
Note: removing any of the two qualifications will make the code erroneous. There is no other way to enter `math`’s namespace if you did the following:
```py
import math
```

#### 4.1.11 Importing a module
Now we’re going to show you how the two namespaces (yours and the module’s one) can coexist.\
Take a look at the example →
```py
import math
def sin(x):
  if 2 * x == pi:
    return 0.99999999
  else:
    return None
pi=3.14
print(sin(pi/2))
print(math.sin(math.pi/2))
```
We’ve defined our own `pi` and `sin` here. The code produces the following output:
```
0.99999999
1.0
<<<<<<< HEAD
```
=======
``` 
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
As you can see, the entities don’t affect each other.

#### 4.1.12 Importing a module
In the second method, the import’s syntax precisely points out which module’s entity (or entities) are acceptable in the code →\
```py
from math import pi
```
<<<<<<< HEAD
The instruction consists of the following elements:
=======
The instruction consists of the following elements: 
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
- the `from` keyword;
- the **name of the module** to be (selectively) imported;
- the `import` keyword;
- the **name or list of names of the entity/entities** which are being imported into the namespace.

The instruction has this effect:
- the listed entities (and only those ones) are **imported from the indicated module**;
- the names of the imported entities **are accessible without qualification**.

Note: no other entities are imported. Moreover, you cannot import additional entities using a qualification – a line like this one:
```py
print(math.e)
```
will cause an error (e is Euler’s number: 2.71828...)\
Let’s rewrite the previous script to incorporate the new technique.

#### 4.1.13 Importing a module
Here it is →
```py
from math import sin,pi
print(sin(pi/2))
```
The output is the same as previously, as in fact we’ve used the same entities as before:
```
1.0
```
Does the code look simpler? Maybe, but the look is not the only effect of this kind of import. Let’s show you that.

#### 4.1.14 Importing a module
Analyze the code carefully →
- line 01: carry out the selective import;
- line 02: make use of the imported entities and get the expected result (1.0)
- lines 03 through 08: redefine the meaning of pi and sin – in effect, they supersede the original (imported) definitions within the code’s namespace;
- line 09: get 0.99999999, which confirms our conclusions.
```py
from math import sin,pi
print(sin(pi/2))
pi=3.14
def sin(x):
  if 2 * x == pi:
    return 0.99999999
  else:
    return None
print(Sin(pi/2))
```

#### 4.1.15 Importing a module
Here, we’ve reversed the sequence of the code’s operations →
```py
pi = 3.14
def sin(x):
  if 2 * x == pi:
    return 0.99999999
  else:
    return None
print(sin(pi/2))
from math import sin,pi
print(sin(pi/2))
```
- lines 01 through 06: define our own pi and sin;
- line 07: make use of them ( 0.99999999 appears on screen)
- line 08: carry out the import – the imported symbols supersede their previous definitions within the namespace;
- line 09: get 1.0 as a result.

Let’s do another test.

#### 4.1.16 Importing a module
In the third method, the import’s syntax is a more aggressive form of the previously presented one →
```py
from module import *
```
As you can see, the name of an entity (or the list of entities’ names) is replaced with a single asterisk (*).\
Such an instruction imports all entities from the indicated module.\
Is it convenient? Yes, it is, as it relieves you of the duty of enumerating all the names you need.\
Is it unsafe? Yes, it is – unless you know all the names provided by the module, you may not be able to avoid name conflicts. Treat this as a temporary solution, and try not to use it in regular code.

#### 4.1.17 Importing a module
If you use the import module variant and you don’t like a particular module’s name (e.g., it’s the same as one of your already defined entities, so qualification becomes troublesome) you can give it any name you like – this is called aliasing. Aliasing causes the module to be identified under a different name than the original. This may shorten the qualified names, too.\
Creating an alias is done together with importing the module, and demands the following form of the import instruction →
```py
import module as alias
```
The “module” identifies the original module’s name while the “alias” is the name you wish to use instead of the original.\
Note: `as` is a keyword.

#### 4.1.18 Importing a module
If you need to change the word math, you can introduce your own name, just like in the example →
```py
import math as M
print(M.sin(M.pi/2))
```
Note: after successful execution of an aliased import, the original module name becomes inaccessible and must not be used.

#### 4.1.19 Importing a module
In turn, when you use the from module import name variant and you need to change the entity’s name, you make an alias for the entity. This will cause the name to be replaced by the alias you choose.\
<<<<<<< HEAD
This is how it can be done →
=======
This is how it can be done → 
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
```py
from module import name as alias
```
As previously, the original (unaliased) name becomes inaccessible.\
The phrase name as alias can be repeated – use commas to separate the multiplied phrases, like this:
```py
from module import n as a, m as b, o as c
```
<<<<<<< HEAD

=======
 
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
#### 4.1.20 Importing a module
The example may look a bit weird, but it works. →
```py
from math import pi as PI, sin as sine
print(sine(PI/2))
```
Now you’re familiar with the basics of using modules. Let us show you some modules and some of their useful entities.

#### 4.2.1 Working with standard modules
Before we start going through some standard Python modules, we want to introduce the dir() function to you. It has nothing to do with the dir command you know from Windows and Unix consoles, as dir()doesn’t show the contents of a disk directory/folder, but there is no denying that it does something really similar – it is able to reveal all the names provided through a particular module. There is one condition: the module has to have been previously imported as a whole (i.e., using the import module instruction – from module is not enough).\
The function returns an alphabetically sorted list containing all entities’ names available in the module identified by a name passed to the function as an argument. Note: if the module’s name has been aliased, you must use the alias, not the original name.\
Using the function inside a regular script doesn’t make much sense, but it is still possible.
```py
dir(module)
```

#### 4.2.2 Working with standard modules
For example, you can run the following code to print the names of all entities within the math module →
```py
import math

for name in dir(math):
  print(name,end='\t')
```
<<<<<<< HEAD
Have you noticed these strange names beginning with `__` at the top of the list? We’ll tell you more about them when we talk about the issues related to writing your own modules.\
=======
Have you noticed these strange names beginning with __ at the top of the list? We’ll tell you more about them when we talk about the issues related to writing your own modules.\
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
Some of the names might bring back memories from math lessons, and you probably won’t have any problems guessing their meanings.\
The example code produces the following output:
```
__doc__     __file__    __loader__  __name__    __package__      __spec__    acos  acosh asin  asinh atanatan2   atanh ceil      copysign    cos   cosh  degrees     e     erf   erfc  exp      expm1 fabs  factorial   floor fmod  frexp fsum  gamma hypot      isfinite    isinf isnan ldexp lgamma      log   log10 log1p log2      modf  pi    pow   radians     sin   sinh  sqrt  tan   tanh      trunc
```

#### 4.2.3 Working with standard modules
Using the dir() function inside a code may not seem very useful – usually you want to know a particular module’s contents before you write and run the code.\
Fortunately, you can execute the function directly in the Python console, without needing to write and run a separate script.\
This is how it can be done →
![](423.jpg)

#### 4.2.4 Some functions from the math module
Let’s start with a quick preview of some of the functions provided by the math module. We’ve chosen them arbitrarily, but that doesn’t mean that the functions we haven’t mentioned here are any less significant. Dive into the modules’ depths yourself – we don’t have the space or the time to talk about everything in detail here.\
The first group of the math’s functions are connected with trigonometry:
- sin(x)→ the sine of x;
- cos(x)→ the cosine of x;
- tan(x)→ the tangent of x.

All these functions take one argument (an angle measurement expressed in radians) and return the appropriate result (be careful with tan() – not all arguments are accepted). Of course, there are also their inversed versions:
- asin(x)→ the arcsine of x;
- acos(x)→ the arccosine of x;
- atan(x)→ the arctangent of x.

These functions take one argument (mind the domains) and return a measure of an angle in radians.\
To effectively operate on angle measurements, the math module provides you with the following entities:\
- pi→ a constant with a value that is an approximation of π;
- radians(x)→ a function that converts x from degrees to radians;
- degrees(x)→ acting in the other direction (from radians to degrees)

The example program isn’t very sophisticated, but can you predict its results? →
```py
from math import pi,radians,degrees,sin,cos,tan
ad = 90
ar = radians(ad)
ad = degrees(ar)
print(ad==90)
print(ar==pi/2.)
print(sin(ar)/cos(ar)==tan(ar))
print(asin(sin(ar))==ar)
```
Apart from the circular functions (listed above) the math module also contains a set of their hyperbolic analogues:
- sinh(x)→ the hyperbolic sine;
- cosh(x)→ the hyperbolic cosine;
- tanh(x)→ the hyperbolic tangent;
- asinh(x)→ the hyperbolic arcsine;
- acosh(x)→ the hyperbolic arccosine;
- atanh(x)→ the hyperbolic arctangent.

#### 4.2.5 Some functions from the math module
Were you able to answer the previous question? →
```
True
True
True
True
```

#### 4.2.6 Some functions from the math module
Another group of the math’s functions is formed by functions which are connected with exponentiation:
- e→ a constant with a value that is an approximation of Euler’s number (e)
- exp(x)→ finding the value of ex;
- log(x)→ the natural logarithm of x
- log(x, b)→ the logarithm of x to base b
- log10(x)→ the decimal logarithm of x (more precise than log(x,10))
- log2(x)→ the binary logarithm of x (more precise than log(x,2))

Note: the pow() function:
- pow(x,y)→ finding the value of xy (mind the domains)

This is a built-in function, and doesn’t have to be imported.\
Can you predict the code’s output? →
```py
from math import e,exp,log

print(pow(e,1)==exp(log(e)))
print(pow(2,2)==exp(2*log(2)))
print(log(e,e)==exp(0))
```

#### 4.2.7 Some functions from the math module
<<<<<<< HEAD
This is the output of the code →
=======
This is the output of the code → 
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
```
True
True
True
```

#### 4.2.8 Some functions from the math module
The last group consists of some general-purpose functions like:
- ceil(x)→ the ceiling of x (the smallest integer greater than or equal to x)
- floor(x)→ the floor of x (the largest integer less than or equal to x)
- trunc(x)→ the value of x truncated to an integer (be careful – it’s not an equivalent either of ceil or floor)
- factorial(x)→ returns x! (x has to be an integral and not a negative)
- hypot(x,y)→ returns the length of the hypotenuse of a right-angle triangle with the leg lengths equal to x and y (the same as sqrt(pow(x,2)+pow(y,2)) but more precise)

Analyze the example program carefully →
```py
from math import ceil,floor,trunc

x=1.4
y=2.6
print(floor(x),floor(y))
print(floor(-x),floor(-y))
print(ceil(x),ceil(y))
print(ceil(-x),ceil(-y))
print(trunc(x),trunc(y))
print(trunc(-x),trunc(-y))
```
It demonstrates the fundamental differences between ceil(), floor() and trunc().\
Its output is:
```
1 2
-2 -3
2 3
-1 -2
1 2
-1 -2
```

#### 4.2.9 Is there real randomness in computers?
Another module worth mentioning is the one named random. It delivers some mechanisms allowing you to operate with pseudorandom numbers.\
Note the prefix pseudo – the numbers generated by the modules may look random in the sense that you cannot predict their subsequent values, but don’t forget that they all are calculated using very refined algorithms.\
The algorithms aren’t random – they are deterministic and predictable. Only those physical processes which run completely out of our control (like the intensity of cosmic radiation) may be used as a source of actual random data. Data produced by deterministic computers cannot be random in any way.\
A random number generator takes a value called a seed, treats it as an input value, calculates a “random” number based on it (the method depends on a chosen algorithm) and produces a new seed value.\
The length of a cycle in which all seed values are unique may be very long, but it isn’t infinite – sooner or later the seed values will start repeating, and the generating values will repeat, too. This is normal. It’s a feature, not a mistake, or a bug.\
The initial seed value, set during the program start, determines the order in which the generated values will appear.\
The random factor of the process may be augmented by setting the seed with a number taken from the current time – this may ensure that each program launch will start from a different seed value (ergo, it will use different random numbers).\
Fortunately, such an initialization is done by Python during module import.

#### 4.2.10 Some functions from the random module
The most general function named random() (not to be confused with the module’s name) produces a float number x coming from the range (0.0, 1.0) –in other words: (0.0 <= x < 1.0).\
The example program will produce five pseudorandom values – as their values are determined by the current (rather unpredictable) seed value, you can’t guess them.
```py
from random import random
for i in range(5):
  print(random())
```

#### 4.2.11 Some functions from the random module
The `seed()` function is able to directly set the generator’s seed. We’ll show you two of its variants:
- seed() – sets the seed with the current time;
- seed(i) – sets the seed with the integer value i.

We’ve modified the previous program – in effect, we’ve removed any trace of randomness from the code →
```py
from random import random, seed
seed(0)
for i in range(5):
  print(random())
```
Due to the fact that the seed is always set with the same value, the sequence of generated values always looks the same.
This is what we’ve got:
```
0.844421851525
0.75795440294
0.420571580831
0.258916750293
0.511274721369
```
And you?\
Note: your values may be slightly different than ours if your system uses more precise or less precise floating-point arithmetic, but the difference will be seen quite far from the decimal point.

#### 4.2.12 Some functions from the random module
If you want integer random values, one of the following functions would fit better:
- randrange(end)
- randrange(beg,end)
- randrange(beg, end, step)
- randint(left, right)

The first three invocations will generate an integer taken (pseudorandomly) from the range (respectively):
- range(end)
- range(beg,end)
- range(beg,end,step)

Note the implicit right-sided exclusion!\
The last function is an equivalent of randrange(left, right+1) – it generates the integer value i, which falls in the range [left,right] (no exclusion on the right side).\
The example program will consequently output a line consisting of three zeros and either a zero or one at the fourth place →
```py
from random import randrange, randint

print(randrange(1),end=' ')
print(randrange(0,1),end=' ')
print(randrange(0,1,1),end=' ')
print(randint(0,0))
```

#### 4.2.13 Some functions from the random module
The previous functions have one important disadvantage – they may produce repeating values even if the number of subsequent invocations is not greater than the width of the specified range. The following program very likely outputs a set of numbers in which some elements are not unique.\
This is what we got in one of the launches:
```
9,4,5,4,5,8,9,4,8,4,
```

As you can see, this is not a good tool for generating numbers in a lottery. Fortunately, there is a better solution than writing your own code to check the uniqueness of the “drawn” numbers.
```py
from random import randint

for i in range(10):
  print(randint(1,10),end=',')
```

#### 4.2.14 Some functions from the random module
It’s a function named in a very suggestive way – choice:
- choice(sequence)
- sample(sequence, elements_to_chose=1)

The first variant chooses a “random” element from the input sequence and returns it.\
The second one builds a list (a sample) consisting of the elements_to_chose element (which defaults to 1) “drawn” from the input sequence.\
In other words, the function chooses some of the input elements, returning a list with the choice. The elements in the sample are placed in random order. Note: the elements_to_chose must not be greater than the length of the input sequence.\
Again, the output of the example program is not predictable →
```py
from random import choice,sample

lst=[1,2,3,4,5,6,7,8,9,10]
print(choice(lst))
print(sample(lst,5))
print(sample(lst,10))
```
Our results looked like this:
```
4
[3, 1, 8, 9, 10]
[10, 8, 5, 1, 6, 4, 3, 9, 7, 2]
```

#### 4.2.15 How to know where you are
Sometimes, it may be necessary to find out information unrelated to Python. For example, you may need to know the location of your program within the greater environment of the computer.\
Imagine your program’s environment as a pyramid consisting of a number of layers or platforms →
- your (running) code is located at the top of it;
- Python (more precisely – its runtime environment) lies directly below it;
- the next layer of the pyramid is filled with the OS (operating system) – Python’s environment provides some of its functionalities using the operating system’s services; Python, although very powerful, isn’t omnipotent – it’s forced to use many helpers if it’s going to process files or communicate with physical devices;
- the bottom-most layer is hardware – the processor (or processors), network interfaces, human interface devices (mice, keyboards, etc.) and all other machinery needed to make the computer run; the OS knows how to drive it, and uses lots of tricks to conduct all parts in a consistent rhythm.

This means than some of your (or rather your program’s) actions have to travel a long way to be successfully performed – imagine that:
- your code wants to create a file, so it invokes one of Python’s functions;
- Python accepts the order, rearranges it to meet local OS requirements (it’s like putting the stamp “approved” on your request) and sends it down (this may remind you of a chain of command)
- the OS checks if the request is reasonable and valid (e.g., whether the file name conforms to some syntax rules) and tries to create the file; such an operation, seemingly very simple, isn’t atomic – it consists of many minor steps taken by . . .
- . . . the hardware, which is responsible for activating storage devices (hard disk, solid state devices, etc.) to satisfy the OS’s needs.

Usually, you’re not aware of all that fuss – you want the file to be created and that’s that.\
But sometimes you want to know more – for example, the name of the OS which hosts Python, and some characteristics describing the hardware that hosts the OS.\
There is a module providing some means to allow you to know where you are and what components work for you. The module is named platform. We’ll show you some of the functions it provides to you.

#### 4.2.16 Some functions from the platform module
There is a function that can show you all the underlying layers in one glance, named platform. It just returns a string describing the environment; thus, its output is rather addressed to humans than to automated processing (you’ll see it soon).\
This is how you can invoke it:
```py
from platform import platform

print(platform())
print(platform(1))
print(platform(0,1))
```
- platform(aliased=False, terse=False)
- aliased→ when set to True (or any non-zero value) it may cause the function to present the alternative underlying layer names instead of the common ones;
- terse→ when set to True (or any non-zero value) it may convince the function to present a briefer form of the result (if possible)

We ran our sample program using three different platforms – this is what we got:

- Intel x86 + Windows ® Vista (32 bit)
Windows-Vista-6.0.6002-SP2
Windows-Vista-6.0.6002-SP2
Windows-Vista
- Intel x86 + Gentoo Linux (64 bit)
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-gentoo-2.3
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-gentoo-2.3
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-glibc2.3.4
- Raspberry PI2 + Raspbian Linux (32 bit)
Linux-4.4.0-1-rpi2-armv7l-with-debian-9.0
Linux-4.4.0-1-rpi2-armv7l-with-debian-9.0
Linux-4.4.0-1-rpi2-armv7l-with-glibc2.9

#### 4.2.17 Some functions from the platform module
Sometimes, you may just want to know the generic name of the processor which runs your OS together with Python and your code – a function named machine() will tell you that. As previously, the function returns a string.\
Again, we ran the sample program on three different platforms:
-Intel x86 + Windows ® Vista (32 bit)
```
x86
```
-Intel x86 + Gentoo Linux (64 bit)
```
x86_64
```
-Raspberry PI2 + Raspbian Linux (32 bit)
```
armv7l
```
```py
from platform import machine

print(machine())
```

#### 4.2.18 Some functions from the platform module
The processor() function returns a string filled with the real processor name (if possible)\
Again, we ran the sample program on three different platforms:
- Intel x86 + Windows ® Vista (32 bit)
```
x86
```
- Intel x86 + Gentoo Linux (64 bit)
```
Intel(R) Core(TM) i3-2330M CPU @ 2.20GHz
```
- Raspberry PI2 + Raspbian Linux (32 bit)
```
armv7l
```
```py
from platform import processor

print(processor())
```

#### 4.2.19 Some functions from the platform module
A function named system() returns the generic OS name as a string →\
Our example platforms presented themselves like this:
Intel x86 + Windows ® Vista (32 bit)
```
Windows
```
Intel x86 + Gentoo Linux (64 bit)
```
Linux
```
Raspberry PI2 + Raspbian Linux (32 bit)
```
Linux
```
```py
from platform import system
print(system())
```

#### 4.2.20 Some functions from the platform module
The OS version is provided as a string by the version() function →\
Intel x86 + Windows ® Vista (32 bit)
```
6.0.6002
```
Intel x86 + Gentoo Linux (64 bit)
```
#1 SMP PREEMPT Fri Jul 21 22:44:37 CEST 2017
```
Raspberry PI2 + Raspbian Linux (32 bit)
```
#1 SMP Debian 4.4.6-1+rpi14 (2016-05-05)
```
```py
from platform import version
print(version())
```

#### 4.2.21 Some functions from the platform module
If you need to know what version of Python is running your code, you can check it using a number of dedicated functions – here are two of them →
- python_implementation()→ returns a string denoting the Python implementation (expect 'CPython' here, unless you decide to use any non-canonical Python branch)
- python_version_tuple()→ returns a three-element tuple filled with:
  - the major part of Python’s version;
  - the minor part;
  - the patch level number.

Our example program produced the following output:
```
CPython
3
4
5
```

It’s very likely that your version of Python will be different.
```py
from platform import python_implementation,python_version_tuple

print(python_implementation())
for atr in python_version_tuple():
  print(atr)
```

#### 4.2.22 Some functions from Python modules
We have only covered the basics of Python modules here. Python’s modules make up their own universe, in which Python itself is only a galaxy, and we would venture to say that exploring the depths of these modules can take significantly more time than getting acquainted with “pure” Python.\
Moreover, the Python community all over the world creates and maintains hundreds of additional modules used in very niche applications like genetics, psychology, or even astrology. These modules aren’t (and won’t be) distributed along with Python, or through official channels, which makes the Python universe broader – almost infinite.\
Don’t worry – you won’t need all these modules. Many of them are very specific. All you need to do is find the modules you want, and teach yourself how to use them. It’s easy.\
Now let’s take a look at something else. We’re going to show you how to write your own module.

#### 4.3.1 Modules and packages
Writing your own modules doesn’t differ much from writing ordinary scripts. There are some specific aspects you must be aware of, but it definitely isn’t rocket science. You’ll see this soon enough.\
Let’s summarize some important issues:
- a module is a kind of container filled with functions – you can pack as many functions as you want into one module and distribute it across the world;
- of course, it’s generally a good idea not to mix functions with different application areas within one module (just like in a library – nobody expects scientific works to be put among comic books), so group your functions carefully and name the module containing them in a clear and intuitive way (e.g., don’t give the name arcade_games to a module containing functions intended to partition and format hard disks)
- making many modules may cause a little mess – sooner or later you’ll want to group your modules exactly in the same way as you’ve previously grouped functions – is there a more general container than a module?
- yes, there is – it’s a package; in the world of modules, a package plays a similar role to a folder/directory in the world of files.

#### 4.3.2 Your first module
Let’s start from scratch, just like this →\
You need two files to repeat these experiments. One of them will be the module itself. It’s empty now. Don’t worry, you’re going to fill it with actual code.\
We’ve named the file module.py. Not very creative, but simple and clear.
<<<<<<< HEAD

=======
 
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
#### 4.3.3 Your first module
The second file contains the code using the new module. Its name is main.py\
Its content is very brief so far →
```py
# main.py
import module
```
Note: both files have to be located in the same folder. We strongly encourage you to create an empty, new folder for both files. Some things will be easier then.\
Run the main.py file. What do you see?\
You should see nothing. This means that Python has successfully imported the contents of the module.py file. It doesn’t matter that the module is empty for now. The very first step has been done, but before you take the next step, we want you to take a look into the folder in which both files exist.\
Do you notice something interesting?\
A new subfolder has appeared – can you see it? Its name is `__pycache__`. Take a look inside. What do you see?\
There is a file named (more or less):
```
module.cpython-xy.pyc
```
where x and y are digits derived from your version of Python (e.g., they will be 3 and 4 if you use Python 3.4).\
The name of the file is the same as your module’s name (module here). The part after the first dot says which Python implementation has created the file (CPython here) and its version number. The last part (pyc) comes from the words “Python” and “compiled”.\
You can look inside the file – the content is completely unreadable to humans. It has to be like that, as the file is intended for Python’s use only.\
When Python imports a module for the first time, it translates its contents into a somewhat compiled shape. The file doesn’t contain machine code – it’s internal Python semi-compiled code, ready to be executed by Python’s interpreter. As such a file doesn’t require lots of the checks needed for a pure source file, the execution starts faster, and runs faster, too.\
Thanks to that, every subsequent import will go quicker than interpreting the source text from scratch.\
Python is able to check if the module’s source file has been modified (in this case, the pyc file will be rebuilt) or not (when the pyc file may be run at once). As this process is fully automatic and transparent, you don’t have to keep it in mind.\

#### 4.3.4 Your first module
Now we’ve put a little something into the module file →\
```py
# module.py

print("I like to be a module")
```
Can you notice any differences between a module and an ordinary script? There are none so far.\
It’s possible to run this file like any other script.\
Try it for yourself.\
What happens? You should see the following line inside your console:\
```
I like to be a module

#### 4.3.5 Your first module
Let’s go back to the main.py file →\
```py
# main.py

import module
```
Run it. What do you see?\
```
I like to be a module
```
What does it actually mean? When a module is imported, its content is implicitly executed by Python. It gives the module the chance to initialize some of its internal aspects (e.g., it may assign some variables with useful values). Note: the initialization takes place only once, when the first import occurs, so the assignments done by the module aren’t repeated unnecessarily. Imagine the following context:
- there is a module named mod1;
- there is a module named mod2 which contains the import mod1 instruction;
- there is a main file containing the import mod1 and import mod2 instructions.

At first glance, you may think that mod1 will be imported twice – fortunately, only the first import occurs. Python remembers the imported modules and silently omits all subsequent imports.

#### 4.3.6 Your first module
Python can do much more. It also creates a variable called `__name__`\
Moreover, each source file uses its own, separate version of the variable – it isn’t shared between modules.\
We’ll show you how to use it.
Modify the module a bit →
```py
# module.py

print("I like to be a module")
print(__name__)
```
Now run the module.py file. You should see the following lines:
```
I like to be a module
__main__
```
Now run the main.py file. And? Do you see the same as us?
```
I like to be a module
module
```
We can say that:
- when you run a file directly, its `__name__` variable is set to `__main__`;
- when a file is imported as a module, its `__name__` variable is set to the file’s name (excluding .py)

#### 4.3.7 Your first module
This is how you can make use of the `__main__` variable in order to detect the context in which your code has been activated →
```py
# module.py
if __name__ == '__main__':
  print("I prefr to be a module")
else:
  print("I like to be a module")
```
There’s a cleverer way to utilize the variable, however. If you write a module filled with a number of complex functions, you can use it to place a series of tests to check if the functions work properly.\
Each time you modify any of these functions, you can simply run the module to make sure that your amendments didn’t spoil the code. These tests will be omitted when the code is imported as a module.

#### 4.3.8 Your first module
This module will contain two simple functions, and if you want to know how many times the functions have been invoked, you need a counter initialized to zero when the module is being imported.\
You can do it this way →
```py
# module.py

counter = 0

if __name__ == "__main__":
  print("I prefer to be a module")
else:
  print("I like to be a module")
```

#### 4.3.9 Your first module
Introducing such a variable is absolutely correct, but may cause important side effects that you must be aware of.\
Take a look at the modified main.py file →
```py
# main.py
import module
print(module.counter)
```
As you can see, the main file tries to access the module’s counter variable. Is this legal? Yes, it is. It is usable? It may be very usable. Is it safe? That depends – if you trust your module’s users, there’s no problem; however, you may not want the rest of the world to see your personal/private variable.\
Unlike many others programming languages, Python has no means of allowing you to hide such variables from the eyes of the module’s users. You can only inform your users that this is your variable, that they may read it, but that they should not modify it under any circumstances.\
<<<<<<< HEAD
This is done by preceding the variable’s name with `_` or `__`, but remember, it’s only a convention. Your module’s users may obey it or they may not.\
=======
This is done by preceding the variable’s name with _ or __, but remember, it’s only a convention. Your module’s users may obey it or they may not.\
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
Of course, we’ll follow the convention. Now let’s put two functions into the module – they’ll evaluate the sum and product of the numbers collected in a list.\
In addition, let’s add some ornaments there and remove any superfluous remnants.

#### 4.3.10 Your first module
The module is ready →
```py
#!/usr/bin/env python3
""" module.py - an example of Python module """
__counter = 0
def sum(list):
  global __counter
  __counter += 1
  sum = 0
  for el in list:
    sum += el
  return sum

def prod(list):
  global __counter
  __counter += 1
  prod = 1
  for el in list:
    prod *= el
  return prod

if __name__ == "__main__":
  print("I prefer to be a module, but I can do some tests for you")
  l = [i + 1 for i in range(5)]
  print(sum(l)==15)
  print(prod(l) == 120)
```
A few elements need some explanation, we think:
- the line starting with `#!` has many names – it may be called shabang, shebang, hashbang, poundbang or even hashpling (don’t ask us why). The name itself means nothing here – its role is more important. From Python’s point of view, it’s just a comment as it starts with #. For Unix and Unix-like OSs (including MacOS) such a line instructs the OS how to execute the contents of the file (in other words, what program needs to be launched to interpret the text). In some environments (especially those connected with web servers) the absence of that line will cause trouble;
- a string (maybe a multiline) placed before any module instructions (including imports) is called the doc-string, and should briefly explain the purpose and contents of the module;
- the functions defined inside the module (`suml()` and prodl()) are available for import;
- we’ve used the `__name__` variable to detect when the file is run stand-alone, and seized this opportunity to perform some simple tests.

#### 4.3.11 Your first module
Now it’s possible to use the new module – this is one way →
```py
from module import suml,prodl

zeroes = [0 for i in range(5)]
ones = [1 for i in range(5)]
print(suml(zeroes))
print(prodl(ones))
```

#### 4.3.12 Your first module
It’s time to make this example more complicated – we’ve assumed here that the main Python file is located in the same folder/directory as the module to be imported.\
Let’s give up this assumption and conduct the following thought experiment →
- we are using Windows ® OS (this assumption is important, as the file name’s shape depends on it)
- the main Python script lies in C:\Users\user\py\progs and is named main.py
- the module to import is located in C:\Users\user\py\modules

How to deal with it? To answer this question, we have to talk about how Python searches for modules. There’s a special variable (actually a list) storing all locations (folders/directories) that are searched in order to find a module which has been requested by the import instruction.\
Python browses these folders in the order in which they are listed in the list – if the module cannot be found in any of these directories, the import fails.\
Otherwise, the first folder containing a module with the desired name will be taken into consideration (if any of the remaining folders contains a module of that name, it will be ignored).\
The variable is named path, and it’s accessible through the module named sys. This is how you can check its regular value →\
![](4312.png)\
We’ve launched the code inside the C:\User\user folder, and we’ve got:
```
C:\Users\user
C:\Users\user\AppData\Local\Programs\Python\Python36-32\python36.zip
C:\Users\user\AppData\Local\Programs\Python\Python36-32\DLLs
C:\Users\user\AppData\Local\Programs\Python\Python36-32\lib
C:\Users\user\AppData\Local\Programs\Python\Python36-32
C:\Users\user\AppData\Local\Programs\Python\Python36-32\lib\site-packages
```
Note: the folder in which the execution starts is listed in the first path’s element.\
Note once again: there is a zip file listed as one of the path’s elements – it’s not an error. Python is able to treat zip files as ordinary folders – this can save lots of storage.\
Can you figure out how we can solve the problem?\
You can solve it by adding a folder containing the module to the path variable (it’s fully modifiable).

#### 4.3.13 Your first module
One of several possible solutions looks like this →
```py
# main.py
from sys import path

path.append('..\\modules')

import module

zeroes = [0 for i in range(5)]
ones = [1 for i in range(5)]
print(module.suml(zeroes))
print(module.prodl(ones))
```
Note:
- we’ve doubled the \ inside folder name – do you know why? (*)
- we’ve used the relative name of the folder – this will work if you start the main.py file directly from its home folder, and won’t work if the current directory doesn’t fit the relative path; you can always use an absolute path, like this:
```py
path.append('C:\\Users\\user\\py\\modules')
```
- we’ve used the append() method – in effect, the new path will occupy the last element in the path list; if you don’t like the idea, you can use insert() instead.\
(*)because a backslash is used to escape other characters – if you want to get just a backslash, you have to escape it.

#### 4.3.14 Your first package
Imagine that in the not-so-distant future you and your associates write a large number of Python functions.\
Your team decides to group the functions in separate modules, and this is the final result of the ordering →
```py
# alpha.py
#!/usr/bin/env python3

"""module: alpha"""

def FunA():
  return "Alpha"

if __name__ == "__main__":
  print("I prefer to be a module")
```
```py
# beta.py
def FunB(): ...
```
```py
# iota.py
def FunI(): ...
```
```py
# sigma.py
def FunS(): ...
```
```py
# tau.py
def FunT(): ...
```
```py
# psi.py
def FunP(): ...
```
```py
# omegaj.py
def FunO(): ...
```
Note: we’ve presented the whole content for the omega module only – assume that all the modules look similar (they contain one function named FunX, where X is the first letter of the module’s name).

#### 4.3.15 Your first package
Suddenly, somebody notices that these modules form their own hierarchy, so putting them all in a flat structure won’t be a good idea.\
After some discussion, the team comes to the conclusion that the modules have to be grouped. All participants agree that the following tree structure perfectly reflects the mutual relationships between the modules →\
![](4315.png)\
Let’s review this from the bottom up:
- the ugly group contains two modules: psi and omega;
- the best group contains two modules: sigma and tau;
- the good group contains two modules (alpha and beta) and one subgroup (best)
- the extra group contains two subgroups (good and bad) and one module (iota)

Does it look bad? Not at all – analyze the structure carefully. It resembles something, doesn’t it?\
It looks like a directory structure.

#### 4.3.16 Your first package
This is how the tree currently looks →
Such a structure is almost a package (in the Python sense). It lacks the fine detail to be both functional and operative. We’ll complete it in a moment.\
If you assume that extra is the name of a newly created package (think of it as the package’s root), it will impose a naming rule which allows you to clearly name every entity from the tree.\
For example:
- the location of a function named FunT() from the tau package may be described as:
```py
extra.good.best.tau.FunT()
```
- a function marked as:
```py
extra.ugly.psi.FunP()
```
comes from the psi module being stored in the ugly subpackage of the extra package.

#### 4.3.17 Your first package
There are two questions to answer:
- how do you transform such a tree (actually, a subtree) into a real Python package (in other words, how do you convince Python that such a tree is not just a bunch of junk files, but a set of modules)?
- where do you put the subtree to make it accessible to Python?

The first question has a surprising answer. Packages, like modules, may require initialization.\
The initialization of a module is done by an unbound code (not a part of any function) located inside the module’s file. As a package is not a file, this technique is useless for initializing packages.\
You need to use a different trick instead – Python expects that there is a file with a very unique name inside the package’s folder:\
```
__init__.py
```
The content of the file is executed when any of the package’s modules is imported. If you don’t want any special initializations, you can leave the file empty, but you mustn’t omit it.

#### 4.3.18 Your first package
<<<<<<< HEAD
The presence of the `__init.py__` file finally makes up the package →
=======
The presence of the __init.py__ file finally makes up the package →
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
```
extra
├── __init__.py
├── good
│   ├── alpha.py
│   ├── best
│   │   ├── sigma.py
│   │   └── tau.py
│   └── beta.py
├── iota.py
└── ugly
    ├── omega.py
    └── psi.py

3 directories, 8 files
```
<<<<<<< HEAD
Note: it’s not only the “root” folder that can contain the `__init__.py` file – you can put it inside any of its subfolders (subpackages) too. It may be useful if some of the subpackages require individual treatment and special kinds of initialization.\
=======
Note: it’s not only the “root” folder that can contain the __init__.py file – you can put it inside any of its subfolders (subpackages) too. It may be useful if some of the subpackages require individual treatment and special kinds of initialization.\
>>>>>>> 98475b441ffe097eb84eb3448dc4c6917328f4b4
Now it’s time to answer the second question – the answer is simple: anywhere. You only have to ensure that Python is aware of the package’s location. You already know how to do that.\
You’re ready to make use of your first package.

#### 4.3.19 Your first package
Let’s assume that the working environment looks as follows →\
![](4319.png)\
We’ve prepared a zip file containing all the files from the packages branch. You can download it and use it for your own experiments, but remember to unpack it in the folder presented in the scheme, otherwise, it won’t be accessible to the code from the main file.

You’ll be continuing your experiments using the main2.py file.


#### 4.3.20 Your first package
We are going to access the FunI() function from the iota module from the top of the extra package. It forces us to use qualified package names (associate this with naming folders and subfolders – the conventions are very similar).\
This is how to do it →\
```py
# main2.py
from sys import path
path.append('..\\packages')
import extra.iota
print(extra.iota.FunI())
```
Note:
- we’ve modified the path variable to make it accessible to Python;
- the import doesn’t point directly to the module, but specifies the fully qualified path from the top of the package;

replacing import extra.iota with import iota will cause an error.

#### 4.3.21 Your first package
The following variant is valid too →\
```py
# main2.py
from sys import path
path.append('..\\packages')
from extra.iota import FunI
print(FunI())
```
Note the qualified name of the `iota` module.

#### 4.3.22 Your first package
Now let’s reach all the way to the bottom of the tree – this is how to get access to the sigma and tau modules →
```py
# main2.py
from sys import path
path.append('..\\packages')
import extra.good.best.sigma
from extra.good.best.tau import FunT
print(extra.good.best.sigma.FunS())
print(FunT())
```

#### 4.3.23 Your first package
You can make your life easier by using aliasing →
```py
# main2.py
from sys import path
path.append('..\\packages')
import extra.good.best.sigma as sig
import extra.good.alpha as alp
print(sig.FunS())
print(alp.FunA())
```

#### 4.3.24 Your first package
Let’s assume that we’ve zipped the whole subdirectory, starting from the extra folder (including it), and let’s get a file named extrapack.zip. Next, we put the file inside the packages folder.\
Now we are able to use the zip file in a role of packages →
```py
# main2.py
from sys import path
path.append('..\\packages\\extrapack.zip')
import extra.good.best.sigma as sig
import extra.good.alpha as alp
from extra.iota import FunI
from extra.good.beta import FunB
print(sig.Funs())
print(alp.FunA())
print(FunI())
print(FunB())
```
If you want to conduct your own experiments with the package we’ve created, you can download it here. We encourage you to do so.\
Now you can create modules and combine them into packages. It’s time to start a completely different discussion – about errors, failures and crashes.
