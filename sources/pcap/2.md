# Certified Associate of Python Programming, Module 2
#### 2.1.1 Questions and answers
A programmer writes a program and the program asks questions.
A computer executes the program and provides the answers. The program must be able to react according to the received answers.
Fortunately, computers know only two kinds of answers: _yes, this is true_ or _no, this is false_.\
You will never get a response like Let me think....I don’t know or Probably yes, but I don’t know for sure.
To ask questions, Python uses a set of very special operators.
Let’s go through them one after another, illustrating their effects on some simple examples.

#### 2.1.2 Questions and answers
Question: are two values equal?
To ask this question, you use the `==` (equal equal) operator.
Don’t forget this important distinction:
1. `=` is an assignment operator (`a = b` assigns `a` with the value of `b`)
2. `==` is the question are these values equal? (`a == b` compares `a` and `b`)

It is a **binary operator with left-sided binding**. It needs two arguments and checks if they are equal.
Now let’s ask a few questions. Try to guess the answers.

#### 2.1.3 Equality
```py
2 == 2
```
This question is easy. Of course, 2 is equal to 2.
Python will answer `True` (remember this pair of predefined literals, `True` and `False` – they’re Python keywords, too).

#### 2.1.4 Equality
```py
2 == 2.
```
This question is not as easy as the first one.
Luckily, Python is able to convert the integer value into its real equivalent, and consequently, the answer is `True`.

#### 2.1.5 Equality
```py
1 == 2
```
This is easy, too. The answer will be (or rather, always is) `False`.

#### 2.1.6 Equality
```py
var == 0
```
Note that we cannot find the answer if we do not know what value is currently stored in the variable `var`.
If the variable has been changed many times during the execution of your program, or its initial value is entered from the console, the answer to this question can be given only by Python and only at runtime.

#### 2.1.7 Equality
Imagine a programmer who suffers from insomnia, and has to count black and white sheep separately as long as there are exactly twice as many black sheep as white ones.
The question will be as follows →
```py
BlackSheep == 2 * WhiteSheep
```
Due to the low priority of the `==` operator, the question shall be treated as equivalent to this one:
```py
BlackSheep == (2 * WhiteSheep)
```

#### 2.1.8 Greater than
You can also ask this question using the `>` (greater than) operator.\
If you want to know if there are more black sheep than white ones, you can write it as follows →
```py
BlackSheep > WhiteSheep
```
`True` confirms it; `False` denies it.

#### 2.1.9 Greater than or equal to
The greater than operator has another special, non-strict variant, but it’s denoted differently than in classical arithmetic notation: `>=` (greater than or equal to).
There are two subsequent signs, not one.
Both of these operators (strict and non-strict), as well as the two others discussed in the next section, are binary operators with left-sided binding, and their priority is greater than that shown by `==` and `!=`.
If we want to find out whether or not we have to wear a warm hat, we ask the following question →
```py
CentigradeOutside >= 0.0
```

#### 2.1.10 Less than or equal to
As you’ve probably already guessed, the operators used in this case are: the `<` (less than) operator and its non-strict sibling `<=` (less than or equal to). Look at this simple example →
```py
CurrentVelocityMph < 85
CurrentVelocityMph <= 85
```
We’re going to check if there’s a risk of being fined by the highway police (the first question is strict, the second isn’t).

#### 2.1.11 Making use of the answers
What can you do with the answer you get from the computer?
There are at least two possibilities: first, you can memorize it (store it in a variable) and make use of it later. How do you do that? Well, you would use an arbitrary variable like this →
```py
CurrentVelocityMph < 85
CurrentVelocityMph <= 85
```
The content of the variable will tell you the answer to the question asked.

#### 2.1.12 Priorities updated
The second possibility is more convenient and far more common: you can use the answer you get to make a decision about the future of the program.
You need a special instruction for this purpose, and we’ll discuss it very soon.
Now we need to update our priority table, and put all the new operators into it. It now looks as follows →

--- | ---
`+` `-` | Unary
`**`    | 
`*` `/` `%` 
`+` `-` | binary
`<` `<=` `=` `>` `>=`
`==` `!=`

#### 2.1.13 Conditions and conditional execution
You already know how to ask Python questions, but you still don’t know how to make reasonable use of the answers. You have to have a mechanism which will allow you to do something if a condition is met, and not do it if it isn’t.
It’s just like in real life: you do certain things or you don’t when a specific condition is met or not, e.g., you go for a walk if the weather is good, or stay home if it’s wet and cold.\
To make such decisions, Python offers a special instruction. Due to its nature and its application, it’s called a **conditional instruction** (or **conditional statement**).
There are several variants of it. We’ll start with the simplest, increasing the difficulty slowly.
The first form of a conditional statement, which you can see to the side, is written very informally but figuratively →
```py
if true_or_not:
  do_this_if_true
```
This conditional statement consists of the following, strictly necessary, elements in this and this order only:
- the `if` keyword
- one or more white spaces;
- an expression (a question or an answer) whose value will be interpreted solely in terms of True (when its value is non-zero) and False (when it is equal to zero);
- a colon followed by a newline;
- an intended instruction or instructions (at least one instruction is absolutely required); the indentation may be achieved in two ways – by inserting a particular number of spaces, or by using the tab character (the latter way is recommended); note: if there is more than one instruction in the indented part, the indentation should be the same in all lines; it may look the same if you use tabs mixed with spaces, but it’s important to make all indentations exactly the same)

How does that statement work?
- If the `true_or_not` expression represents the truth (i.e., its value is not equal to zero), the indented statement(s) will be executed;
- if the `true_or_not` expression does not represent the truth (i.e., its value is equal to zero), the indented statement(s) will be omitted (ignored), and the next executed instruction will be the one after the original indentation level.

#### 2.1.14 Conditions and conditional execution
In real life, we often express a desire:
> if the weather is good, we’ll go for a walk
> then, we’ll have lunch

As you can see, having lunch is not a conditional activity and doesn’t depend on the weather.
Knowing what conditions influence our behavior, and assuming that we have the parameterless functions `GoForAWalk()` and `HaveLunch()`, we can write the following snippet →
```py
if TheWeatherIsGood:
  GoForAWalk()
HaveLunch()
```

#### 2.1.15 Conditions and conditional execution
If a particular sleepless Python developer falls asleep when he or she counts 120 sheep, and the sleep-inducing procedure may be implemented as a special function named SleepAndDream(), the whole code takes the following shape →
```py
if SheepCounter >= 120:
  SleepAndDream()
```
You can read it as: _if SheepCounter is greater than or equal to 120, then fall asleep and dream_.

#### 2.1.16 Conditions and conditional execution
We’ve said that conditionally executed statements have to be indented. This creates a very legible structure, clearly demonstrating all possible execution paths in the code.
Take a look at the following code →
```py
if SheepCounter >= 120:
  MakeABed()
  TakeAShower()
  SleepAndDream()
FeedTheSheepdogs()
```
As you can see, making a bed, taking a shower and falling asleep are all executed conditionally – when `SheepCounter` reaches the desired limit.
Feeding the sheepdogs, however, is always done.
Now we’re going to discuss another variant of the conditional statement, which also allows you to perform an additional action when the condition is not met.

#### 2.1.17 More conditional execution
We started out with a simple phrase which read: _If the weather is good, we will go for a walk_.
Note – there is not a word about what will happen if it rains. We only know that we won’t go outdoors, but what we could do instead is not known. We may want to plan something in case of bad weather, too.
We can say, for example: If the weather is good, we will go for a walk, otherwise we will go to a theater.
Now we know what we’ll do if the conditions are met, and we know what we’ll do if not everything goes our way. In other words, we have a “Plan B”.\
Python allows us to express such alternative plans. This is done with a second, slightly more complex form of the conditional statement – here it is →
```py
if true_or_false_condition:
  perform_if_condition_true
else:
  perform_if_condition_false
```
Thus, there is a new word: `else` – this is a keyword.
The part of the code which begins with `else` says what to do if the condition specified for the `if` is not met (note the colon after the word).\
The if-else execution goes as follows:
- if the condition evaluates to `True` (its value is not equal to zero), the `perform_if_condition_true` statement is executed, and the conditional statement comes to an end;
- if the condition evaluates to `False` (it is equal to zero), the `perform_if_condition_false` statement is executed, and the conditional statement comes to an end.

#### 2.1.18 More conditional execution
By using this form of conditional statement, we can describe our plans as follows →
```py
if TheWeatherIsGood:
  GoForAWalk()
else:
  GoToATheatre()
HaveLunch()
```

#### 2.1.19 More conditional execution
Everything we’ve said about indentation works in the same manner inside the `else` branch.
This how it looks →
```py
if TheWeatherIsGood:
  GoForAWalk()
  HaveFun()
else:
  GoToATheatre()
  EnjoyTheMovie()
HaveLunch()
```

#### 2.1.20 More conditional execution
Now let’s discuss two special cases of the conditional statement.\
First, consider the case where the instruction placed after the `if` is another `if`.\
Read what we have planned for this Sunday. If the weather is fine, we’ll go for a walk. If we find a nice restaurant, we’ll have lunch there. Otherwise, we’ll eat a sandwich. If the weather is poor, we’ll go to the theater. If there are no tickets, we’ll go shopping in the nearest mall.\
Let’s write the same in Python. Consider carefully the code here →
```py
if TheWeatherIsGood:
  if NiceRestaurantFound:
    HaveLunch()
  else:
    EatASandwich()
else:
  if TicketsAvailable:
    GoToATheatre()
  else:
    GoShopping()
```
Here are two important points:
- this use of the `if` statement is known as nesting; remember that every else refers to the `if` which lies at the same indentation level; you need to know this to determine how the `if`s and `else`s pair up;
- consider how the indentation improves readability, and makes the code easier to understand and trace.

#### 2.1.21 More conditional execution
The second special case introduces another new Python keyword: `elif`. As you probably suspect, it’s a shorter form of `else if`.
`elif` is used to check more than just one condition, and to stop when the first statement which is true is found.\
Our next example resembles nesting, but the similarities are very slight. Again, we’ll change our plans and express them as follows: If the weather is fine, we’ll go for a walk, otherwise if we get tickets, we’ll go to the theater, otherwise if there are free tables at the restaurant, we’ll go for lunch; if all else fails, we’ll return home and play chess.\
Have you noticed how many times we’ve used the word “otherwise”? This is the stage where the elif keyword plays its role.\
Let’s write the same scenario using Python →
```py
if TheWeatherIsGood:
  GoForAWalk()
elif TicketsAvailable:
  GoToATheatre()
elif TableAvailable:
  GoForLunch()
else:
  PlayChessAtHome()
```
The way to assemble subsequent `if`-`elif`-`else` statements is sometimes called a **cascade**.
Notice again how the indentation improves the readability of the code.\
Some additional attention has to be paid in this case:
- you mustn’t use `else` without a preceding `if`;
- `else` is always the last branch of the cascade, regardless of whether you’ve used `elif` or not;
- `else` is an optional part of the cascade, and may be omitted;
- if there is an `else` branch in the cascade, only one of all the branches is executed;
- if there is no `else` branch, it’s possible than none of the available branches is executed.

This may sound a little puzzling, but hopefully some simple examples will help shed more light.

#### 2.1.22 Some simple examples
Now we’re going to show you some simple yet complete programs. We won’t explain them in detail, because we consider the comments inside the code to be sufficient guides.
All the programs solve the same problem – they find the largest of several numbers and print it out. We’ll start with the simplest case – how to identify the larger of two numbers →
```py
# read two numbers
number1 = int(input("Enter first number: "))
number2 = int(input("Enter second number: "))

# choose the larger number
if number1 > number2:
  max = number1
else:
  max = number2

# print the result
print("The large number is ", max)
```
This snippet should be clear – it reads two integer values, compares them, and finds which is the larger.
Now we’re going to show you one intriguing fact.

#### 2.1.23 Some simple examples
Python has an interesting feature – this is it here →
```py
# read two numbers
number1 = int(input("Enter first number: "))
number2 = int(input("Enter second number: "))

# choose the larger number
if number1 > number2: max = number1
else: max = number2

# print the result
print("The larger number is ", max)
```
Note: if any of the `if`-`elif`-`else` branches contains just one instruction, you may code it in a more comprehensive form (you don’t need to make an indented line after the keyword, but just continue the line after the colon).
We personally think it’s ugly and misleading, and we’re not going to use this style in our future programs, but it’s definitely worth knowing if you want to read and understand someone else’s programs.
There are no other differences in the code.\
It’s time to complicate the code – let’s find the largest of three numbers. Will it enlarge the code? A bit.

#### 2.1.24 Some simple examples
Let’s try to find the largest of three numbers.
We assume that the first value is the largest. Then we verify this hypothesis with the two remaining values.
Here we go →
```py
# read two numbers
number1 = int(input("Enter first number: "))
number2 = int(input("Enter second number: "))
number3 = int(input("Enter third number: "))

# we temporarily assume that the first number is the largest one; we will verify it soon
max = number1

# we check if the third value is larger than current max and update max if needed
if number3 > max:
  max = number3

# print the result
print("The largest number is ", max)
```
This method is significantly simpler than trying to find the largest number all at once, by comparing all possible pairs of numbers (i.e., first with second, second with third, third with first).\
Try to rebuild the code for yourself.

#### 2.1.25 Some simple examples
You should now be able to write a program which finds the largest of four, five, six, or even ten numbers.
You already know the scheme, so extending the size of the problem will not be particularly complex.
But what happens if we ask you to write a program that finds the largest of two hundred numbers? Can you imagine the code?
You’ll need two hundred variables. If two hundred variables isn’t bad enough, try to imagine searching for the largest of a million numbers.
Imagine a code that contains 199 conditional statements and two hundred invocations of the input() function.
Luckily, you don’t need to deal with that. There’s a simpler approach.

#### 2.1.26 Some simple examples
We’ll ignore the requirements of Python syntax for now, and try to analyze the problem without thinking about the real programming. In other words, we’ll try to write the algorithm, and when we’re happy with it, we’ll implement it.
In this case, we’ll use a kind of notation which is not an actual programming language (it can be neither compiled nor executed), but it is formalized, concise and readable.
It’s called **pseudocode**.\
There’s an example of pseudocode here →
```
1.max = -999999
2.number=int(input())
3.if number == -1:
4.  print(max)
5.  exit()
6.if number > max:
7.  max = number
8. go to line number 2
```
Take a look at it. What’s happening in it?
Firstly, we can simplify the program if, at the very beginning of the code, we assign the variable max with a value which will be smaller than any of the entered numbers. We’ll use -999999999 for that purpose.\
Secondly, we assume that our algorithm will not know in advance how many numbers will be delivered to the program. We expect that the user will enter as many numbers as she/he wants – the algorithm will work well with one hundred and with one thousand numbers. How do we do that?\
We make a deal with the user: when the value -1 is entered, it will be a sign that there are no more data and the program should end its work.
Otherwise, if the entered value is not equal to -1, the program will read another number, and so on.
The trick is based on the assumption that any part of the code can be performed more than once – precisely, as many times as needed.
Performing a certain part of the code more than once is called a loop. The meaning of this term is probably obvious to you.
Lines 02 through 08 make a loop. We’ll pass through them as many times as needed to review all the entered values.
Can you use a similar structure in a program written in Python?
Yes, you can.

#### 2.2.1 Looping your code with while
Do you agree with the statement presented here? →
```
while there is something to do
  do it
```
Note that this record also declares that if there is nothing to do, nothing at all will happen.

#### 2.2.2 Looping your code with while
In general, in Python, a loop is as follows →
```py
while conditional_expression:
  instruction
  ```
If you notice some similarities to the `if` instruction, that’s quite all right. Indeed, the syntactic difference is only one: you use the word `while` instead of the word `if`. The semantic difference is more important: when the condition is met, `if` performs its statements only once; while repeats the execution as long as the condition evaluates to `True`.\
Note: all the rules regarding indentation are applicable here, too. We’ll show you this soon.

#### 2.2.3 Looping your code with while
Let’s take a look at some specific comments:
- if you want to execute more than one statement inside one `while`, you must (as with `if`) indent all the instructions in the same way – take a look here →
```py
while conditional_expression:
  instruction_1
  instruction_2
  instruction_3
  instruction_n
```
- an instruction or set of instructions executed inside the while loop is called the loop’s body;
- if the condition is `False` (equal to zero) as early as when it is tested for the first time, the body is not executed even once (note the analogy of not having to do anything if there is nothing to do)
- the body should be able to change the condition’s value, because if the condition is `True` at the beginning, the body might run continuously to infinity – notice that doing a thing usually decreases the number of things to do)

#### 2.2.4 Looping your code with while
Here’s an example of a loop that is not able to finish its execution →
```py
while True:
  print("I'm stuck inside a loop")
```
This loop will infinitely print “I’m stuck inside a loop” on the screen.
Let’s go back to the sketch of the algorithm we showed you recently. We’re going to show you how to use this newly learned loop to find the largest number from a large set of entered data.

#### 2.2.5 Looping your code with while
Analyze the program carefully. Locate the loop’s body and find out how the body is exited.
Check how this code implements the algorithm we showed you earlier.
```py
# we will store the current greatest number here
max = -999999

# get the first value *
number = int(input("Enter value or -1 to stop: "))

# if the number is not equal to -1 we will continue
while number != -1:

  # is the number greater than max?
  if number > max:
    
    # yes - update max
    max = number
  
  # get next number
  number = int(input("Enter value or -1 to stop: "))

# print the largest number
print("The largest number is ", max)
```

#### 2.2.6 Looping your code with while
Let’s look at another example employing the while loop →
```py
# program reads a sequence of numbers and counts how many numbers are even and odd and terminates when zero is entered
Evens = 0
Odds = 0

# read first number
Number = int(input("Enter a value or 0 to stop: "))
# 0 terminates execution
while Number != 0:
  # check if the number is odd
  if Number % 2 == 1:
    # increase "odd" counter
    Odds += 1
  else:
    # increase "even" counter
    Evens += 1
  # read next number
  Number = int(input("Enter a value or 0 to stop: "))
# print results
print("Even numbers: ", Evens)
print("Odd numbers: ", Odds)
```
Follow the comments to find out the idea and the solution.
Certain expressions can be simplified without changing the program’s behavior. Take a look at the next slide.

#### 2.2.7 Looping your code with while
Try to recall how Python interprets the truth of a condition, and note that these two forms are equivalent →
```py
while Number != 0:

while Number:
```

#### 2.2.8 Looping your code with while
The condition that checks if a number is odd can be coded in these equivalent forms →
```py
if Number % 2 == 1:

if Number % 2:
```

#### 2.2.9 Looping your code with while
This code is intended to repeat the introduction exactly five times.
But there’s one things that can be written more compactly – the condition of the `while` loop.

#### 2.2.10 Looping your code with while
Can you see the difference?
Is it more compact than previously? A bit.
Is it more legible? That’s disputable.
Don’t feel obliged to code your programs in a way that is always the shortest and the most compact. Readability may be a more important factor. Keep your code ready for a new programmer.
```py
counter = 5
while counter:
  print("My name is Python...")
  counter -= 1
```

#### 2.2.11 Looping your code with while
Another kind of loop available in Python comes from the observation that sometimes it’s more important to count the “turns” of the loop than to check the conditions.
Imagine that a loop’s body needs to be executed exactly one hundred times. If you would like to use the while loop to do it, it may look like this →
```py
i = 0
while i < 100:
  # do something
  i += 1
```
It would be nice if somebody could do this boring counting for you. Is that possible?
Of course it is – there’s a special loop for these kinds of tasks, and it is named for.
Actually, the for loop is designed to do more complicated tasks – it can “browse” large collections of data item by item. We’ll show you how to do that soon, but right now we’re going to present a simpler variant of its application.

#### 2.2.12 Looping your code with for
Take a look at the snippet →
```py
for i in range(100):
  # do something
  pass
```
There are some new elements. Let us tell you about them:
- the `for` keyword opens the `for` loop; note – there’s no condition after it; you don’t have to think about conditions, as they’re checked internally, without any intervention;
- any variable after the `for` keyword is the **control variable** of the loop; it counts the loop’s turns, and does it automatically;
- the `in` keyword introduces a syntax element describing the range of possible values being assigned to the control variable;
- the `range()` function (this is a very special function) is responsible for generating all the desired values of the control variable; in our example, the function will create (we can even say that it will feed the loop with) subsequent values from the following set: 0, 1, 2 .. 97, 98, 99; note: in this case, the `range()` function starts its job from 0 and finishes it one step (one integer number) before the value of its argument;
- note the `pass` keyword inside the loop body – it does nothing at all; it’s an empty instruction – we put it here because the for loop’s syntax demands at least one instruction inside the body (by the way – `if`, `elif`, `else` and `while` express the same thing)

Our next examples will be a bit more modest in the number of loop repetitions.

#### 2.2.13 Looping your code with for
Take a look at the snippet →
```py
for i in range(10):
  print("Value of i is currently", i)
```
Can you predict its output?

#### 2.2.14 Looping your code with for
This is the answer →
```
Value of i is currently 0
Value of i is currently 1
Value of i is currently 2
Value of i is currently 3
Value of i is currently 4
Value of i is currently 5
Value of i is currently 6
Value of i is currently 7
Value of i is currently 8
Value of i is currently 9
```
Note:
- the loop has been executed ten times (it’s the range() function’s argument)
- the last control variable’s value is 9 (not 10, as it starts from 0, not from 1)

#### 2.2.15 Looping your code with for
The `range()` function invocation may be equipped with two arguments, not just one →
```py
for i in range(2,8):
  print("Value of i is currently", i)
```
In this case, the first argument determines the initial (first) value of the control variable.\
The last argument shows the first value the control variable will not be assigned.\
Note: the `range()` function accepts only integers as its arguments, and generates sequences of integers.\
Can you guess the output of the program?

#### 2.2.16 Looping your code with for
Here it is →
```
Value of i is currently 2
Value of i is currently 3
Value of i is currently 4
Value of i is currently 5
Value of i is currently 6
Value of i is currently 7
```
The first shown value is 2 (taken from the `range()`’s first argument)
The last is 7 (although the `range()`’s second argument is 8).

#### 2.2.17 Looping your code with for
The `range()` function may also accept three arguments– take a look →
```py
for i in range(2,8,3):
  print("Value of i is currently", i)
```
The third argument is an increment – it’s a value added to control the variable at every loop turn (as you may suspect, the default value of the increment is 1).\
Can you tell us how many lines will appear in the console and what values they will contain?

#### 2.2.18 Looping your code with for
These are the two expected lines →
```
Value of i is currently 2
Value of i is currently 5
```

#### 2.2.19 Looping your code with for
Note: if the set generated by the `range()` function is empty, the loop won’t execute its body at all.\
Just like here – there will be no output →
```py
for i in range(1,1):
  print("Value of i is currently", i)
```

#### 2.2.20 Looping your code with for
Note: the set generated by the range() has to be sorted in ascending order. There’s no way to force the range() to create a set in a different form. This means that the range()’s second argument must be greater than the first.\
Thus, there will be no output here, either →
```py
for i in range(2,1):
print("Value of i is currently", i)
```

#### 2.2.21 Looping your code with for
Let’s have a look at a short program whose task is to write some of the first powers of two →
```py
pow = 1
for exp in range(16):
  print("2 to the power of ", exp, " is ", pow)
  pow *= 2
```
The `exp` variable is used as a control variable for the loop, and indicates the current value of the exponent. The exponentiation itself is replaced by multiplying by two. Since 20 is equal to 1, then 2 × 1 is equal to 2<sup>1</sup>, 2 × 2<sup>1</sup> is equal to 2<sup>2</sup>, and so on. What is the greatest exponent for which our program still prints the result?

#### 2.2.22 The break and continue statements
So far, we’ve treated the body of the loop as an indivisible and inseparable sequence of instructions that are performed completely at every turn of the loop. However, as developer, you could be faced with the following choices:
- it appears that it’s unnecessary to continue the loop as a whole; you should refrain from further execution of the loop’s body and go further;
- it appears that you need to start the next turn of the loop without completing the execution of the current turn.

Python provides two special instructions for the implementation of both these tasks. Let’s say for the sake of accuracy that their existence in the language is not necessary – an experienced programmer is able to code any algorithm without these instructions. Such additions, which don’t improve the language’s expressive power, but only simplify the developer’s work, are sometimes called **syntactic candy**,or **syntactic sugar**.

These two instructions are:
- `break` – exits the loop immediately, and unconditionally ends the loop’s operation; the program begins to execute the nearest instruction after the loop’s body;
- `continue` – behaves as if the program has suddenly reached the end of the body; the next turn is started and the condition expression is tested immediately.

Both these words are keywords.\
Now we’ll show you two simple examples. Let’s return to our program that recognizes the largest among the entered numbers. We’ll convert it twice, using both instructions. Analyze the code, and judge whether and how you would use either of them.\
The `break` variant goes here →
```py
max = -999999
counter = 0

while True:
  number = int(input("Enter a value: "))
  if number == -1:
    break
  counter += 1
  if number > max:
    max = number
if counter:
  print("The largest number is ", max)
else:
  print("Are you kidding? You haven't entered any value!")
```

#### 2.2.23 The break and continue statements
And now the continue variant →
```py
max = -999999
counter = 0

while True:
  number = int(input("Enter a value: "))
  if number == -1:
    continue
  counter += 1
  if number > max:
    max = number
if counter:
  print("The largest number is ", max)
else:
  print("Are you kidding? You haven't entered any value!")
```

#### 2.2.24 Loops and else
Both loops, `while` and `for`, have one interesting (and rarely used) feature. 
We’ll show you how it works – try to judge for yourself if it’s usable and whether you can live without it or not.
In other words, try to convince yourself if the feature is valuable and useful, or is just syntactic sugar.\
Take a look at the snippet →
```py
i = 1
while i < 5:
  print(i)
  i += 1
else:
  print("else: ", i)
```
There’s something strange at the end – the `else` keyword.
As you may have suspected, loops may have the `else` branch too, like `if`s.
The loop’s `else` branch is always executed once, regardless of whether the loop has entered its body or not.
Can you guess the output?

#### 2.2.25 Loops and else
This is what it looks like →
```
1
2
3
4
else: 5
```

#### 2.2.26 Loops and else
We’ve modified the snippet a bit – the loop has no chance to execute its body even once →
```py
i = 5
while i < 5:
  print(i)
  i += 1
else:
  print("else:", i)
```
The `while`’s condition is `False` at the beginning – can you see it?

#### 2.2.27 Loops and else
As you can see, the `else` branch has been executed despite that →
```
else: 5
```

#### 2.2.28 Loops and else
`for` loops behave a bit differently – take a look at the snippet →
```py
for i in range(5):
  print(i)
else:
  print("else: ", i)
```
The output may be a bit surprising.

#### 2.2.29 Loops and else
Here it is →
```
0
1
2
3
4
else: 4
```
Note: the `i` variable retains its last value here.

#### 2.2.30 Loops and else
This is our last experiment →
```py
i = 111
for i in range(2,1):
  print(i)
else:
  print("else: ", i)
```
The loop’s body won’t be executed here at all.
Note: we’ve assigned the i variable before the loop.

#### 2.2.31 Loops and else
Here’s the puzzle’s solution →
```
else: 111
```
When the loop’s body isn’t executed, the control variable retains the value it had before the loop.\
Note: if the control variable doesn’t exist before the loop starts, it won’t exist when the execution reaches the else branch.\
How do you feel about this variant of `else`?
Now we’re going to tell you about some other kinds of variables. Our current variables can only store one value at a time, but there are variables that can do much more – they can store as many values as you want.

#### 2.3.1 Computer logic
Have you noticed that the conditions we’ve used so far have been very simple, not to say, quite primitive? The conditions we use in real life are much more complex. Let’s look at this sentence:
> If we have some free time, and the weather is good, we will go for a walk.

We’ve used the conjunction “and”, which means that going for a walk depends on the simultaneous fulfilment of these two conditions. In the language of logic, such a connection of conditions is called a conjunction. And now another example:\
> If you are in the mall or I am in the mall, one of us will buy a gift for Mom.

The appearance of the word “or” means that the purchase depends on at least one of these conditions. In logic, such a compound is called a **disjunction**.\
It’s clear that Python must have operators to build conjunctions and disjunctions. Without them, the expressive power of the language would be substantially weakened. They’re called **logical operators**.

#### 2.3.2 Pride and Prejudice
One logical conjunction operator in Python is the word and. It’s a binary operator with a priority that is lower than the one expressed by the comparison operators. It allows us to code complex conditions without the use of parentheses like this one →
```
Counter > 0 and Value == 100
```

#### 2.3.3 Pride and Prejudice
The result provided by the and operator can be determined on the basis of the truth table.\
If we consider the conjunction of:
```
Left and Right
```
the set of possible values of arguments and corresponding values of the conjunction looks as follows →

`Left`  | `Right` | `Left AND Right`
---     | ---     | ---
False   | True    | False
False   | False   | False
True    | False   | False
True    | True    | True

#### 2.3.4 To be or not to be
A disjunction operator is the word or. It’s a binary operator with a lower priority than and (just like `+` compared to `*`). Its truth table is as follows →

`Left`  | `Right` | `Left OR Right`
---     | ---     | ---
False   | True    | True
False   | False   | False
True    | False   | True
True    | True    | True

#### 2.3.5 To be or not to be
In addition, there’s another operator that can be applied for constructing conditions. It’s a unary operator performing a logical negation. Its operation is simple: it turns truth into falsehood and falsehood into truth. This operator is written as the word not, and its priority is very high: the same as the unary `+`/`-`. Its truth table is simple →

`Arg` | `NOT Arg`
---   | ---
False | True
True  | False

#### 2.3.6 Some logical expressions
Note that the following conditions are pairwise equivalent →
```
Variable > 0
NOT (Variable <= 0)

Variable != 0
NOT (Variable == 0)
```

#### 2.3.7 Some logical expressions
You may remember De Morgan’s laws from school. They say that:
> The negation of a conjunction is the disjunction of the negations.
> The negation of a disjunction is the conjunction of the negations.

Let’s write the same thing using Python →
```py
not(p and q) == (not p) or (not q)
not (p or q) == (not p) and (not qq)
```
Note how the parentheses have been used to code the expressions – we put them there to improve readability.\
We should add that none of these two-argument operators can be used in the abbreviated form known as op=. This exception is worth remembering.

#### 2.3.8 Logical values vs. single bits
Logical operators take their arguments as a whole regardless of how many bits they contain. The operators are aware only of the value: zero (when all the bits are reset) means False; not zero (when at least one bit is set) means True. The result of their operations is one of these values: False or True. This means that this snippet will assign the value True to the j variable if i is not zero; otherwise, it will be False.
```py
i == 1
j == not not i
```

#### 2.3.9 Logical values vs. single bits
However, there are four operators that allow you to manipulate single bits of data. They are called bitwise operators. They cover all the operations we mentioned before in the logical context, and one additional operator. This is the xor (as in exclusive or) operator, and is denoted as ^ (caret). Here are all of them:
- `&` (ampersand) bitwise conjunction
- `|` (bar) bitwise disjunction
- `~` (tilde) bitwise negation
- `^` (caret) bitwise exclusive or (`xor`)

Let’s make it easier:
- `&` requires exactly two 1s to provide 1 as the result;
- `|` requires at least one 1 to provide 1 as the result;
- `^` requires exactly one 1 to provide 1 as the result.

Let us add an important remark: the arguments of these operators must be integers; we must not use floats here.\
The difference in the operation of the logical and bit operators is important: the logical operators do not penetrate into the bit level of its argument. They’re only interested in the final integer value.\
Bitwise operators are stricter: they deal with every bit separately. If we assume that the integer variable occupies 64 bits (which is common in modern computer systems), you can imagine the bitwise operation as a 64-fold evaluation of the logical operator for each pair of bits of the arguments. This analogy is obviously imperfect, as in the real world all these 64 operations are performed at the same time (simultaneously).

`Left`  | `Right` | `Left & Right`  | `Left \| Right` | `Left ^ Right`
---     | ---     | ---             | ---             | ---
0       | 0       | 0               | 0               | 0
0       | 1       | 0               | 1               | 1
1       | 0       | 0               | 1               | 1
1       | 1       | 1               | 1               | 0

`Arg` | `~Arg`
---   | ---
0     | 1
1     | 0

#### 2.3.10 Logical values vs. single bits
We’ll now show you an example of the difference in operation between the logical and bit operations. Let’s assume that the following assignments have been performed:
> i = 15
> j = 22

If we assume that the integers are stored with 32 bits, the bitwise image of the two variables will be as follows →
```
i: 00000000000000000000000000001111
j: 00000000000000000000000000010110
```

#### 2.3.11 Logical values vs. single bits
The assignment is given:
```py
log = i and j
```
We are dealing with a logical conjunction here. Let’s trace the course of the calculations. Both variables iandj are not zeros, so will be deemed to represent True. Consulting the truth table for the and operator, we can see that the result will be True. No other operations are performed.
```
log: True
```

#### 2.3.12 Logical values vs. single bits
Now the bitwise operation – here it is:
```py
bit = i & j
```
The `&` operator will operate with each pair of corresponding bits separately, producing the values of the relevant bits of the result. Therefore, the result will be as follows →

`i` | `00000000000000000000000000001111`
`j` | `00000000000000000000000000010110`
`bit = i & j` | `00000000000000000000000000000110`

These bits correspond to the integer value of six.

#### 2.3.13 Logical values vs. single bits
Let’s look at the negation operators now. First the logical one:
```py
logneg = not i
```
The logneg variable will be set to `False` – nothing more needs to be done.\
The bitwise negation goes like this:
```py
bitneg = ~i
```
It may be a bit surprising: the bitneg variable value is -16. This may seem strange, but isn’t at all. If you wish to learn more, you should check out the binary numeral system and the rules governing two’s complement numbers.

`i` | `00000000000000000000000000001111`
`bit = ~i` | `11111111111111111111111111110000`

#### 2.3.14 Logical values vs. single bits
Each of these two-argument operators can be used in abbreviated form. These are the examples of their equivalent notations →

---           | ---
`x = x & y`   | `x &= y`
`x = x \| y`  | `x \|\= y`
`x = x ^ y`   | `x ^= y`

#### 2.3.15 How do we deal with single bits?
We’ll now show you what you can use bitwise operators for. Imagine that you’re a developer obliged to write an important piece of an operating system. You’ve been told that you’re allowed to use a variable assigned in the following way →
```
FlagRegister = 0x1234
```

#### 2.3.16 How do we deal with single bits?
The variable stores the information about various aspects of system operation. Each bit of the variable stores one yes/no value. You’ve also been told that only one of these bits is yours – the third (remember that bits are numbered from zero, and bit number zero is the lowest one, while the highest is number 31). The remaining bits are not allowed to change, because they’re intended to store other data. Here’s your bit marked with the letter x→
```
FlagRegister = 0000000000000000000000000000x000
```

#### 2.3.17 How do we deal with single bits?
You may be faced with the following tasks:
- **check the state of your bit** – you want to find out the value of your bit; comparing the whole variable to zero will not do anything, because the remaining bits can have completely unpredictable values, but you can use the following conjunction property:
```
x & 1 = x
x & 0 = 0
```
If you apply the `&` operation to the FlagRegister variable along with the following bit image:
```
0000000000000000000000000000001000
```
(note the 1 at your bit’s position) as the result, you obtain one of the following bit strings:
```
0000000000000000000000000000001000 if your bit was set to 1
0000000000000000000000000000000000 if your bit was reset to 0
```
Such a sequence of zeros and ones, whose task is to grab the value or to change the selected bits, is called a **bit mask**. Let’s build a bit mask to detect the state of your bit. It should point to the third bit. That bit has the weight of 23 = 8. A suitable mask could be created by the following declaration:
```py
TheMask = 8
```
You can also make a sequence of instructions depending on the state of your bit – here it is →
```py
if FlagRegister & TheMask:
  # my bit is set
else:
  # my bit is set
```

#### 2.3.18 How do we deal with single bits?
- **reset your bit** – you assign a zero to the bit while all the other bits must remain unchanged; let’s use the same property of the conjunction as before, but let’s use a slightly different mask – exactly as below:
```
1111111111111111111111111111110111
```
Note that the mask was created as a result of the negation of all the bits of TheMask variable. Resetting the bit is simple, and looks like this (choose the one you like more) →
```py
FlagRegister = FlagRegister & ~TheMask
FlagRegister &= ~TheMask
```

#### 2.3.19 How do we deal with single bits?
- **set your bit** – you assign a 1 to your bit, while all the remaining bits must remain unchanged; use the following disjunction property:
```
x | 1 = 1
x | 0 = x
```
You’re now ready to set your bit with one of the following instructions →
```py
FlagRegister = FlagRegister | TheMask
FlagRegister |= TheMask
```

#### 2.3.20 How do we deal with single bits?
- **Negate your bit** – you replace a 1 with a 0 and a 0 with a 1. You can use an interesting property of the xor operator:
```
x ^ 1 = ~x
x ^ 0 = x
```
and negate your bit with the following instructions →
```py
FlagRegister = FlagRegister ^ TheMask
FlagRegister ^= TheMask
```

#### 2.3.21 How do we deal with single bits?
Python offers yet another operation relating to single bits: shifting. This is applied only to integer values, and you mustn’t use floats as arguments for it. You already apply this operation very often and quite unconsciously. How do you multiply any number by ten? Take a look:
```
12345 × 10 = 123450
```
As you can see, multiplying by ten is in fact a shift of all the digits to the left and filling the resulting gap with zero. Division by ten? Take a look:
```
12340 ÷10 = 1234
```
Dividing by ten is nothing but shifting the digits to the right.\
The same kind of operation is performed by the computer, but with one difference: as two is the base for binary numbers (not 10), shifting a value one bit to the left thus corresponds to multiplying it by two; respectively, shifting one bit to the right is like dividing by two (notice that the rightmost bit is lost).\
The shift operators in Python are a pair of digraphs, << and >>, clearly suggesting in which direction the shift will act. The left argument of these operators is an integer value whose bits are shifted. The right argument determines the size of the shift. It shows that this operation is certainly not commutative.\
The priority of these operators is very high. You’ll see them in the updated table of priorities, which we’ll show you at the end of this section.
```
Value << Bits
Value >> Bits
```

#### 2.3.22 How do we deal with single bits?
Take a look at these shifts →
```py
Var = 17
VarRight = Var >> 1
VarLeft = Var << 2
print(Var, VarLeft, VarRight)
```
The final `print()` invocation produces the following output:
```
17 68 8
```
Note:
- `17 // 2 → 8` (shifting to the right by one bit is the same as integer division by two)
- `17 * 4 → 68` (shifting to the left by two bits is the same as integer multiplication by four)

#### 2.3.23 How do we deal with single bits?
And here is the updated priority table, containing all the operators introduced so far →

--- | ---
`!` `~` `++` `--` `+` `-` | unary
`*` `/` `%` 
`+` `-` | binary
`>>` `<<` 
`<` `>` `<=` `>=`
`==` `!=`
`&`
`\|`
`&&`
`\|\|`
`=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `\|=` `>>=` `<<=`

